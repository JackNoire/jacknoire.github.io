{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/01/12/hello-world/"},{"title":"在Windows中使用CreateProcess创建子进程","text":"本文记录了在Windows中使用CreateProcessA创建子进程的方法。 CreateProcessA函数原型123456789101112BOOL CreateProcessA( LPCSTR lpApplicationName, //应用程序名 LPSTR lpCommandLine, //命令行 LPSECURITY_ATTRIBUTES lpProcessAttributes, //如果为NULL，则子进程不会继承新进程的句柄 LPSECURITY_ATTRIBUTES lpThreadAttributes, //如果为NULL，则子进程不会继承新线程的句柄 BOOL bInheritHandles, //父进程的可继承句柄是否继承给新的进程 DWORD dwCreationFlags, //控制子进程的创建过程和优先级的标志 LPVOID lpEnvironment, //如果为NULL，则新的进程会使用父进程的环境 LPCSTR lpCurrentDirectory, //如果为NULL，则新的进程与父进程会有相同目录 LPSTARTUPINFOA lpStartupInfo, //用于设置新进程的主窗口特性 LPPROCESS_INFORMATION lpProcessInformation //PROCESS_INFORMATION指针，用于获取新进程的信息); 本文只关心lpApplicationName, lpCommandLine, lpStartupInfo, lpProcessInformation 这四个参数。 简单示例接下来，写一个简单的示例来说明这个函数的基本用法。 编写程序作为子进程编写child.c，代码为： 12345678#include &lt;stdio.h&gt;int main(int argc, char **argv) { for(int i = 0; i &lt; argc; i++) { printf(&quot;argv[%d]: %s\\n&quot;, i, argv[i]); } return 0;} 功能很简单，就是打印argv字符串数组的内容。编译后在命令行中运行child 123456789 abcdefg !@#$%： 12345&gt; child 123456789 abcdefg !@#$%argv[0]: childargv[1]: 123456789argv[2]: abcdefgargv[3]: !@#$% 编写程序调用CreateProcessA创建子进程编写程序parent，代码如下： 12345678910111213141516171819#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;int main() { STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); CreateProcessA( &quot;child.exe&quot;, //lpApplicationName &quot;abcdefg !@#$%^&amp;&quot;, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation return 0;} parent会调用CreateProcessA，创建子进程child，而child则会打印argv数组： 123&gt; parentargv[0]: abcdefgargv[1]: !@#$%^&amp; child中argv的内容和lpCommandLine字符串的内容是一致的。 lpApplicationName可以为NULL，此时应用程序的名字为lpCommandLine中第一个被空格隔开的字符串： CreateProcessA function (processthreadsapi.h) 对简单示例的进一步完善对创建进程操作是否成功的判断CreateProcessA会返回BOOL类型的变量，表示本次创建进程的操作是否成功。因此，可以加上对函数返回值的判断： 1234567891011121314BOOL result = CreateProcessA( &quot;child.exe&quot;, //lpApplicationName &quot;abcdefg !@#$%^&amp;&quot;, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformationif(!result) { printf(&quot;Create Process Failed!\\n&quot;); return -1;} 创建进程失败时获取错误码如果CreateProcessA返回FALSE，则可以通过GetLastError获取错误码，GetLastError定义在头文件errhandlingapi.h中。 1234if(!result) { printf(&quot;Create Process Failed! Error Code:%d\\n&quot;, GetLastError()); return -1;} 在调用CreateProcessA之前，会通过STARTUPINFO si = {0};将STARTUPINFO结构体si的内容清零。现在将清零操作去掉，重新编译运行parent，看是否还能成功创建子进程： 12&gt; parentCreate Process Failed! Error Code:998 创建子进程失败了，错误码为998，查阅System Error Codes (500-999)： ERROR_NOACCESS 998 (0x3E6) Invalid access to memory location. 发生了对内存地址的无效访问。这说明STARTUPINFO结构体使用之前清零是有必要的。 通过PROCESS_INFORMATION结构体获取子进程信息CreateProcessA的最后一个参数为LPPROCESS_INFORMATION lpProcessInformation，是一个PROCESS_INFOMATION结构体指针。PROCESS_INFOMATION的定义为： 123456typedef struct _PROCESS_INFORMATION { HANDLE hProcess; HANDLE hThread; DWORD dwProcessId; DWORD dwThreadId;} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; CreateProcessA会创建一个进程和它的主线程，hProcess就是这个进程的句柄，hThread就是进程的主线程的句柄。dwProcessId和dwThreadId分别为进程和它的主线程的标识符ID。 简单示例中传入的参数为&amp;pi，因此就可以通过pi得到创建的进程以及其主线程的句柄和标识符了。添加如下代码，打印子进程的进程标识符： 1printf(&quot;Child Process ID: %d\\n&quot;, pi.dwProcessId); 运行parent： 1234&gt; parentChild Process ID: 13816argv[0]: abcdefgargv[1]: !@#$%^&amp; 父进程等待子进程执行结束在Linux中，父进程可以通过wait系统调用等待子进程执行完毕。Windows中也有类似的功能，即WaitForSingleObject。 WaitForSingleObject的函数原型为： 1234DWORD WaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds); 需要传入两个参数，hHandle为对象的句柄，dwMilliseconds为等待的毫秒数。如果对象结束，或对象没有结束但经过了dwMilliseconds毫秒，则等待完毕，进程继续执行后面的语句。 父进程可以通过PROCESS_INFORMATION结构体获取子进程的进程句柄，然后再将子进程的句柄传入WaitForSingleObject中，即可等待子进程执行完毕。 在打印子进程ID前，添加语句： 1WaitForSingleObject(pi.hProcess, 10000); 再运行parent，得到的结果为： 1234&gt; parentargv[0]: abcdefgargv[1]: !@#$%^&amp;Child Process ID: 3944 说明父进程会等待子进程child执行完毕后再打印子进程的ID。 关闭PROCESS_INFORMATION中的句柄一个更好的习惯是在PROCESS_INFORMATION中的句柄使用完毕后，用CloseHandle将其关闭。 If the function succeeds, be sure to call the CloseHandle function to close the hProcess and hThread handles when you are finished with them. Otherwise, when the child process exits, the system cannot clean up the process structures for the child process because the parent process still has open handles to the child process. However, the system will close these handles when the parent process terminates, so the structures related to the child process object would be cleaned up at this point. 在parent.c的末尾添加CloseHandle代码： 12CloseHandle(pi.hProcess);CloseHandle(pi.hThread); 最终，得到的完整的parent.c代码为： 123456789101112131415161718192021222324252627282930#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;#include &lt;errhandlingapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;handleapi.h&gt;int main() { STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); BOOL result = CreateProcessA( &quot;child.exe&quot;, //lpApplicationName &quot;abcdefg !@#$%^&amp;&quot;, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation if(!result) { printf(&quot;Create Process Failed! Error Code:%d\\n&quot;, GetLastError()); return -1; } WaitForSingleObject(pi.hProcess, 10000); printf(&quot;Child Process ID: %d\\n&quot;, pi.dwProcessId); CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0;}","link":"/2021/01/17/windows-createprocess/"},{"title":"Windows读写其他进程内存的方法","text":"本文记录了如何使用Windows提供的ReadProcessMemory和WriteProcessMemory对其他进程的内存空间进行读写操作。 ReadProcessMemory和WriteProcessMemory的函数原型1234567BOOL ReadProcessMemory( HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead); 1234567BOOL WriteProcessMemory( HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten); Microsoft的文档中有对每个参数的详细解释： ReadProcessMemory function (memoryapi.h) WriteProcessMemory function (memoryapi.h) 使用这两个函数，需要传入目标进程的句柄、想要读写内存的基地址、读写内存的大小等信息。在通过CreateProcess创建子进程时，可以通过PROCESS_INFORMATION结构体得到子进程的句柄。因此，先来看读写子进程内存的方法。 读写子进程内存编写子进程子进程的功能为打印全局变量i的值，并使变量i不断自增。 12345678910#include &lt;stdio.h&gt;#include &lt;synchapi.h&gt;int i;int main() { while(1) { printf(&quot;%d. &quot;, i++); Sleep(100); }} 运行结果为： 12&gt; child0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 编写父进程读取子进程内存父进程首先要通过CreateProcess创建子进程，然后通过PROCESS_INFORMATION结构体获取子进程的句柄。之后，再将句柄传入ReadProcessMemory，即可读取子进程的内存。 如果要让父进程修改子进程的全局变量i，则需要知道i的内存地址，这可以通过反汇编工具（如IDA Pro）获取。我使用的编译器会将全局变量i的内存地址设置为0x407970，不同编译器编译得到的child中i的内存地址可能不同。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;#include &lt;errhandlingapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;handleapi.h&gt;#include &lt;memoryapi.h&gt;int main() { //创建子进程 STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); BOOL result = CreateProcessA( &quot;child.exe&quot;, //lpApplicationName NULL, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation if(!result) { printf(&quot;Create Process Failed! Error Code:%d\\n&quot;, GetLastError()); return -1; } //读写子进程全局变量i，地址为0x407970 int childi; while(1) { ReadProcessMemory(pi.hProcess, (void *)0x407970, &amp;childi, sizeof(int), NULL); printf(&quot;\\nparent read child i: %d\\n&quot;, childi); Sleep(600); } CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0;} 运行parent： 12345678910111213&gt; parentparent read child i: 00. 1. 2. 3. 4. 5.parent read child i: 66. 7. 8. 9. 10. 11.parent read child i: 1212. 13. 14. 15. 16. 17.parent read child i: 1818. 19. 20. 21. 22. 23.parent read child i: 2424. 25. 26. 27. 28. 29.parent read child i: 30 可以看出parent成功读取了child中变量i的内容。 添加修改子进程内存的代码使用WriteProcessMemory可以修改子进程中i的值。在parent中添加代码： 12345678910//读写子进程全局变量i，地址为0x407970int childi;while(1) { ReadProcessMemory(pi.hProcess, (void *)0x407970, &amp;childi, sizeof(int), NULL); if(childi &gt; 20) { childi = 0; WriteProcessMemory(pi.hProcess, (void *)0x407970, &amp;childi, sizeof(int), NULL); } Sleep(600);} 当读取到的i大于20时，就将i清零，并写入子进程的内存当中。运行parent： 12345&gt; parent0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 0. 1. 2. 3. 4. 5. 6. i大于20后不久就会被清零。之所以没有立即清零是因为parent中有一个Sleep(600);。 读取其他进程的内存读写其他进程内存需要首先获取其句柄，这可以通过函数OpenProcess得到。 OpenProcess函数原型12345HANDLE OpenProcess( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId); 因此，知道了目标进程的进程标识符ProcessId，就可以获得其句柄了。 OpenProcess function (processthreadsapi.h) 编写目标进程代码目标进程会先调用GetCurrentProcessId获取自身的进程标识符并打印出来，然后就开始不断打印全局变量i的值并将i加一。 123456789101112#include &lt;stdio.h&gt;#include &lt;synchapi.h&gt;#include &lt;processthreadsapi.h&gt;int i;int main() { printf(&quot;My Process ID: %d\\n&quot;, GetCurrentProcessId()); while(1) { printf(&quot;%d. &quot;, i++); Sleep(100); }} 编写修改器代码修改器会先根据目标进程的ProcessId获取句柄，然后再调用ReadProcessMemory和WriteProcessMemory读写目标进程的全局变量i，当i大于20时清零。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;memoryapi.h&gt;#include &lt;errhandlingapi.h&gt;int main(int argc, char **argv) { if(argc &lt; 2) { printf(&quot;Usage: modifier [pid]\\n&quot;); return -1; } //OpenProcess获得目标进程的句柄 int targetPid = atoi(argv[1]); HANDLE hTarget = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, targetPid); if(NULL == hTarget) { printf(&quot;Open Process Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } //读写目标进程全局变量i，地址为0x407970 int targetI; BOOL result; while(1) { result = ReadProcessMemory(hTarget, (void *)0x407970, &amp;targetI, sizeof(int), NULL); if(!result) { printf(&quot;Read Process Memory Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } else if(targetI &gt; 20) { targetI = 0; result = WriteProcessMemory(hTarget, (void *)0x407970, &amp;targetI, sizeof(int), NULL); if(!result) { printf(&quot;Write Process Memory Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } } Sleep(600); } return 0;} 运行结果首先运行目标程序program，得到其进程标识符为4372，然后再运行修改器程序并传入参数4372，即modifier 4372，一段时间后终止修改器。最终，program的打印结果如下： 12345678910&gt; programMy Process ID: 43720. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 全局变量i一开始会不断自增，当修改器开始运行后，i的值便被清零，然后当i的值超过20后也会被清零。修改器停止运行后，i的值又会不断自增而不会被清零。","link":"/2021/01/19/windows-modify-process-memory/"},{"title":"在Windows中创建线程和远程线程","text":"本文记录了如何使用CreateThread和CreateRemoteThread创建线程和远程线程。 创建线程CreateThread函数在Windows中创建线程可以使用CreateThread函数，其原型为： 12345678HANDLE CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, __drv_aliasesMem LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); 最重要的两个参数为lpStartAddress和lpParameter，分别表示线程的起始地址和线程函数的参数。在C语言中，可以用函数名表示函数的起始地址。如果线程创建成功，则会返回新线程的句柄。 参数的详细解释可以参考Microsoft的文档： CreateThread function (processthreadsapi.h) 下面编写一个简单示例来说明CreateThread函数的用法。 线程函数的编写由于线程可以共享进程的全局变量，因此可以编写线程对全局变量进行读写操作。 首先设置一个全局变量i： 1int i; 然后编写两个线程函数。第一个函数会让i不断加上一个数，内容为： 1234567891011121314151617/* thread_func1 * 传入参数： * param[0]: 循环次数 * param[1]: 自增数 * 功能： * 每次循环让全局变量i加上param[1] * 循环param[0]次 */void thread_func1(int *param) { printf(&quot;Thread 1 Start\\n&quot;); for(int j = 0; j &lt; param[0]; j++) { i += param[1]; printf(&quot;%d. &quot;, i); Sleep(100); } printf(&quot;\\nThread 1 End\\n&quot;);} 第二个函数会检查i是否大于某个值，如果是则会将i清零： 12345678910111213141516171819/* thread_func2 * 传入参数： * param[0]: 循环次数 * param[1]: 上限 * 功能： * 每次循环检查全局变量i是否大于param[1] * 如果大于param[1]则将i清零 * 循环param[0]次 */void thread_func2(int *param) { printf(&quot;\\nThread 2 Start\\n&quot;); for(int j = 0; j &lt; param[0]; j++) { if(i &gt; param[1]) { i = 0; } Sleep(100); } printf(&quot;\\nThread 2 End\\n&quot;);} CreateThread中函数的参数只允许传入一个，所以如果需要传入多个参数，可以通过传入数组来实现。 main函数的编写接下来编写main函数。 首先要准备两个函数参数的数组： 12int func1_param[2] = {70, 3};int func2_param[2] = {30, 20}; 第一个函数的两个参数为70和3，说明要循环70次，每次循环i要加上3；第二个函数的两个参数为30和20，说明要循环30次，如果i大于20则将i清零。 然后调用CreateThread先后创建两个线程： 123456789101112131415161718192021222324HANDLE threadHandles[2];//创建第一个线程，执行thread_func1threadHandles[0] = CreateThread(NULL, //lpThreadAttributes 0, //dwStackSize thread_func1, //lpStartAddress func1_param, //lpParameter 0, //dwCreationFlags NULL); //lpThreadIdif(NULL == threadHandles[0]) { //检查线程是否创建成功 printf(&quot;Create Thread 1 Failed! Error Code: %d\\n&quot;, GetLastError()); return -1;}//2秒后创建第二个线程，执行thread_func2Sleep(2000);threadHandles[1] = CreateThread(NULL, //lpThreadAttributes 0, //dwStackSize thread_func2, //lpStartAddress func2_param, //lpParameter 0, //dwCreationFlags NULL); //lpThreadIdif(NULL == threadHandles[1]) { //检查线程是否创建成功 printf(&quot;Create Thread 2 Failed! Error Code: %d\\n&quot;, GetLastError()); return -1;} 如果要等待两个线程同时结束后再继续接下来的操作，则可以使用WaitForMultipleObjects： 1WaitForMultipleObjects(2, threadHandles, TRUE, 100000); 最后关闭句柄： 123CloseHandle(threadHandles[0]);CloseHandle(threadHandles[1]);return 0; 完整代码及运行结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;errhandlingapi.h&gt;#include &lt;handleapi.h&gt;int i;/* thread_func1 * 传入参数： * param[0]: 循环次数 * param[1]: 自增数 * 功能： * 每次循环让全局变量i加上param[1] * 循环param[0]次 */void thread_func1(int *param) { printf(&quot;Thread 1 Start\\n&quot;); for(int j = 0; j &lt; param[0]; j++) { i += param[1]; printf(&quot;%d. &quot;, i); Sleep(100); } printf(&quot;\\nThread 1 End\\n&quot;);}/* thread_func2 * 传入参数： * param[0]: 循环次数 * param[1]: 上限 * 功能： * 每次循环检查全局变量i是否大于param[1] * 如果大于param[1]则将i清零 * 循环param[0]次 */void thread_func2(int *param) { printf(&quot;\\nThread 2 Start\\n&quot;); for(int j = 0; j &lt; param[0]; j++) { if(i &gt; param[1]) { i = 0; } Sleep(100); } printf(&quot;\\nThread 2 End\\n&quot;);}int main() { int func1_param[2] = {70, 3}; int func2_param[2] = {30, 20}; HANDLE threadHandles[2]; //创建第一个线程，执行thread_func1 threadHandles[0] = CreateThread(NULL, //lpThreadAttributes 0, //dwStackSize thread_func1, //lpStartAddress func1_param, //lpParameter 0, //dwCreationFlags NULL); //lpThreadId if(NULL == threadHandles[0]) { //检查线程是否创建成功 printf(&quot;Create Thread 1 Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } //2秒后创建第二个线程，执行thread_func2 Sleep(2000); threadHandles[1] = CreateThread(NULL, //lpThreadAttributes 0, //dwStackSize thread_func2, //lpStartAddress func2_param, //lpParameter 0, //dwCreationFlags NULL); //lpThreadId if(NULL == threadHandles[1]) { //检查线程是否创建成功 printf(&quot;Create Thread 2 Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } WaitForMultipleObjects(2, threadHandles, TRUE, 100000); CloseHandle(threadHandles[0]); CloseHandle(threadHandles[1]); return 0;} 12345678&gt; threadtestThread 1 Start3. 6. 9. 12. 15. 18. 21. 24. 27. 30. 33. 36. 39. 42. 45. 48. 51. 54. 57.Thread 2 Start3. 6. 9. 12. 15. 18. 21. 3. 6. 9. 12. 15. 18. 21. 3. 6. 9. 12. 15. 18. 21. 3. 6. 9. 12. 15. 18. 21. 3. 6.Thread 2 End9. 12. 15. 18. 21. 24. 27. 30. 33. 36. 39. 42. 45. 48. 51. 54. 57. 60. 63. 66. 69.Thread 1 End 线程1开始后，i会不断增加，然后，当线程2开始后，i超过20便会被清零。线程2结束后，i又会不断增加，而不会被清零。 创建远程线程在Windows中，进程除了可以给自己创建线程，还可以给其他进程创建线程，这就是远程线程。创建远程线程需要用到CreateRemoteThread函数。 CreateRemoteThread函数123456789HANDLE CreateRemoteThread( HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); 和CreateThread相比，只多了一个hProcess参数，表示目标进程的句柄。此外，这里的lpStartAddress指的是目标进程中函数的内存地址，所以在正常使用时，远程线程的代码是在目标进程中本来就有的。 参数的详细解释可以查看Microsoft的文档： CreateRemoteThread function (processthreadsapi.h) 接下来，编写一个简单示例来说明这个函数的用法。 编写目标程序目标进程的代码中首先还是设置一个全局变量i，然后是main函数： 12345678int main() { printf(&quot;Process ID: %d\\n&quot;, GetCurrentProcessId()); while(1) { printf(&quot;%d. &quot;, i++); Sleep(100); } return 0;} main函数首先会打印自身的Process ID，然后就会不断地让全局变量i加一，并打印出来。 接下来，再编写一个函数thread_func： 12345678int thread_func() { while(1) { if(i &gt; 20) { i = 0; } Sleep(600); }} 由于main函数中并没有调用这个函数，因此正常运行目标程序，全局变量i并不会清零。 123&gt; programProcess ID: 140320. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 编写程序为目标进程开启远程线程首先通过反汇编工具（如IDA Pro）获取目标程序中thread_func的起始地址。我的机器上thread_func起始地址为0x401550。 然后就可以编写创建远程线程的代码： 1234567891011121314151617181920212223#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char **argv) { if(argc &lt; 0) { return -1; } HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, atoi(argv[1])); if(NULL == hProcess) { printf(&quot;Open Process Failed! (%d)\\n&quot;, GetLastError()); return -1; } //program中thread_func起始地址为0x401550 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, 0x401550, NULL, 0, NULL); if(NULL == hThread) { printf(&quot;Create Thread Failed! (%d)\\n&quot;, GetLastError()); return -1; } CloseHandle(hProcess); CloseHandle(hThread); return 0;} 首先通过OpenProcess获取目标进程的句柄。然后，再将目标进程句柄、thread_func起始内存地址等参数传入CreateRemoteThread当中。这样就可以在目标进程中开启远程线程执行thread_func中的代码了。 运行结果首先运行目标程序program，得知其进程ID为16500，然后再运行remotethread 16500，remotethread程序就可以根据16500获取目标进程的句柄，进而为目标程序开启远程线程。新的线程就会运行thread_func函数中的代码，从而实现对全局变量i清零的操作。之后，remotethread进程退出了，但由于thread_func线程是属于program进程的，因此仍然会继续运行，i会继续被清零。 12345678&gt; programProcess ID: 165000. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 58. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22.","link":"/2021/01/20/windows-thread-remote-thread/"}],"tags":[{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"进程","slug":"进程","link":"/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"内存","slug":"内存","link":"/tags/%E5%86%85%E5%AD%98/"},{"name":"线程","slug":"线程","link":"/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"远程线程","slug":"远程线程","link":"/tags/%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B/"}],"categories":[{"name":"Windows","slug":"Windows","link":"/categories/Windows/"}]}