{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/01/12/hello-world/"},{"title":"在Windows中使用CreateProcess创建子进程","text":"本文记录了在Windows中使用CreateProcessA创建子进程的方法。 CreateProcessA函数原型123456789101112BOOL CreateProcessA( LPCSTR lpApplicationName, //应用程序名 LPSTR lpCommandLine, //命令行 LPSECURITY_ATTRIBUTES lpProcessAttributes, //如果为NULL，则子进程不会继承新进程的句柄 LPSECURITY_ATTRIBUTES lpThreadAttributes, //如果为NULL，则子进程不会继承新线程的句柄 BOOL bInheritHandles, //父进程的可继承句柄是否继承给新的进程 DWORD dwCreationFlags, //控制子进程的创建过程和优先级的标志 LPVOID lpEnvironment, //如果为NULL，则新的进程会使用父进程的环境 LPCSTR lpCurrentDirectory, //如果为NULL，则新的进程与父进程会有相同目录 LPSTARTUPINFOA lpStartupInfo, //用于设置新进程的主窗口特性 LPPROCESS_INFORMATION lpProcessInformation //PROCESS_INFORMATION指针，用于获取新进程的信息); 本文只关心lpApplicationName, lpCommandLine, lpStartupInfo, lpProcessInformation 这四个参数。 简单示例接下来，写一个简单的示例来说明这个函数的基本用法。 编写程序作为子进程编写child.c，代码为： 12345678#include &lt;stdio.h&gt;int main(int argc, char **argv) { for(int i = 0; i &lt; argc; i++) { printf(&quot;argv[%d]: %s\\n&quot;, i, argv[i]); } return 0;} 功能很简单，就是打印argv字符串数组的内容。编译后在命令行中运行child 123456789 abcdefg !@#$%： 12345&gt; child 123456789 abcdefg !@#$%argv[0]: childargv[1]: 123456789argv[2]: abcdefgargv[3]: !@#$% 编写程序调用CreateProcessA创建子进程编写程序parent，代码如下： 12345678910111213141516171819#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;int main() { STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); CreateProcessA( &quot;child.exe&quot;, //lpApplicationName &quot;abcdefg !@#$%^&amp;&quot;, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation return 0;} parent会调用CreateProcessA，创建子进程child，而child则会打印argv数组： 123&gt; parentargv[0]: abcdefgargv[1]: !@#$%^&amp; child中argv的内容和lpCommandLine字符串的内容是一致的。 lpApplicationName可以为NULL，此时应用程序的名字为lpCommandLine中第一个被空格隔开的字符串： CreateProcessA function (processthreadsapi.h) 对简单示例的进一步完善对创建进程操作是否成功的判断CreateProcessA会返回BOOL类型的变量，表示本次创建进程的操作是否成功。因此，可以加上对函数返回值的判断： 1234567891011121314BOOL result = CreateProcessA( &quot;child.exe&quot;, //lpApplicationName &quot;abcdefg !@#$%^&amp;&quot;, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformationif(!result) { printf(&quot;Create Process Failed!\\n&quot;); return -1;} 创建进程失败时获取错误码如果CreateProcessA返回FALSE，则可以通过GetLastError获取错误码，GetLastError定义在头文件errhandlingapi.h中。 1234if(!result) { printf(&quot;Create Process Failed! Error Code:%d\\n&quot;, GetLastError()); return -1;} 在调用CreateProcessA之前，会通过STARTUPINFO si = {0};将STARTUPINFO结构体si的内容清零。现在将清零操作去掉，重新编译运行parent，看是否还能成功创建子进程： 12&gt; parentCreate Process Failed! Error Code:998 创建子进程失败了，错误码为998，查阅System Error Codes (500-999)： ERROR_NOACCESS 998 (0x3E6) Invalid access to memory location. 发生了对内存地址的无效访问。这说明STARTUPINFO结构体使用之前清零是有必要的。 通过PROCESS_INFORMATION结构体获取子进程信息CreateProcessA的最后一个参数为LPPROCESS_INFORMATION lpProcessInformation，是一个PROCESS_INFOMATION结构体指针。PROCESS_INFOMATION的定义为： 123456typedef struct _PROCESS_INFORMATION { HANDLE hProcess; HANDLE hThread; DWORD dwProcessId; DWORD dwThreadId;} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; CreateProcessA会创建一个进程和它的主线程，hProcess就是这个进程的句柄，hThread就是进程的主线程的句柄。dwProcessId和dwThreadId分别为进程和它的主线程的标识符ID。 简单示例中传入的参数为&amp;pi，因此就可以通过pi得到创建的进程以及其主线程的句柄和标识符了。添加如下代码，打印子进程的进程标识符： 1printf(&quot;Child Process ID: %d\\n&quot;, pi.dwProcessId); 运行parent： 1234&gt; parentChild Process ID: 13816argv[0]: abcdefgargv[1]: !@#$%^&amp; 父进程等待子进程执行结束在Linux中，父进程可以通过wait系统调用等待子进程执行完毕。Windows中也有类似的功能，即WaitForSingleObject。 WaitForSingleObject的函数原型为： 1234DWORD WaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds); 需要传入两个参数，hHandle为对象的句柄，dwMilliseconds为等待的毫秒数。如果对象结束，或对象没有结束但经过了dwMilliseconds毫秒，则等待完毕，进程继续执行后面的语句。 父进程可以通过PROCESS_INFORMATION结构体获取子进程的进程句柄，然后再将子进程的句柄传入WaitForSingleObject中，即可等待子进程执行完毕。 在打印子进程ID前，添加语句： 1WaitForSingleObject(pi.hProcess, 10000); 再运行parent，得到的结果为： 1234&gt; parentargv[0]: abcdefgargv[1]: !@#$%^&amp;Child Process ID: 3944 说明父进程会等待子进程child执行完毕后再打印子进程的ID。 关闭PROCESS_INFORMATION中的句柄一个更好的习惯是在PROCESS_INFORMATION中的句柄使用完毕后，用CloseHandle将其关闭。 If the function succeeds, be sure to call the CloseHandle function to close the hProcess and hThread handles when you are finished with them. Otherwise, when the child process exits, the system cannot clean up the process structures for the child process because the parent process still has open handles to the child process. However, the system will close these handles when the parent process terminates, so the structures related to the child process object would be cleaned up at this point. 在parent.c的末尾添加CloseHandle代码： 12CloseHandle(pi.hProcess);CloseHandle(pi.hThread); 最终，得到的完整的parent.c代码为： 123456789101112131415161718192021222324252627282930#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;#include &lt;errhandlingapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;handleapi.h&gt;int main() { STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); BOOL result = CreateProcessA( &quot;child.exe&quot;, //lpApplicationName &quot;abcdefg !@#$%^&amp;&quot;, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation if(!result) { printf(&quot;Create Process Failed! Error Code:%d\\n&quot;, GetLastError()); return -1; } WaitForSingleObject(pi.hProcess, 10000); printf(&quot;Child Process ID: %d\\n&quot;, pi.dwProcessId); CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0;}","link":"/2021/01/17/windows-createprocess/"},{"title":"Windows读写其他进程内存的方法","text":"本文记录了如何使用Windows提供的ReadProcessMemory和WriteProcessMemory对其他进程的内存空间进行读写操作。 ReadProcessMemory和WriteProcessMemory的函数原型1234567BOOL ReadProcessMemory( HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead); 1234567BOOL WriteProcessMemory( HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten); Microsoft的文档中有对每个参数的详细解释： ReadProcessMemory function (memoryapi.h) WriteProcessMemory function (memoryapi.h) 使用这两个函数，需要传入目标进程的句柄、想要读写内存的基地址、读写内存的大小等信息。在通过CreateProcess创建子进程时，可以通过PROCESS_INFORMATION结构体得到子进程的句柄。因此，先来看读写子进程内存的方法。 读写子进程内存编写子进程子进程的功能为打印全局变量i的值，并使变量i不断自增。 12345678910#include &lt;stdio.h&gt;#include &lt;synchapi.h&gt;int i;int main() { while(1) { printf(&quot;%d. &quot;, i++); Sleep(100); }} 运行结果为： 12&gt; child0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 编写父进程读取子进程内存父进程首先要通过CreateProcess创建子进程，然后通过PROCESS_INFORMATION结构体获取子进程的句柄。之后，再将句柄传入ReadProcessMemory，即可读取子进程的内存。 如果要让父进程修改子进程的全局变量i，则需要知道i的内存地址，这可以通过反汇编工具（如IDA Pro）获取。我使用的编译器会将全局变量i的内存地址设置为0x407970，不同编译器编译得到的child中i的内存地址可能不同。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;#include &lt;errhandlingapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;handleapi.h&gt;#include &lt;memoryapi.h&gt;int main() { //创建子进程 STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); BOOL result = CreateProcessA( &quot;child.exe&quot;, //lpApplicationName NULL, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation if(!result) { printf(&quot;Create Process Failed! Error Code:%d\\n&quot;, GetLastError()); return -1; } //读写子进程全局变量i，地址为0x407970 int childi; while(1) { ReadProcessMemory(pi.hProcess, (void *)0x407970, &amp;childi, sizeof(int), NULL); printf(&quot;\\nparent read child i: %d\\n&quot;, childi); Sleep(600); } CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0;} 运行parent： 12345678910111213&gt; parentparent read child i: 00. 1. 2. 3. 4. 5.parent read child i: 66. 7. 8. 9. 10. 11.parent read child i: 1212. 13. 14. 15. 16. 17.parent read child i: 1818. 19. 20. 21. 22. 23.parent read child i: 2424. 25. 26. 27. 28. 29.parent read child i: 30 可以看出parent成功读取了child中变量i的内容。 添加修改子进程内存的代码使用WriteProcessMemory可以修改子进程中i的值。在parent中添加代码： 12345678910//读写子进程全局变量i，地址为0x407970int childi;while(1) { ReadProcessMemory(pi.hProcess, (void *)0x407970, &amp;childi, sizeof(int), NULL); if(childi &gt; 20) { childi = 0; WriteProcessMemory(pi.hProcess, (void *)0x407970, &amp;childi, sizeof(int), NULL); } Sleep(600);} 当读取到的i大于20时，就将i清零，并写入子进程的内存当中。运行parent： 12345&gt; parent0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 0. 1. 2. 3. 4. 5. 6. i大于20后不久就会被清零。之所以没有立即清零是因为parent中有一个Sleep(600);。 读取其他进程的内存读写其他进程内存需要首先获取其句柄，这可以通过函数OpenProcess得到。 OpenProcess函数原型12345HANDLE OpenProcess( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId); 因此，知道了目标进程的进程标识符ProcessId，就可以获得其句柄了。 OpenProcess function (processthreadsapi.h) 编写目标进程代码目标进程会先调用GetCurrentProcessId获取自身的进程标识符并打印出来，然后就开始不断打印全局变量i的值并将i加一。 123456789101112#include &lt;stdio.h&gt;#include &lt;synchapi.h&gt;#include &lt;processthreadsapi.h&gt;int i;int main() { printf(&quot;My Process ID: %d\\n&quot;, GetCurrentProcessId()); while(1) { printf(&quot;%d. &quot;, i++); Sleep(100); }} 编写修改器代码修改器会先根据目标进程的ProcessId获取句柄，然后再调用ReadProcessMemory和WriteProcessMemory读写目标进程的全局变量i，当i大于20时清零。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;memoryapi.h&gt;#include &lt;errhandlingapi.h&gt;int main(int argc, char **argv) { if(argc &lt; 2) { printf(&quot;Usage: modifier [pid]\\n&quot;); return -1; } //OpenProcess获得目标进程的句柄 int targetPid = atoi(argv[1]); HANDLE hTarget = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, targetPid); if(NULL == hTarget) { printf(&quot;Open Process Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } //读写目标进程全局变量i，地址为0x407970 int targetI; BOOL result; while(1) { result = ReadProcessMemory(hTarget, (void *)0x407970, &amp;targetI, sizeof(int), NULL); if(!result) { printf(&quot;Read Process Memory Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } else if(targetI &gt; 20) { targetI = 0; result = WriteProcessMemory(hTarget, (void *)0x407970, &amp;targetI, sizeof(int), NULL); if(!result) { printf(&quot;Write Process Memory Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } } Sleep(600); } return 0;} 运行结果首先运行目标程序program，得到其进程标识符为4372，然后再运行修改器程序并传入参数4372，即modifier 4372，一段时间后终止修改器。最终，program的打印结果如下： 12345678910&gt; programMy Process ID: 43720. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 全局变量i一开始会不断自增，当修改器开始运行后，i的值便被清零，然后当i的值超过20后也会被清零。修改器停止运行后，i的值又会不断自增而不会被清零。","link":"/2021/01/19/windows-modify-process-memory/"}],"tags":[{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"进程","slug":"进程","link":"/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"内存","slug":"内存","link":"/tags/%E5%86%85%E5%AD%98/"}],"categories":[{"name":"Windows","slug":"Windows","link":"/categories/Windows/"}]}