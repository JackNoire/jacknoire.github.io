<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>在Windows中使用CreateProcess创建子进程 - JackNoire&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="JackNoire&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="JackNoire&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="本文记录了在Windows中使用CreateProcessA创建子进程的方法。"><meta property="og:type" content="blog"><meta property="og:title" content="在Windows中使用CreateProcess创建子进程"><meta property="og:url" content="https://jacknoire.github.io/2021/01/17/windows-createprocess/"><meta property="og:site_name" content="JackNoire&#039;s Blog"><meta property="og:description" content="本文记录了在Windows中使用CreateProcessA创建子进程的方法。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://jacknoire.github.io/img/og_image.png"><meta property="article:published_time" content="2021-01-17T08:34:58.000Z"><meta property="article:modified_time" content="2021-01-17T14:03:05.595Z"><meta property="article:author" content="JackNoire"><meta property="article:tag" content="Windows"><meta property="article:tag" content="进程"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://jacknoire.github.io/2021/01/17/windows-createprocess/"},"headline":"JackNoire's Blog","image":["https://jacknoire.github.io/img/og_image.png"],"datePublished":"2021-01-17T08:34:58.000Z","dateModified":"2021-01-17T14:03:05.595Z","author":{"@type":"Person","name":"JackNoire"},"description":"本文记录了在Windows中使用CreateProcessA创建子进程的方法。"}</script><link rel="canonical" href="https://jacknoire.github.io/2021/01/17/windows-createprocess/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/vs.min.css"><link rel="stylesheet"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.gif" alt="JackNoire&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-17T08:34:58.000Z" title="2021/1/17 下午4:34:58">2021-01-17</time>发表</span><span class="level-item"><time dateTime="2021-01-17T14:03:05.595Z" title="2021/1/17 下午10:03:05">2021-01-17</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Windows/">Windows</a></span><span class="level-item">10 分钟读完 (大约1450个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">在Windows中使用CreateProcess创建子进程</h1><div class="content"><p>本文记录了在Windows中使用CreateProcessA创建子进程的方法。</p>
<a id="more"></a>

<h2 id="CreateProcessA函数原型"><a href="#CreateProcessA函数原型" class="headerlink" title="CreateProcessA函数原型"></a>CreateProcessA函数原型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateProcessA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR                lpApplicationName,    <span class="comment">//应用程序名</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSTR                 lpCommandLine,        <span class="comment">//命令行</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpProcessAttributes,  <span class="comment">//如果为NULL，则子进程不会继承新进程的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpThreadAttributes,   <span class="comment">//如果为NULL，则子进程不会继承新线程的句柄</span></span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL                  bInheritHandles,      <span class="comment">//父进程的可继承句柄是否继承给新的进程</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD                 dwCreationFlags,      <span class="comment">//控制子进程的创建过程和优先级的标志</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID                lpEnvironment,        <span class="comment">//如果为NULL，则新的进程会使用父进程的环境</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR                lpCurrentDirectory,   <span class="comment">//如果为NULL，则新的进程与父进程会有相同目录</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPSTARTUPINFOA        lpStartupInfo,        <span class="comment">//用于设置新进程的主窗口特性</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPPROCESS_INFORMATION lpProcessInformation  <span class="comment">//PROCESS_INFORMATION指针，用于获取新进程的信息</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>本文只关心<code>lpApplicationName</code>, <code>lpCommandLine</code>, <code>lpStartupInfo</code>, <code>lpProcessInformation</code> 这四个参数。</p>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>接下来，写一个简单的示例来说明这个函数的基本用法。</p>
<h3 id="编写程序作为子进程"><a href="#编写程序作为子进程" class="headerlink" title="编写程序作为子进程"></a>编写程序作为子进程</h3><p>编写child.c，代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能很简单，就是打印argv字符串数组的内容。编译后在命令行中运行<code>child 123456789 abcdefg !@#$%</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; child 123456789 abcdefg !@#$%</span><br><span class="line">argv[0]: child</span><br><span class="line">argv[1]: 123456789</span><br><span class="line">argv[2]: abcdefg</span><br><span class="line">argv[3]: !@#$%</span><br></pre></td></tr></table></figure>
<h3 id="编写程序调用CreateProcessA创建子进程"><a href="#编写程序调用CreateProcessA创建子进程" class="headerlink" title="编写程序调用CreateProcessA创建子进程"></a>编写程序调用CreateProcessA创建子进程</h3><p>编写程序parent，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;processthreadsapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    STARTUPINFO si = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">    CreateProcessA( <span class="string">&quot;child.exe&quot;</span>,        <span class="comment">//lpApplicationName</span></span><br><span class="line">                    <span class="string">&quot;abcdefg !@#$%^&amp;&quot;</span>,  <span class="comment">//lpCommandLine</span></span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    FALSE,</span><br><span class="line">                    <span class="number">0</span>,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    &amp;si,    <span class="comment">//lpStartupInfo</span></span><br><span class="line">                    &amp;pi);   <span class="comment">//lpProcessInformation</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>parent会调用CreateProcessA，创建子进程child，而child则会打印argv数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; parent</span><br><span class="line">argv[0]: abcdefg</span><br><span class="line">argv[1]: !@#$%^&amp;</span><br></pre></td></tr></table></figure>
<p>child中argv的内容和lpCommandLine字符串的内容是一致的。</p>
<p>lpApplicationName可以为NULL，此时应用程序的名字为lpCommandLine中第一个被空格隔开的字符串：</p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcessA function (processthreadsapi.h)</a></p>
<h2 id="对简单示例的进一步完善"><a href="#对简单示例的进一步完善" class="headerlink" title="对简单示例的进一步完善"></a>对简单示例的进一步完善</h2><h3 id="对创建进程操作是否成功的判断"><a href="#对创建进程操作是否成功的判断" class="headerlink" title="对创建进程操作是否成功的判断"></a>对创建进程操作是否成功的判断</h3><p>CreateProcessA会返回BOOL类型的变量，表示本次创建进程的操作是否成功。因此，可以加上对函数返回值的判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BOOL result = CreateProcessA( <span class="string">&quot;child.exe&quot;</span>,        <span class="comment">//lpApplicationName</span></span><br><span class="line">                <span class="string">&quot;abcdefg !@#$%^&amp;&quot;</span>,  <span class="comment">//lpCommandLine</span></span><br><span class="line">                <span class="literal">NULL</span>,</span><br><span class="line">                <span class="literal">NULL</span>,</span><br><span class="line">                FALSE,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                <span class="literal">NULL</span>,</span><br><span class="line">                <span class="literal">NULL</span>,</span><br><span class="line">                &amp;si,    <span class="comment">//lpStartupInfo</span></span><br><span class="line">                &amp;pi);   <span class="comment">//lpProcessInformation</span></span><br><span class="line"><span class="keyword">if</span>(!result) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Create Process Failed!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建进程失败时获取错误码"><a href="#创建进程失败时获取错误码" class="headerlink" title="创建进程失败时获取错误码"></a>创建进程失败时获取错误码</h3><p>如果CreateProcessA返回FALSE，则可以通过GetLastError获取错误码，GetLastError定义在头文件errhandlingapi.h中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!result) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Create Process Failed! Error Code:%d\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用CreateProcessA之前，会通过<code>STARTUPINFO si = &#123;0&#125;;</code>将STARTUPINFO结构体si的内容清零。现在将清零操作去掉，重新编译运行parent，看是否还能成功创建子进程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; parent</span><br><span class="line">Create Process Failed! Error Code:998</span><br></pre></td></tr></table></figure>
<p>创建子进程失败了，错误码为998，查阅<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/debug/system-error-codes--500-999-">System Error Codes (500-999)</a>：</p>
<blockquote>
<p><strong>ERROR_NOACCESS</strong></p>
<ul>
<li>998 (0x3E6)</li>
<li>Invalid access to memory location.</li>
</ul>
</blockquote>
<p>发生了对内存地址的无效访问。这说明STARTUPINFO结构体使用之前清零是有必要的。</p>
<h3 id="通过PROCESS-INFORMATION结构体获取子进程信息"><a href="#通过PROCESS-INFORMATION结构体获取子进程信息" class="headerlink" title="通过PROCESS_INFORMATION结构体获取子进程信息"></a>通过PROCESS_INFORMATION结构体获取子进程信息</h3><p>CreateProcessA的最后一个参数为<code>LPPROCESS_INFORMATION lpProcessInformation</code>，是一个PROCESS_INFOMATION结构体指针。PROCESS_INFOMATION的定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_INFORMATION</span> &#123;</span></span><br><span class="line">  HANDLE hProcess;</span><br><span class="line">  HANDLE hThread;</span><br><span class="line">  DWORD  dwProcessId;</span><br><span class="line">  DWORD  dwThreadId;</span><br><span class="line">&#125; PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;</span><br></pre></td></tr></table></figure>
<p>CreateProcessA会创建一个进程和它的主线程，hProcess就是这个进程的句柄，hThread就是进程的主线程的句柄。dwProcessId和dwThreadId分别为进程和它的主线程的标识符ID。</p>
<p>简单示例中传入的参数为&amp;pi，因此就可以通过pi得到创建的进程以及其主线程的句柄和标识符了。添加如下代码，打印子进程的进程标识符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Child Process ID: %d\n&quot;</span>, pi.dwProcessId);</span><br></pre></td></tr></table></figure>
<p>运行parent：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; parent</span><br><span class="line">Child Process ID: 13816</span><br><span class="line">argv[0]: abcdefg</span><br><span class="line">argv[1]: !@#$%^&amp;</span><br></pre></td></tr></table></figure>
<h3 id="父进程等待子进程执行结束"><a href="#父进程等待子进程执行结束" class="headerlink" title="父进程等待子进程执行结束"></a>父进程等待子进程执行结束</h3><p>在Linux中，父进程可以通过wait系统调用等待子进程执行完毕。Windows中也有类似的功能，即<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject</a>。</p>
<p>WaitForSingleObject的函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD  dwMilliseconds</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>需要传入两个参数，hHandle为对象的句柄，dwMilliseconds为等待的毫秒数。如果对象结束，或对象没有结束但经过了dwMilliseconds毫秒，则等待完毕，进程继续执行后面的语句。</p>
<p>父进程可以通过PROCESS_INFORMATION结构体获取子进程的进程句柄，然后再将子进程的句柄传入WaitForSingleObject中，即可等待子进程执行完毕。</p>
<p>在打印子进程ID前，添加语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WaitForSingleObject(pi.hProcess, <span class="number">10000</span>);</span><br></pre></td></tr></table></figure>
<p>再运行parent，得到的结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; parent</span><br><span class="line">argv[0]: abcdefg</span><br><span class="line">argv[1]: !@#$%^&amp;</span><br><span class="line">Child Process ID: 3944</span><br></pre></td></tr></table></figure>
<p>说明父进程会等待子进程child执行完毕后再打印子进程的ID。</p>
<h3 id="关闭PROCESS-INFORMATION中的句柄"><a href="#关闭PROCESS-INFORMATION中的句柄" class="headerlink" title="关闭PROCESS_INFORMATION中的句柄"></a>关闭PROCESS_INFORMATION中的句柄</h3><p>一个更好的习惯是在PROCESS_INFORMATION中的句柄使用完毕后，用CloseHandle将其关闭。</p>
<blockquote>
<p>If the function succeeds, be sure to call the <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/desktop/api/handleapi/nf-handleapi-closehandle">CloseHandle</a> function to close the <strong>hProcess</strong> and <strong>hThread</strong> handles when you are finished with them. Otherwise, when the child process exits, the system cannot clean up the process structures for the child process because the parent process still has open handles to the child process. However, the system will close these handles when the parent process terminates, so the structures related to the child process object would be cleaned up at this point.</p>
</blockquote>
<p>在parent.c的末尾添加CloseHandle代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CloseHandle(pi.hProcess);</span><br><span class="line">CloseHandle(pi.hThread);</span><br></pre></td></tr></table></figure>
<p>最终，得到的完整的parent.c代码为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;processthreadsapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errhandlingapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;synchapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;handleapi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    STARTUPINFO si = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(si);</span><br><span class="line">    BOOL result = CreateProcessA( <span class="string">&quot;child.exe&quot;</span>,        <span class="comment">//lpApplicationName</span></span><br><span class="line">                    <span class="string">&quot;abcdefg !@#$%^&amp;&quot;</span>,  <span class="comment">//lpCommandLine</span></span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    FALSE,</span><br><span class="line">                    <span class="number">0</span>,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    <span class="literal">NULL</span>,</span><br><span class="line">                    &amp;si,    <span class="comment">//lpStartupInfo</span></span><br><span class="line">                    &amp;pi);   <span class="comment">//lpProcessInformation</span></span><br><span class="line">    <span class="keyword">if</span>(!result) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Create Process Failed! Error Code:%d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WaitForSingleObject(pi.hProcess, <span class="number">10000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Child Process ID: %d\n&quot;</span>, pi.dwProcessId);</span><br><span class="line">    CloseHandle(pi.hProcess);</span><br><span class="line">    CloseHandle(pi.hThread);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Windows/">Windows</a><a class="link-muted mr-2" rel="tag" href="/tags/%E8%BF%9B%E7%A8%8B/">进程</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/01/19/windows-modify-process-memory/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Windows读写其他进程内存的方法</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/01/12/hello-world/"><span class="level-item">Hello World</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#CreateProcessA函数原型"><span class="level-left"><span class="level-item">1</span><span class="level-item">CreateProcessA函数原型</span></span></a></li><li><a class="level is-mobile" href="#简单示例"><span class="level-left"><span class="level-item">2</span><span class="level-item">简单示例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#编写程序作为子进程"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">编写程序作为子进程</span></span></a></li><li><a class="level is-mobile" href="#编写程序调用CreateProcessA创建子进程"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">编写程序调用CreateProcessA创建子进程</span></span></a></li></ul></li><li><a class="level is-mobile" href="#对简单示例的进一步完善"><span class="level-left"><span class="level-item">3</span><span class="level-item">对简单示例的进一步完善</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#对创建进程操作是否成功的判断"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">对创建进程操作是否成功的判断</span></span></a></li><li><a class="level is-mobile" href="#创建进程失败时获取错误码"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">创建进程失败时获取错误码</span></span></a></li><li><a class="level is-mobile" href="#通过PROCESS-INFORMATION结构体获取子进程信息"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">通过PROCESS_INFORMATION结构体获取子进程信息</span></span></a></li><li><a class="level is-mobile" href="#父进程等待子进程执行结束"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">父进程等待子进程执行结束</span></span></a></li><li><a class="level is-mobile" href="#关闭PROCESS-INFORMATION中的句柄"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">关闭PROCESS_INFORMATION中的句柄</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Windows/"><span class="level-start"><span class="level-item">Windows</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-01-19T09:49:39.000Z">2021-01-19</time></p><p class="title"><a href="/2021/01/19/windows-modify-process-memory/">Windows读写其他进程内存的方法</a></p><p class="categories"><a href="/categories/Windows/">Windows</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-01-17T08:34:58.000Z">2021-01-17</time></p><p class="title"><a href="/2021/01/17/windows-createprocess/">在Windows中使用CreateProcess创建子进程</a></p><p class="categories"><a href="/categories/Windows/">Windows</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-01-12T13:54:53.176Z">2021-01-12</time></p><p class="title"><a href="/2021/01/12/hello-world/">Hello World</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Windows/"><span class="tag">Windows</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%86%85%E5%AD%98/"><span class="tag">内存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%BF%9B%E7%A8%8B/"><span class="tag">进程</span><span class="tag">2</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.gif" alt="JackNoire&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 JackNoire</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>